// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
// ** Copyright UCAR (c) 1992 - 2016
// ** University Corporation for Atmospheric Research(UCAR)
// ** National Center for Atmospheric Research(NCAR)
// ** Boulder, Colorado, USA
// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
////////////////////////////////////////////
// Params.cc
//
// TDRP C++ code file for class 'Params'.
//
// Code for program MosSpdb2Html
//
// This file has been automatically
// generated by TDRP, do not modify.
//
/////////////////////////////////////////////

/**
 *
 * @file Params.cc
 *
 * @class Params
 *
 * This class is automatically generated by the Table
 * Driven Runtime Parameters (TDRP) system
 *
 * @note Source is automatically generated from
 *       paramdef file at compile time, do not modify
 *       since modifications will be overwritten.
 *
 *
 * @author Automatically generated
 *
 */
using namespace std;

#include "Params.hh"
#include <cstring>

  ////////////////////////////////////////////
  // Default constructor
  //

  Params::Params()

  {

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // initialize table

    _init();

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Copy constructor
  //

  Params::Params(const Params& source)

  {

    // sync the source object

    source.sync();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // copy table

    tdrpCopyTable((TDRPtable *) source._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Destructor
  //

  Params::~Params()

  {

    // free up

    freeAll();

  }

  ////////////////////////////////////////////
  // Assignment
  //

  void Params::operator=(const Params& other)

  {

    // sync the other object

    other.sync();

    // free up any existing memory

    freeAll();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // copy table

    tdrpCopyTable((TDRPtable *) other._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = other._exitDeferred;

  }

  ////////////////////////////////////////////
  // loadFromArgs()
  //
  // Loads up TDRP using the command line args.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   char **params_path_p:
  //     If this is non-NULL, it is set to point to the path
  //     of the params file used.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromArgs(int argc, char **argv,
                           char **override_list,
                           char **params_path_p,
                           bool defer_exit)
  {
    int exit_deferred;
    if (_tdrpLoadFromArgs(argc, argv,
                          _table, &_start_,
                          override_list, params_path_p,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadApplyArgs()
  //
  // Loads up TDRP using the params path passed in, and applies
  // the command line args for printing and checking.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   const char *param_file_path: the parameter file to be read in
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadApplyArgs(const char *params_path,
                            int argc, char **argv,
                            char **override_list,
                            bool defer_exit)
  {
    int exit_deferred;
    if (tdrpLoadApplyArgs(params_path, argc, argv,
                          _table, &_start_,
                          override_list,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  //

  bool Params::isArgValid(const char *arg)
  {
    return (tdrpIsArgValid(arg));
  }

  ////////////////////////////////////////////
  // load()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to load
  // up more than one class for a single application. It is a
  // lower-level routine than loadFromArgs, and hence more
  // flexible, but the programmer must do more work.
  //
  //   const char *param_file_path: the parameter file to be read in.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::load(const char *param_file_path,
                   char **override_list,
                   int expand_env, int debug)
  {
    if (tdrpLoad(param_file_path,
                 _table, &_start_,
                 override_list,
                 expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadFromBuf()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to
  // load up more than one module for a single application,
  // using buffers which have been read from a specified source.
  //
  //   const char *param_source_str: a string which describes the
  //     source of the parameter information. It is used for
  //     error reporting only.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   const char *inbuf: the input buffer
  //
  //   int inlen: length of the input buffer
  //
  //   int start_line_num: the line number in the source which
  //     corresponds to the start of the buffer.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromBuf(const char *param_source_str,
                          char **override_list,
                          const char *inbuf, int inlen,
                          int start_line_num,
                          int expand_env, int debug)
  {
    if (tdrpLoadFromBuf(param_source_str,
                        _table, &_start_,
                        override_list,
                        inbuf, inlen, start_line_num,
                        expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadDefaults()
  //
  // Loads up default params for a given class.
  //
  // See load() for more detailed info.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadDefaults(int expand_env)
  {
    if (tdrpLoad(NULL,
                 _table, &_start_,
                 NULL, expand_env, FALSE)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // sync()
  //
  // Syncs the user struct data back into the parameter table,
  // in preparation for printing.
  //
  // This function alters the table in a consistent manner.
  // Therefore it can be regarded as const.
  //

  void Params::sync(void) const
  {
    tdrpUser2Table(_table, (char *) &_start_);
  }

  ////////////////////////////////////////////
  // print()
  // 
  // Print params file
  //
  // The modes supported are:
  //
  //   PRINT_SHORT:   main comments only, no help or descriptions
  //                  structs and arrays on a single line
  //   PRINT_NORM:    short + descriptions and help
  //   PRINT_LONG:    norm  + arrays and structs expanded
  //   PRINT_VERBOSE: long  + private params included
  //

  void Params::print(FILE *out, tdrp_print_mode_t mode)
  {
    tdrpPrint(out, _table, _className, mode);
  }

  ////////////////////////////////////////////
  // checkAllSet()
  //
  // Return TRUE if all set, FALSE if not.
  //
  // If out is non-NULL, prints out warning messages for those
  // parameters which are not set.
  //

  int Params::checkAllSet(FILE *out)
  {
    return (tdrpCheckAllSet(out, _table, &_start_));
  }

  //////////////////////////////////////////////////////////////
  // checkIsSet()
  //
  // Return TRUE if parameter is set, FALSE if not.
  //
  //

  int Params::checkIsSet(const char *paramName)
  {
    return (tdrpCheckIsSet(paramName, _table, &_start_));
  }

  ////////////////////////////////////////////
  // freeAll()
  //
  // Frees up all TDRP dynamic memory.
  //

  void Params::freeAll(void)
  {
    tdrpFreeAll(_table, &_start_);
  }

  ////////////////////////////////////////////
  // usage()
  //
  // Prints out usage message for TDRP args as passed
  // in to loadFromArgs().
  //

  void Params::usage(ostream &out)
  {
    out << "TDRP args: [options as below]\n"
        << "   [ -params/--params path ] specify params file path\n"
        << "   [ -check_params/--check_params] check which params are not set\n"
        << "   [ -print_params/--print_params [mode]] print parameters\n"
        << "     using following modes, default mode is 'norm'\n"
        << "       short:   main comments only, no help or descr\n"
        << "                structs and arrays on a single line\n"
        << "       norm:    short + descriptions and help\n"
        << "       long:    norm  + arrays and structs expanded\n"
        << "       verbose: long  + private params included\n"
        << "       short_expand:   short with env vars expanded\n"
        << "       norm_expand:    norm with env vars expanded\n"
        << "       long_expand:    long with env vars expanded\n"
        << "       verbose_expand: verbose with env vars expanded\n"
        << "   [ -tdrp_debug] debugging prints for tdrp\n"
        << "   [ -tdrp_usage] print this usage\n";
  }

  ////////////////////////////////////////////
  // arrayRealloc()
  //
  // Realloc 1D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::arrayRealloc(const char *param_name, int new_array_n)
  {
    if (tdrpArrayRealloc(_table, &_start_,
                         param_name, new_array_n)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // array2DRealloc()
  //
  // Realloc 2D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::array2DRealloc(const char *param_name,
                             int new_array_n1,
                             int new_array_n2)
  {
    if (tdrpArray2DRealloc(_table, &_start_, param_name,
                           new_array_n1, new_array_n2)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // _init()
  //
  // Class table initialization function.
  //
  //

  void Params::_init()

  {

    TDRPtable *tt = _table;

    // Parameter 'Comment 0'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 0");
    tt->comment_hdr = tdrpStrDup("MosSpdb2Html reads an SPDB database of METAR staiton\nreports and produces HTML output. The program triggers\nat regular intervals and uses the LookBack and LookAhead\nparameters to get a temporal window to process data in.\n\nData are written to an output directory where they are\noverwritten as new data become available, and to an\narchive directory where the file name have both the valid\ntime and the archive time, and so are not overwritten.\n\nNiles Oien, February 2001");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'TriggerUrl'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("TriggerUrl");
    tt->descr = tdrpStrDup("URL to trigger off, typically of the form\nspdbp:://host.domain:[port]:dir/dir");
    tt->help = tdrpStrDup("This parameter is also used in the generation of the\ntotal MOS tables.");
    tt->val_offset = (char *) &TriggerUrl - &_start_;
    tt->single_val.s = tdrpStrDup("spdbp:://localhost::spdb/ExtractedFromModel");
    tt++;
    
    // Parameter 'OutDir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("OutDir");
    tt->descr = tdrpStrDup("Output directory");
    tt->help = tdrpStrDup("Forecast HTML files are written here.");
    tt->val_offset = (char *) &OutDir - &_start_;
    tt->single_val.s = tdrpStrDup("$(RAP_DATA_DIR)/web/mos/html");
    tt++;
    
    // Parameter 'ArchiveDir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("ArchiveDir");
    tt->descr = tdrpStrDup("Archive directory");
    tt->help = tdrpStrDup("Archived HTML files are written here.");
    tt->val_offset = (char *) &ArchiveDir - &_start_;
    tt->single_val.s = tdrpStrDup("$(RAP_DATA_DIR)/web/mos/archive");
    tt++;
    
    // Parameter 'Instance'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("Instance");
    tt->descr = tdrpStrDup("Instance to check in to Procmap with");
    tt->help = tdrpStrDup("Set to something unique.");
    tt->val_offset = (char *) &Instance - &_start_;
    tt->single_val.s = tdrpStrDup("primary");
    tt++;
    
    // Parameter 'Mode'
    // ctype is '_mode'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("Mode");
    tt->descr = tdrpStrDup("Operation mode");
    tt->help = tdrpStrDup("Archive mode automatically invoked by -interval option.");
    tt->val_offset = (char *) &Mode - &_start_;
    tt->enum_def.name = tdrpStrDup("mode");
    tt->enum_def.nfields = 2;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("ARCHIVE");
      tt->enum_def.fields[0].val = ARCHIVE;
      tt->enum_def.fields[1].name = tdrpStrDup("REALTIME");
      tt->enum_def.fields[1].val = REALTIME;
    tt->single_val.e = REALTIME;
    tt++;
    
    // Parameter 'LookBack'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("LookBack");
    tt->descr = tdrpStrDup("Look back time, seconds.");
    tt->help = tdrpStrDup("Program will look back by this time from trigger time.");
    tt->val_offset = (char *) &LookBack - &_start_;
    tt->single_val.i = 0;
    tt++;
    
    // Parameter 'LookAhead'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("LookAhead");
    tt->descr = tdrpStrDup("Look ahead time, seconds.");
    tt->help = tdrpStrDup("Program will look ahead by this time from trigger time.");
    tt->val_offset = (char *) &LookAhead - &_start_;
    tt->single_val.i = 3600;
    tt++;
    
    // Parameter 'TriggerInterval'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("TriggerInterval");
    tt->descr = tdrpStrDup("Trigger interval, seconds.");
    tt->help = tdrpStrDup("Program will trigger regularly at this interval.");
    tt->val_offset = (char *) &TriggerInterval - &_start_;
    tt->single_val.i = 1800;
    tt++;
    
    // Parameter 'PMU_String'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("PMU_String");
    tt->descr = tdrpStrDup("PMU registration string.");
    tt->help = tdrpStrDup("While waiting for data the program registers with this string.");
    tt->val_offset = (char *) &PMU_String - &_start_;
    tt->single_val.s = tdrpStrDup("Waiting for data");
    tt++;
    
    // Parameter 'Debug'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("Debug");
    tt->descr = tdrpStrDup("Debug flag.");
    tt->help = tdrpStrDup("Set for debug output.");
    tt->val_offset = (char *) &Debug - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Verbose'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("Verbose");
    tt->descr = tdrpStrDup("Verbose debug flag.");
    tt->help = tdrpStrDup("Set for more verbose output.");
    tt->val_offset = (char *) &Verbose - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'CeilingReplaceValues'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("CeilingReplaceValues");
    tt->descr = tdrpStrDup("Replacement values for Ceiling, Km");
    tt->help = tdrpStrDup("If a ceiling value is in this list, then the actual value\nis not printed out to the web page - instead, the string\nfrom the CeilingReplaceString array is used. Thus, values\nthat have special meaning (like missing or unlimited visibility\nvalues) are not printed to the web.");
    tt->array_offset = (char *) &_CeilingReplaceValues - &_start_;
    tt->array_n_offset = (char *) &CeilingReplaceValues_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(float);
    tt->array_n = 2;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].f = 0;
      tt->array_vals[1].f = 10000;
    tt++;
    
    // Parameter 'CeilingReplaceStrings'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("CeilingReplaceStrings");
    tt->descr = tdrpStrDup("Replacement strings for CeilingReplaceValues - the\nCeilingReplaceValues and CeilingReplaceStrings arrays\nshould be the same length.");
    tt->help = tdrpStrDup("These strings are used to replace special values for ceiling.");
    tt->array_offset = (char *) &_CeilingReplaceStrings - &_start_;
    tt->array_n_offset = (char *) &CeilingReplaceStrings_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(char*);
    tt->array_n = 2;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].s = tdrpStrDup("UNKNOWN");
      tt->array_vals[1].s = tdrpStrDup("UNLIMITED");
    tt++;
    
    // Parameter 'VisibilityReplaceValues'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("VisibilityReplaceValues");
    tt->descr = tdrpStrDup("Replacement values for Visibility, Km");
    tt->help = tdrpStrDup("If a Visibility value is in this list, then the actual value\nis not printed out to the web page - instead, the string\nfrom the VisibilityReplaceString array is used. Thus, values\nthat have special meaning (like missing or unlimited visibility\nvalues) are not printed to the web.");
    tt->array_offset = (char *) &_VisibilityReplaceValues - &_start_;
    tt->array_n_offset = (char *) &VisibilityReplaceValues_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(float);
    tt->array_n = 2;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].f = 0;
      tt->array_vals[1].f = 10000;
    tt++;
    
    // Parameter 'VisibilityReplaceStrings'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("VisibilityReplaceStrings");
    tt->descr = tdrpStrDup("Replacement strings for VisibilityReplaceValues - the\nVisibilityReplaceValues and VisibilityReplaceStrings arrays\nshould be the same length.");
    tt->help = tdrpStrDup("These strings are used to replace special values for Visibility.");
    tt->array_offset = (char *) &_VisibilityReplaceStrings - &_start_;
    tt->array_n_offset = (char *) &VisibilityReplaceStrings_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(char*);
    tt->array_n = 2;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].s = tdrpStrDup("UNKNOWN");
      tt->array_vals[1].s = tdrpStrDup("UNLIMITED");
    tt++;
    
    // Parameter 'MaxVisibility'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("MaxVisibility");
    tt->descr = tdrpStrDup("Max value for Visibility, Km.");
    tt->help = tdrpStrDup("Similar to MaxCeiling parameter, see below.");
    tt->val_offset = (char *) &MaxVisibility - &_start_;
    tt->single_val.f = 10;
    tt++;
    
    // Parameter 'MinVisibility'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("MinVisibility");
    tt->descr = tdrpStrDup("Min value for Visibility, Km.");
    tt->help = tdrpStrDup("If vis is less than this, it is simply described\nas being less than this rather than giving a\nnumerical value. Similar to MaxVisibility");
    tt->val_offset = (char *) &MinVisibility - &_start_;
    tt->single_val.f = 0.25;
    tt++;
    
    // Parameter 'MaxCeiling'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("MaxCeiling");
    tt->descr = tdrpStrDup("Max value for Ceiling, feet.");
    tt->help = tdrpStrDup("Values greater than this are described as being greater than this\nas opposed to being listed directly, ie. if this is set to 10000.0\nfeet and the actual ceiling is 11000 feet then the display shows\nGREATER THAN 10000 feet as opposed to 11000 feet.");
    tt->val_offset = (char *) &MaxCeiling - &_start_;
    tt->single_val.f = 10000;
    tt++;
    
    // Parameter 'CalmWindThreshold'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("CalmWindThreshold");
    tt->descr = tdrpStrDup("Calm wind threshold, knots.");
    tt->help = tdrpStrDup("If the wind speed is less than this, the display simply describes\nconditions as calm. This parameter is used for the generation\nof the total output table as well.");
    tt->val_offset = (char *) &CalmWindThreshold - &_start_;
    tt->single_val.f = 2.5;
    tt++;
    
    // Parameter 'Comment 1'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 1");
    tt->comment_hdr = tdrpStrDup(" QUALITY CONTROL PARAMETERS ");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'RelHumRange'
    // ctype is '_MinMax_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("RelHumRange");
    tt->descr = tdrpStrDup("Accepted range for relative humidity, percent.");
    tt->help = tdrpStrDup("If the values are outside this range then they are\nmarked as missing. Note that the relative humidity\nis not now displayed, but it is used in the computation of the\ndew point, which is displayed.");
    tt->val_offset = (char *) &RelHumRange - &_start_;
    tt->struct_def.name = tdrpStrDup("MinMax_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("float");
      tt->struct_def.fields[0].fname = tdrpStrDup("Min");
      tt->struct_def.fields[0].ptype = FLOAT_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &RelHumRange.Min - (char *) &RelHumRange;
      tt->struct_def.fields[1].ftype = tdrpStrDup("float");
      tt->struct_def.fields[1].fname = tdrpStrDup("Max");
      tt->struct_def.fields[1].ptype = FLOAT_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &RelHumRange.Max - (char *) &RelHumRange;
    tt->n_struct_vals = 2;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].f = 0;
      tt->struct_vals[1].f = 100;
    tt++;
    
    // Parameter 'PressureRange'
    // ctype is '_MinMax_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("PressureRange");
    tt->descr = tdrpStrDup("Accepted range for pressure, hPa.");
    tt->help = tdrpStrDup("If the values are outside this range then they are marked as missing.");
    tt->val_offset = (char *) &PressureRange - &_start_;
    tt->struct_def.name = tdrpStrDup("MinMax_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("float");
      tt->struct_def.fields[0].fname = tdrpStrDup("Min");
      tt->struct_def.fields[0].ptype = FLOAT_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &PressureRange.Min - (char *) &PressureRange;
      tt->struct_def.fields[1].ftype = tdrpStrDup("float");
      tt->struct_def.fields[1].fname = tdrpStrDup("Max");
      tt->struct_def.fields[1].ptype = FLOAT_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &PressureRange.Max - (char *) &PressureRange;
    tt->n_struct_vals = 2;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].f = 950;
      tt->struct_vals[1].f = 1050;
    tt++;
    
    // Parameter 'TempRange'
    // ctype is '_MinMax_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("TempRange");
    tt->descr = tdrpStrDup("Accepted range for temperature, degrees celcius.");
    tt->help = tdrpStrDup("If the values are outside this range then they are marked as missing.");
    tt->val_offset = (char *) &TempRange - &_start_;
    tt->struct_def.name = tdrpStrDup("MinMax_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("float");
      tt->struct_def.fields[0].fname = tdrpStrDup("Min");
      tt->struct_def.fields[0].ptype = FLOAT_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &TempRange.Min - (char *) &TempRange;
      tt->struct_def.fields[1].ftype = tdrpStrDup("float");
      tt->struct_def.fields[1].fname = tdrpStrDup("Max");
      tt->struct_def.fields[1].ptype = FLOAT_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &TempRange.Max - (char *) &TempRange;
    tt->n_struct_vals = 2;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].f = -20;
      tt->struct_vals[1].f = 30;
    tt++;
    
    // Parameter 'MaxWindSpeed'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("MaxWindSpeed");
    tt->descr = tdrpStrDup("Maximum wind speed, knots.");
    tt->help = tdrpStrDup("If the wind speed exceeds this value it is marked as missing.");
    tt->val_offset = (char *) &MaxWindSpeed - &_start_;
    tt->single_val.f = 250;
    tt++;
    
    // Parameter 'Comment 2'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 2");
    tt->comment_hdr = tdrpStrDup("Parameters pertaining to the Total Tables which\nshow the trend in the weather. Only generated in REALTIME mode.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'MetarUrl'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("MetarUrl");
    tt->descr = tdrpStrDup("URL to read actual station reports from.");
    tt->help = tdrpStrDup("The form the first half of the output page.\nThe second half is formed by the forecasts.");
    tt->val_offset = (char *) &MetarUrl - &_start_;
    tt->single_val.s = tdrpStrDup("spdbp:://localhost::spdb/ExtractedFromModel");
    tt++;
    
    // Parameter 'TableLookBack'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("TableLookBack");
    tt->descr = tdrpStrDup("Time to look back from trigger time for METAR data, seconds.");
    tt->help = tdrpStrDup("Default is four hours.");
    tt->val_offset = (char *) &TableLookBack - &_start_;
    tt->single_val.i = 14400;
    tt++;
    
    // Parameter 'TableLookAhead'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("TableLookAhead");
    tt->descr = tdrpStrDup("Time to look ahead from trigger time for forecast data, seconds.");
    tt->help = tdrpStrDup("Default is twelve hours.");
    tt->val_offset = (char *) &TableLookAhead - &_start_;
    tt->single_val.i = 43200;
    tt++;
    
    // Parameter 'TableMaxLeadTime'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("TableMaxLeadTime");
    tt->descr = tdrpStrDup("Maximum lead time, in seconds, for a forecast to be considered\nvalid for the table. Only has effect if MinimumLeadTimeOnly is false.");
    tt->help = tdrpStrDup("Default is twenty four hours.");
    tt->val_offset = (char *) &TableMaxLeadTime - &_start_;
    tt->single_val.i = 86400;
    tt++;
    
    // Parameter 'MinimumLeadTimeOnly'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("MinimumLeadTimeOnly");
    tt->descr = tdrpStrDup("If set, only the most recent lead time is\ndisplayed for each model run.");
    tt->help = tdrpStrDup("Typically set to TRUE except for debugging.");
    tt->val_offset = (char *) &MinimumLeadTimeOnly - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'Overlap'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("Overlap");
    tt->descr = tdrpStrDup("If set, the actual and METAR times will attempt\nto cover the same period in time in the table.");
    tt->help = tdrpStrDup("Typically set to FALSE except for debugging.");
    tt->val_offset = (char *) &Overlap - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'TableOutDir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("TableOutDir");
    tt->descr = tdrpStrDup("Output directory where Total Tables are written.");
    tt->help = tdrpStrDup("Data are written under a YYYYMMDD directory structure.");
    tt->val_offset = (char *) &TableOutDir - &_start_;
    tt->single_val.s = tdrpStrDup("$(RAP_DATA_DIR)/www_content/MosTrendTable");
    tt++;
    
    // Parameter 'CopyToArchiveDir'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("CopyToArchiveDir");
    tt->descr = tdrpStrDup("Option to copy files to archive dir.");
    tt->help = tdrpStrDup("Archive files are writtent to subdirectories which preserve the generate time. Normal output uses valid time, so later forecasts will overwrite earlier forecasts.");
    tt->val_offset = (char *) &CopyToArchiveDir - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'TableArchiveDir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("TableArchiveDir");
    tt->descr = tdrpStrDup("Output directory where Total Tables are written for archival.");
    tt->help = tdrpStrDup("Data are written under a YYYYMMDD directory structure.");
    tt->val_offset = (char *) &TableArchiveDir - &_start_;
    tt->single_val.s = tdrpStrDup("$(RAP_DATA_DIR)/www_content/archive/MosTrendTable");
    tt++;
    
    // trailing entry has param_name set to NULL
    
    tt->param_name = NULL;
    
    return;
  
  }
