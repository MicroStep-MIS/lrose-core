/*******************************************
 * Dsr2Mdv_tdrp.c
 *
 * TDRP C code file 'Dsr2Mdv' module.
 *
 * Code for program Dsr2Mdv
 *
 * This file has been automatically
 * generated by TDRP, do not modify.
 *
 *******************************************/

#include "Dsr2Mdv_tdrp.h"
#include <string.h>

/*
 * file scope variables
 */

static TDRPtable Table[34];
static Dsr2Mdv_tdrp_struct *Params;
static char *Module = "Dsr2Mdv";

/*************************************************************
 * Dsr2Mdv_tdrp_load_from_args()
 *
 * Loads up TDRP using the command line args.
 *
 * Check TDRP_usage() for command line actions associated with
 * this function.
 *
 *   argc, argv: command line args
 *
 *   Dsr2Mdv_tdrp_struct *params: loads up this struct
 * 
 *   char **override_list: A null-terminated list of overrides
 *     to the parameter file.
 *     An override string has exactly the format of an entry
 *     in the parameter file itself.
 *
 *   char **params_path_p: if non-NULL, this is set to point to
 *                         the path of the params file used.
 *
 *  Returns 0 on success, -1 on failure.
 */

int Dsr2Mdv_tdrp_load_from_args(int argc, char **argv,
                         Dsr2Mdv_tdrp_struct *params,
                         char **override_list,
                         char **params_path_p)
{
  Params = params;
  Dsr2Mdv_tdrp_init(Params);
  if (tdrpLoadFromArgs(argc, argv,
                       Table, Params,
                       override_list, params_path_p)) {
    return (-1);
  } else {
    return (0);
  }
}

/*************************************************************
 * Dsr2Mdv_tdrp_load()
 *
 * Loads up TDRP for a given module.
 *
 * This version of load gives the programmer the option to load
 * up more than one module for a single application. It is a
 * lower-level routine than Dsr2Mdv_tdrp_load_from_args,
 * and hence more flexible, but the programmer must do more work.
 *
 *   char *param_file_path: the parameter file to be read in.
 *
 *   Dsr2Mdv_tdrp_struct *params: loads up this struct
 *
 *   char **override_list: A null-terminated list of overrides
 *     to the parameter file.
 *     An override string has exactly the format of an entry
 *     in the parameter file itself.
 *
 *  expand_env: flag to control environment variable
 *                expansion during tokenization.
 *              If TRUE, environment expansion is set on.
 *              If FALSE, environment expansion is set off.
 *
 *  Returns 0 on success, -1 on failure.
 */

int Dsr2Mdv_tdrp_load(char *param_file_path,
               Dsr2Mdv_tdrp_struct *params,
               char **override_list,
               int expand_env, int debug)
{
  Params = params;
  Dsr2Mdv_tdrp_init(Params);
  if (tdrpLoad(param_file_path, Table,
               params, override_list,
               expand_env, debug)) {
    return (-1);
  } else {
    return (0);
  }
}

/*************************************************************
 * Dsr2Mdv_tdrp_load_defaults()
 *
 * Loads up defaults for a given module.
 *
 * See Dsr2Mdv_tdrp_load() for more details.
 *
 *  Returns 0 on success, -1 on failure.
 */

int Dsr2Mdv_tdrp_load_defaults(Dsr2Mdv_tdrp_struct *params,
                        int expand_env)
{
  Params = params;
  Dsr2Mdv_tdrp_init(Params);
  if (tdrpLoad(NULL, Table,
               params, NULL,
               expand_env, FALSE)) {
    return (-1);
  } else {
    return (0);
  }
}

/*************************************************************
 * Dsr2Mdv_tdrp_sync()
 *
 * Syncs the user struct data back into the parameter table,
 * in preparation for printing.
 */

void Dsr2Mdv_tdrp_sync(void)
{
  tdrpUser2Table(Table, Params);
}

/*************************************************************
 * Dsr2Mdv_tdrp_print()
 * 
 * Print params file
 *
 * The modes supported are:
 *
 *   PRINT_SHORT:   main comments only, no help or descriptions
 *                  structs and arrays on a single line
 *   PRINT_NORM:    short + descriptions and help
 *   PRINT_LONG:    norm  + arrays and structs expanded
 *   PRINT_VERBOSE: long  + private params included
 */

void Dsr2Mdv_tdrp_print(FILE *out, tdrp_print_mode_t mode)
{
  tdrpPrint(out, Table, Module, mode);
}

/*************************************************************
 * Dsr2Mdv_tdrp_check_all_set()
 *
 * Return TRUE if all set, FALSE if not.
 *
 * If out is non-NULL, prints out warning messages for those
 * parameters which are not set.
 */

int Dsr2Mdv_tdrp_check_all_set(FILE *out)
{
  return (tdrpCheckAllSet(out, Table, Params));
}

/*************************************************************
 * Dsr2Mdv_tdrp_check_is_set()
 *
 * Return TRUE if parameter is set, FALSE if not.
 *
 */

int Dsr2Mdv_tdrp_check_is_set(char *param_name)
{
  return (tdrpCheckIsSet(param_name, Table, Params));
}

/*************************************************************
 * Dsr2Mdv_tdrp_free_all()
 *
 * Frees up all TDRP dynamic memory.
 */

void Dsr2Mdv_tdrp_free_all(void)
{
  tdrpFreeAll(Table, Params);
}

/*************************************************************
 * Dsr2Mdv_tdrp_array_realloc()
 *
 * Realloc 1D array.
 *
 * If size is increased, the values from the last array entry is
 * copied into the new space.
 *
 * Returns 0 on success, -1 on error.
 */

int Dsr2Mdv_tdrp_array_realloc(char *param_name, int new_array_n)
{
  if (tdrpArrayRealloc(Table, Params, param_name, new_array_n)) {
    return (-1);
  } else {
    return (0);
  }
}

/*************************************************************
 * Dsr2Mdv_tdrp_array2D_realloc()
 *
 * Realloc 2D array.
 *
 * If size is increased, the values from the last array entry is
 * copied into the new space.
 *
 * Returns 0 on success, -1 on error.
 */

int Dsr2Mdv_tdrp_array2D_realloc(char *param_name,
                          int new_array_n1,
                          int new_array_n2)
{
  if (tdrpArray2DRealloc(Table, Params, param_name,
			 new_array_n1, new_array_n2)) {
    return (-1);
  } else {
    return (0);
  }
}

/*************************************************************
 * Dsr2Mdv_tdrp_table()
 *
 * Returns pointer to static Table for this module.
 */

TDRPtable *Dsr2Mdv_tdrp_table(void)
{
  return (Table);
}

/*************************************************************
 * Dsr2Mdv_tdrp_init()
 *
 * Module table initialization function.
 *
 *
 * Returns pointer to static Table for this module.
 */

TDRPtable *Dsr2Mdv_tdrp_init(Dsr2Mdv_tdrp_struct *params)

{

  TDRPtable *tt = Table;

  Dsr2Mdv_tdrp_struct pp; /* for computing byte_offsets */

  /* zero out struct, and store size */

  memset(params, 0, sizeof(Dsr2Mdv_tdrp_struct));
  params->struct_size = sizeof(Dsr2Mdv_tdrp_struct);

  /* Parameter 'debug' */
  /* ctype is 'Dsr2Mdv_debug_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = ENUM_TYPE;
  tt->param_name = tdrpStrDup("debug");
  tt->descr = tdrpStrDup("Debug option");
  tt->help = tdrpStrDup("If set, debug messages will be printed with the appropriate level of detail.");
  tt->val_offset = (char *) &(pp.debug) - (char *) &pp;
  tt->enum_def.name = tdrpStrDup("debug_t");
  tt->enum_def.nfields = 4;
  tt->enum_def.fields = (enum_field_t *)
      tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
    tt->enum_def.fields[0].name = tdrpStrDup("DEBUG_OFF");
    tt->enum_def.fields[0].val = DEBUG_OFF;
    tt->enum_def.fields[1].name = tdrpStrDup("DEBUG_WARNINGS");
    tt->enum_def.fields[1].val = DEBUG_WARNINGS;
    tt->enum_def.fields[2].name = tdrpStrDup("DEBUG_NORM");
    tt->enum_def.fields[2].val = DEBUG_NORM;
    tt->enum_def.fields[3].name = tdrpStrDup("DEBUG_VERBOSE");
    tt->enum_def.fields[3].val = DEBUG_VERBOSE;
  tt->single_val.e = DEBUG_OFF;
  tt++;
  
  /* Parameter 'malloc_debug_level' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("malloc_debug_level");
  tt->descr = tdrpStrDup("Malloc debug level");
  tt->help = tdrpStrDup("0 - none, 1 - corruption checking, 2 - records all malloc blocks and checks, 3 - printout of all mallocs etc.");
  tt->val_offset = (char *) &(pp.malloc_debug_level) - (char *) &pp;
  tt->has_min = TRUE;
  tt->has_max = TRUE;
  tt->min_val.l = 0;
  tt->max_val.l = 3;
  tt->single_val.l = 0;
  tt++;
  
  /* Parameter 'instance' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("instance");
  tt->descr = tdrpStrDup("Process instance");
  tt->help = tdrpStrDup("Used for registration with procmap.");
  tt->val_offset = (char *) &(pp.instance) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("Test");
  tt++;
  
  /* Parameter 'input_fmq_url' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("input_fmq_url");
  tt->descr = tdrpStrDup("Input URL for DsRadar data via FMQ");
  tt->help = tdrpStrDup("");
  tt->val_offset = (char *) &(pp.input_fmq_url) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("fmqp:://localhost::./fmq.dsRadar");
  tt++;
  
  /* Parameter 'seek_to_end_of_input' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("seek_to_end_of_input");
  tt->descr = tdrpStrDup("Option to seek to the end of the input FMQ.");
  tt->help = tdrpStrDup("If TRUE, the program will seek to the end of the fmq and only read in new data. If FALSE, it will start reading from the beginning of the FMQ.");
  tt->val_offset = (char *) &(pp.seek_to_end_of_input) - (char *) &pp;
  tt->single_val.b = pTRUE;
  tt++;
  
  /* Parameter 'output_mdv_dir' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("output_mdv_dir");
  tt->descr = tdrpStrDup("Dir of output MDV files.");
  tt->help = tdrpStrDup("This directory must exist.");
  tt->val_offset = (char *) &(pp.output_mdv_dir) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("none");
  tt++;
  
  /* Parameter 'radar_info' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("radar_info");
  tt->descr = tdrpStrDup("General info on radar.");
  tt->help = tdrpStrDup("Used for data_set_info in MDV file.");
  tt->val_offset = (char *) &(pp.radar_info) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("not-set");
  tt++;
  
  /* Parameter 'override_radar_location' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("override_radar_location");
  tt->descr = tdrpStrDup("Option to override Dsr radar location.");
  tt->help = tdrpStrDup("If TRUE, the Mdv output will use location information specified in 'radar_location'.");
  tt->val_offset = (char *) &(pp.override_radar_location) - (char *) &pp;
  tt->single_val.b = pFALSE;
  tt++;
  
  /* Parameter 'radar_location' */
  /* ctype is 'Dsr2Mdv_radar_location_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRUCT_TYPE;
  tt->param_name = tdrpStrDup("radar_location");
  tt->descr = tdrpStrDup(".");
  tt->help = tdrpStrDup("The radar_location need only be set if 'override_radar_location' is TRUE.");
  tt->val_offset = (char *) &(pp.radar_location) - (char *) &pp;
  tt->struct_def.name = tdrpStrDup("radar_location_t");
  tt->struct_def.nfields = 3;
  tt->struct_def.fields = (struct_field_t *)
      tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
    tt->struct_def.fields[0].ftype = tdrpStrDup("double");
    tt->struct_def.fields[0].fname = tdrpStrDup("latitude");
    tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
    tt->struct_def.fields[0].rel_offset = 
      (char *) &(pp.radar_location.latitude) - (char *) &(pp.radar_location);
    tt->struct_def.fields[1].ftype = tdrpStrDup("double");
    tt->struct_def.fields[1].fname = tdrpStrDup("longitude");
    tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
    tt->struct_def.fields[1].rel_offset = 
      (char *) &(pp.radar_location.longitude) - (char *) &(pp.radar_location);
    tt->struct_def.fields[2].ftype = tdrpStrDup("double");
    tt->struct_def.fields[2].fname = tdrpStrDup("altitude");
    tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
    tt->struct_def.fields[2].rel_offset = 
      (char *) &(pp.radar_location.altitude) - (char *) &(pp.radar_location);
  tt->n_struct_vals = 3;
  tt->struct_vals = (tdrpVal_t *)
      tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt->struct_vals[0].d = 0;
    tt->struct_vals[1].d = 0;
    tt->struct_vals[2].d = 0;
  tt++;
  
  /* Parameter 'remove_clutter' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("remove_clutter");
  tt->descr = tdrpStrDup("Option to remove clutter.");
  tt->help = tdrpStrDup("If TRUE, clutter will be removed using the clutter table specified in 'clutter_table_path'.");
  tt->val_offset = (char *) &(pp.remove_clutter) - (char *) &pp;
  tt->single_val.b = pFALSE;
  tt++;
  
  /* Parameter 'lookups' */
  /* ctype is 'Dsr2Mdv_lookups_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRUCT_TYPE;
  tt->param_name = tdrpStrDup("lookups");
  tt->descr = tdrpStrDup("Array of lookup table paths for given scan types.");
  tt->help = tdrpStrDup("This array specifies the lookup tables to be used for each scan type. If the first scan_type is set to -1 the first lookup table will be used with all scan types. The clutter_table_path need only be set if 'remove_clutter' is TRUE. If the chosen scan type is not available, the first lookup in the list is used.");
  tt->val_offset = (char *) &(pp.lookups.val) - (char *) &pp;
  tt->len_offset = (char *) &(pp.lookups.len) - (char *) &pp;
  tt->array_offset = (char *) &(pp._lookups) - (char *) &pp;
  tt->array_n_offset = (char *) &(pp.lookups_n) - (char *) &pp;
  tt->is_array = TRUE;
  tt->array_len_fixed = FALSE;
  tt->array_elem_size = sizeof(Dsr2Mdv_lookups_t);
  tt->array_n = 1;
  tt->struct_def.name = tdrpStrDup("lookups_t");
  tt->struct_def.nfields = 3;
  tt->struct_def.fields = (struct_field_t *)
      tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
    tt->struct_def.fields[0].ftype = tdrpStrDup("int");
    tt->struct_def.fields[0].fname = tdrpStrDup("scan_type");
    tt->struct_def.fields[0].ptype = INT_TYPE;
    tt->struct_def.fields[0].rel_offset = 
      (char *) &(pp.lookups.val->scan_type) - (char *) pp.lookups.val;
    tt->struct_def.fields[1].ftype = tdrpStrDup("char*");
    tt->struct_def.fields[1].fname = tdrpStrDup("lookup_table_path");
    tt->struct_def.fields[1].ptype = STRING_TYPE;
    tt->struct_def.fields[1].rel_offset = 
      (char *) &(pp.lookups.val->lookup_table_path) - (char *) pp.lookups.val;
    tt->struct_def.fields[2].ftype = tdrpStrDup("char*");
    tt->struct_def.fields[2].fname = tdrpStrDup("clutter_table_path");
    tt->struct_def.fields[2].ptype = STRING_TYPE;
    tt->struct_def.fields[2].rel_offset = 
      (char *) &(pp.lookups.val->clutter_table_path) - (char *) pp.lookups.val;
  tt->n_struct_vals = 3;
  tt->struct_vals = (tdrpVal_t *)
      tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt->struct_vals[0].i = 0;
    tt->struct_vals[1].s = tdrpStrDup("not_set");
    tt->struct_vals[2].s = tdrpStrDup("not_set");
  tt++;
  
  /* Parameter 'specify_output_fields' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("specify_output_fields");
  tt->descr = tdrpStrDup("Option to specify output fields.");
  tt->help = tdrpStrDup("If TRUE, only the fields specified in the output_field_names array will be stored in the output file. If FALSE, all fields in the data will be stored.");
  tt->val_offset = (char *) &(pp.specify_output_fields) - (char *) &pp;
  tt->single_val.b = pFALSE;
  tt++;
  
  /* Parameter 'output_field_names' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("output_field_names");
  tt->descr = tdrpStrDup("Array of output field names.");
  tt->help = tdrpStrDup("See 'specify_output_fields'.");
  tt->val_offset = (char *) &(pp.output_field_names.val) - (char *) &pp;
  tt->len_offset = (char *) &(pp.output_field_names.len) - (char *) &pp;
  tt->array_offset = (char *) &(pp._output_field_names) - (char *) &pp;
  tt->array_n_offset = (char *) &(pp.output_field_names_n) - (char *) &pp;
  tt->is_array = TRUE;
  tt->array_len_fixed = FALSE;
  tt->array_elem_size = sizeof(char*);
  tt->array_n = 1;
  tt->array_vals = (tdrpVal_t *)
      tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
    tt->array_vals[0].s = tdrpStrDup("DBZ");
  tt++;
  
  /* Parameter 'check_sn' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("check_sn");
  tt->descr = tdrpStrDup("Option to check the signal/noise values.");
  tt->help = tdrpStrDup("If TRUE, the signal/noise value will be computed from the dBZ value at the gate. If this exceeds the parameter 'sn_threshold', it will be conditionally accepted. A second check is made to remove noise spikes. Looking along the radial the number of gates in a row (a 'run') with sn values above the threshold is computed. For the gates in this run to be accepted the length of the run must exceed 'sn_min_valid_run'.");
  tt->val_offset = (char *) &(pp.check_sn) - (char *) &pp;
  tt->single_val.b = pFALSE;
  tt++;
  
  /* Parameter 'sn_threshold' */
  /* ctype is 'double' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = DOUBLE_TYPE;
  tt->param_name = tdrpStrDup("sn_threshold");
  tt->descr = tdrpStrDup("Signal/noise threshold - for noise_removal.");
  tt->help = tdrpStrDup("See 'check_sn'.");
  tt->val_offset = (char *) &(pp.sn_threshold) - (char *) &pp;
  tt->single_val.d = 0;
  tt++;
  
  /* Parameter 'sn_min_valid_run' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("sn_min_valid_run");
  tt->descr = tdrpStrDup("Signal/noise min valid run - for noise_removal.");
  tt->help = tdrpStrDup("This is the minimum valid run length along a radial - see 'check_sn'.");
  tt->val_offset = (char *) &(pp.sn_min_valid_run) - (char *) &pp;
  tt->single_val.l = 5;
  tt++;
  
  /* Parameter 'noise_dbz_at_100km' */
  /* ctype is 'double' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = DOUBLE_TYPE;
  tt->param_name = tdrpStrDup("noise_dbz_at_100km");
  tt->descr = tdrpStrDup("The noise represented as dBZ at 100km range.");
  tt->help = tdrpStrDup("This is used for computing the signal/noise value from the Reflectivity.");
  tt->val_offset = (char *) &(pp.noise_dbz_at_100km) - (char *) &pp;
  tt->single_val.d = 0;
  tt++;
  
  /* Parameter 'create_time_field' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("create_time_field");
  tt->descr = tdrpStrDup("Option to create a field made up of time data.");
  tt->help = tdrpStrDup("If TRUE, a data field will be created which contains the time to the nearest 10 seconds from the reference time for each beam.");
  tt->val_offset = (char *) &(pp.create_time_field) - (char *) &pp;
  tt->single_val.b = pFALSE;
  tt++;
  
  /* Parameter 'input_time_field_name' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("input_time_field_name");
  tt->descr = tdrpStrDup("Input time field name.");
  tt->help = tdrpStrDup("Name of time field as it appears in the dsr stream.  See DsrAddTime parameter file for field name.");
  tt->val_offset = (char *) &(pp.input_time_field_name) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("DATA_TIME");
  tt++;
  
  /* Parameter 'auto_mid_time' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("auto_mid_time");
  tt->descr = tdrpStrDup("Option to automatically compute the volume mid time.");
  tt->help = tdrpStrDup("If TRUE, the mid_time is the mean of the start and end times of the data in the volume. If FALSE, the mid time is computed as the end time minus 'age_at_end_of_volume'.");
  tt->val_offset = (char *) &(pp.auto_mid_time) - (char *) &pp;
  tt->single_val.b = pFALSE;
  tt++;
  
  /* Parameter 'age_at_end_of_volume' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("age_at_end_of_volume");
  tt->descr = tdrpStrDup("Specified age (secs) of the data relative to the data time at the end of the volume.");
  tt->help = tdrpStrDup("Used if 'auto_mid_time' is FALSE.");
  tt->val_offset = (char *) &(pp.age_at_end_of_volume) - (char *) &pp;
  tt->single_val.l = 0;
  tt++;
  
  /* Parameter 'max_vol_duration' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("max_vol_duration");
  tt->descr = tdrpStrDup("Maximum volume duration (secs).");
  tt->help = tdrpStrDup("If a volume exceeds this duration it is not saved. This takes care of cases in which the radar data stops in the middle of a voluem for some reason. Then the early data in the volume will not match the late data.");
  tt->val_offset = (char *) &(pp.max_vol_duration) - (char *) &pp;
  tt->single_val.l = 900;
  tt++;
  
  /* Parameter 'azimuth_offset' */
  /* ctype is 'double' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = DOUBLE_TYPE;
  tt->param_name = tdrpStrDup("azimuth_offset");
  tt->descr = tdrpStrDup("Angular azimuth offset to be used when computing the azimuth beam position.");
  tt->help = tdrpStrDup("The lookup tables are computed making the assumption that the beams occur at regular intervals and that a beam index may be assigned to each beam. When computing the index the beam azimuth must be rounded to a theoretical index. This offset is added to the actual azimuth before truncation to the index value.");
  tt->val_offset = (char *) &(pp.azimuth_offset) - (char *) &pp;
  tt->single_val.d = 0.5;
  tt++;
  
  /* Parameter 'check_missing_beams' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("check_missing_beams");
  tt->descr = tdrpStrDup("Option to check the number of beams missing from the volume.");
  tt->help = tdrpStrDup("If TRUE the number of missing beams will be computed. If this number exceeds max_missing_beams the volume will not be written.");
  tt->val_offset = (char *) &(pp.check_missing_beams) - (char *) &pp;
  tt->single_val.b = pFALSE;
  tt++;
  
  /* Parameter 'max_missing_beams' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("max_missing_beams");
  tt->descr = tdrpStrDup("The maximum number of missing beams for a valid volume.");
  tt->help = tdrpStrDup("The is used if 'check_missing_beams' is TRUE.");
  tt->val_offset = (char *) &(pp.max_missing_beams) - (char *) &pp;
  tt->single_val.l = 200;
  tt++;
  
  /* Parameter 'use_repeated_elevations' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("use_repeated_elevations");
  tt->descr = tdrpStrDup("Option to use data from elevation angles which are repeated in the volume.");
  tt->help = tdrpStrDup("Some radar scan types repeat tilts at certain angles. If TRUE the latest data will be used for each tilt. If FALSE the earliest data will be used.");
  tt->val_offset = (char *) &(pp.use_repeated_elevations) - (char *) &pp;
  tt->single_val.b = pTRUE;
  tt++;
  
  /* Parameter 'min_elevation' */
  /* ctype is 'double' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = DOUBLE_TYPE;
  tt->param_name = tdrpStrDup("min_elevation");
  tt->descr = tdrpStrDup("Minimum elevation to process, in degrees.");
  tt->help = tdrpStrDup("");
  tt->val_offset = (char *) &(pp.min_elevation) - (char *) &pp;
  tt->single_val.d = 0;
  tt++;
  
  /* Parameter 'max_elevation' */
  /* ctype is 'double' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = DOUBLE_TYPE;
  tt->param_name = tdrpStrDup("max_elevation");
  tt->descr = tdrpStrDup("Maximum elevation to process, in degrees.");
  tt->help = tdrpStrDup("");
  tt->val_offset = (char *) &(pp.max_elevation) - (char *) &pp;
  tt->single_val.d = 90;
  tt++;
  
  /* Parameter 'end_of_vol_decision' */
  /* ctype is 'Dsr2Mdv_end_of_vol_decision_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = ENUM_TYPE;
  tt->param_name = tdrpStrDup("end_of_vol_decision");
  tt->descr = tdrpStrDup("Decision type for end-of-volume.");
  tt->help = tdrpStrDup("If END_OF_VOL_FLAG, the end-of-volume flag in the data will be used to trigger the end of volume. If LAST_TILT_IN_VOL, the end of the tilt number given by 'last_tilt_in_vol' will be used  to trigger the end-of-volume.");
  tt->val_offset = (char *) &(pp.end_of_vol_decision) - (char *) &pp;
  tt->enum_def.name = tdrpStrDup("end_of_vol_decision_t");
  tt->enum_def.nfields = 2;
  tt->enum_def.fields = (enum_field_t *)
      tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
    tt->enum_def.fields[0].name = tdrpStrDup("END_OF_VOL_FLAG");
    tt->enum_def.fields[0].val = END_OF_VOL_FLAG;
    tt->enum_def.fields[1].name = tdrpStrDup("LAST_TILT_IN_VOL");
    tt->enum_def.fields[1].val = LAST_TILT_IN_VOL;
  tt->single_val.e = END_OF_VOL_FLAG;
  tt++;
  
  /* Parameter 'last_tilt_in_vol' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("last_tilt_in_vol");
  tt->descr = tdrpStrDup("The tilt number used to end the volume.");
  tt->help = tdrpStrDup("Only applies if 'end_of_vol_decision' is set to LAST_TILT_IN_VOL.");
  tt->val_offset = (char *) &(pp.last_tilt_in_vol) - (char *) &pp;
  tt->single_val.l = 0;
  tt++;
  
  /* Parameter 'write_intermediate_files' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("write_intermediate_files");
  tt->descr = tdrpStrDup("Option to write intermediate files during the volume.");
  tt->help = tdrpStrDup("Some people like the display to update at intervals during the volume rather than waiting for the end of the volume to see the latest data. If TRUE an intermediate file of the specified name will be written to the output directory at the specified interval. See 'intermediate_file_name' and 'intermediate_file_frequency'.");
  tt->val_offset = (char *) &(pp.write_intermediate_files) - (char *) &pp;
  tt->single_val.b = pFALSE;
  tt++;
  
  /* Parameter 'intermediate_file_name' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("intermediate_file_name");
  tt->descr = tdrpStrDup("Name of intermediate file.");
  tt->help = tdrpStrDup("See 'write_intermediate_files'.");
  tt->val_offset = (char *) &(pp.intermediate_file_name) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("latest.mdv");
  tt++;
  
  /* Parameter 'intermediate_file_frequency' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("intermediate_file_frequency");
  tt->descr = tdrpStrDup("The frequency (secs) at which the intermediate files are written.");
  tt->help = tdrpStrDup("See 'write_intermediate_files'.");
  tt->val_offset = (char *) &(pp.intermediate_file_frequency) - (char *) &pp;
  tt->single_val.l = 30;
  tt++;
  
  /* trailing entry has param_name set to NULL */
  
  tt->param_name = NULL;
  
  return (Table);

}
