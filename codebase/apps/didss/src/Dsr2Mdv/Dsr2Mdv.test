/**********************************************************************
 * TDRP params for Dsr2Mdv
 **********************************************************************/

///////////// debug ///////////////////////////////////
//
// Debug option.
// If set, debug messages will be printed with the appropriate level of 
//   detail.
//
// Type: enum
// Options:
//     DEBUG_OFF
//     DEBUG_WARNINGS
//     DEBUG_NORM
//     DEBUG_VERBOSE
//

debug = DEBUG_VERBOSE;

///////////// malloc_debug_level //////////////////////
//
// Malloc debug level.
// 0 - none, 1 - corruption checking, 2 - records all malloc blocks and 
//   checks, 3 - printout of all mallocs etc.
// Minimum val: 0
// Maximum val: 3
// Type: long
//

malloc_debug_level = 0;

///////////// instance ////////////////////////////////
//
// Process instance.
// Used for registration with procmap.
// Type: string
//

instance = "Test";

///////////// input_fmq_url ///////////////////////////
//
// Input URL for DsRadar data via FMQ.
// Type: string
//

input_fmq_url = "fmqp:://localhost::./fmq.dsRadar";

///////////// seek_to_end_of_input ////////////////////
//
// Option to seek to the end of the input FMQ.
// If TRUE, the program will seek to the end of the fmq and only read in 
//   new data. If FALSE, it will start reading from the beginning of the 
//   FMQ.
// Type: boolean
//

seek_to_end_of_input = TRUE;

///////////// output_mdv_dir //////////////////////////
//
// Dir of output MDV files.
// This directory must exist.
// Type: string
//

output_mdv_dir = "output";

///////////// radar_info //////////////////////////////
//
// General info on radar.
// Used for data_set_info in MDV file.
// Type: string
//

radar_info = "Test radar, data generated by Test2Dsr to simulate NEXRAD.";

///////////// override_radar_location /////////////////
//
// Option to override Dsr radar location.
// If TRUE, the Mdv output will use location information specified in 
//   'radar_location'.
// Type: boolean
//

override_radar_location = FALSE;

///////////// radar_location //////////////////////////
//
// .
// The radar_location need only be set if 'override_radar_location' is 
//   TRUE.
//
// Type: struct
//   typedef struct {
//      double latitude;
//      double longitude;
//      double altitude;
//   }
//
//

radar_location = { 0, 0, 0 };

///////////// remove_clutter //////////////////////////
//
// Option to remove clutter.
// If TRUE, clutter will be removed using the clutter table specified in 
//   'clutter_table_path'.
// Type: boolean
//

remove_clutter = FALSE;

///////////// lookups /////////////////////////////////
//
// Array of lookup table paths for given scan types.
// This array specifies the lookup tables to be used for each scan type. 
//   If the first scan_type is set to -1 the first lookup table will be 
//   used with all scan types. The clutter_table_path need only be set if 
//   'remove_clutter' is TRUE. If the chosen scan type is not available, 
//   the first lookup in the list is used.
//
// Type: struct
//   typedef struct {
//      int scan_type;
//      char* lookup_table_path;
//      char* clutter_table_path;
//   }
//
// 1D array - variable length.
//

lookups = {
  { -1, "tables/polar2mdv_lookup", "none"}
};

///////////// specify_output_fields ///////////////////
//
// Option to specify output fields.
// If TRUE, only the fields specified in the output_field_names array 
//   will be stored in the output file. If FALSE, all fields in the data 
//   will be stored.
// Type: boolean
//

specify_output_fields = FALSE;

///////////// output_field_names //////////////////////
//
// Array of output field names.
// See 'specify_output_fields'.
// Type: string
// 1D array - variable length.
//

output_field_names = { "DBZ", "VEL" };

///////////// check_sn ////////////////////////////////
//
// Option to check the signal/noise values.
// If TRUE, the signal/noise value will be computed from the dBZ value 
//   at the gate. If this exceeds the parameter 'sn_threshold', it will be 
//   conditionally accepted. A second check is made to remove noise 
//   spikes. Looking along the radial the number of gates in a row (a 
//   'run') with sn values above the threshold is computed. For the gates 
//   in this run to be accepted the length of the run must exceed 
//   'sn_min_valid_run'.
// Type: boolean
//

check_sn = TRUE;

///////////// sn_threshold ////////////////////////////
//
// Signal/noise threshold - for noise_removal.
// See 'check_sn'.
// Type: double
//

sn_threshold = 5;

///////////// sn_min_valid_run ////////////////////////
//
// Signal/noise min valid run - for noise_removal.
// This is the minimum valid run length along a radial - see 'check_sn'.
// Type: long
//

sn_min_valid_run = 5;

///////////// noise_dbz_at_100km //////////////////////
//
// The noise represented as dBZ at 100km range.
// This is used for computing the signal/noise value from the 
//   Reflectivity.
// Type: double
//

noise_dbz_at_100km = 0;

///////////// auto_mid_time ///////////////////////////
//
// Option to automatically compute the volume mid time.
// If TRUE, the mid_time is the mean of the start and end times of the 
//   data in the volume. If FALSE, the mid time is computed as the end 
//   time minus 'age_at_end_of_volume'.
// Type: boolean
//

auto_mid_time = TRUE;

///////////// age_at_end_of_volume ////////////////////
//
// Specified age (secs) of the data relative to the data time at the end 
//   of the volume.
// Used if 'auto_mid_time' is FALSE.
// Type: long
//

age_at_end_of_volume = 120;

///////////// max_vol_duration ////////////////////////
//
// Maximum volume duration (secs).
// If a volume exceeds this duration it is not saved. This takes care of 
//   cases in which the radar data stops in the middle of a voluem for 
//   some reason. Then the early data in the volume will not match the 
//   late data.
// Type: long
//

max_vol_duration = 900;

///////////// azimuth_offset //////////////////////////
//
// Angular azimuth offset to be used when computing the azimuth beam 
//   position.
// The lookup tables are computed making the assumption that the beams 
//   occur at regular intervals and that a beam index may be assigned to 
//   each beam. When computing the index the beam azimuth must be rounded 
//   to a theoretical index. This offset is added to the actual azimuth 
//   before truncation to the index value.
// Type: double
//

azimuth_offset = 0.5;

///////////// check_missing_beams /////////////////////
//
// Option to check the number of beams missing from the volume.
// If TRUE the number of missing beams will be computed. If this number 
//   exceeds max_missing_beams the volume will not be written.
// Type: boolean
//

check_missing_beams = TRUE;

///////////// max_missing_beams ///////////////////////
//
// The maximum number of missing beams for a valid volume.
// The is used if 'check_missing_beams' is TRUE.
// Type: long
//

max_missing_beams = 2000;

///////////// use_repeated_elevations /////////////////
//
// Option to use data from elevation angles which are repeated in the 
//   volume.
// Some radar scan types repeat tilts at certain angles. If TRUE the 
//   latest data will be used for each tilt. If FALSE the earliest data 
//   will be used.
// Type: boolean
//

use_repeated_elevations = TRUE;

///////////// end_of_vol_decision /////////////////////
//
// Decision type for end-of-volume.
// If END_OF_VOL_FLAG, the end-of-volume flag in the data will be used 
//   to trigger the end of volume. If LAST_TILT_IN_VOL, the end of the 
//   tilt number given by 'last_tilt_in_vol' will be used  to trigger the 
//   end-of-volume.
//
// Type: enum
// Options:
//     END_OF_VOL_FLAG
//     LAST_TILT_IN_VOL
//

end_of_vol_decision = END_OF_VOL_FLAG;

///////////// last_tilt_in_vol ////////////////////////
//
// The tilt number used to end the volume.
// Only applies if 'end_of_vol_decision' is set to LAST_TILT_IN_VOL.
// Type: long
//

last_tilt_in_vol = 6;

///////////// write_intermediate_files ////////////////
//
// Option to write intermediate files during the volume.
// Some people like the display to update at intervals during the volume 
//   rather than waiting for the end of the volume to see the latest data. 
//   If TRUE an intermediate file of the specified name will be written to 
//   the output directory at the specified interval. See 
//   'intermediate_file_name' and 'intermediate_file_frequency'.
// Type: boolean
//

write_intermediate_files = TRUE;

///////////// intermediate_file_name //////////////////
//
// Name of intermediate file.
// See 'write_intermediate_files'.
// Type: string
//

intermediate_file_name = "latest.mdv";

///////////// intermediate_file_frequency /////////////
//
// The frequency (secs) at which the intermediate files are written.
// See 'write_intermediate_files'.
// Type: long
//

intermediate_file_frequency = 30;

