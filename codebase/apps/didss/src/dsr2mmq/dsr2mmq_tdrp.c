/*******************************************
 * dsr2mmq_tdrp.c
 *
 * TDRP C code file 'dsr2mmq' module.
 *
 * Code for program dsr2mmq
 *
 * This file has been automatically
 * generated by TDRP, do not modify.
 *
 *******************************************/

#include "dsr2mmq_tdrp.h"
#include <string.h>

/*
 * file scope variables
 */

static TDRPtable Table[18];
static dsr2mmq_tdrp_struct *Params;
static char *Module = "dsr2mmq";

/*************************************************************
 * dsr2mmq_tdrp_load_from_args()
 *
 * Loads up TDRP using the command line args.
 *
 * Check TDRP_usage() for command line actions associated with
 * this function.
 *
 *   argc, argv: command line args
 *
 *   dsr2mmq_tdrp_struct *params: loads up this struct
 * 
 *   char **override_list: A null-terminated list of overrides
 *     to the parameter file.
 *     An override string has exactly the format of an entry
 *     in the parameter file itself.
 *
 *   char **params_path_p: if non-NULL, this is set to point to
 *                         the path of the params file used.
 *
 *  Returns 0 on success, -1 on failure.
 */

int dsr2mmq_tdrp_load_from_args(int argc, char **argv,
                         dsr2mmq_tdrp_struct *params,
                         char **override_list,
                         char **params_path_p)
{
  Params = params;
  dsr2mmq_tdrp_init(Params);
  if (tdrpLoadFromArgs(argc, argv,
                       Table, Params,
                       override_list, params_path_p)) {
    return (-1);
  } else {
    return (0);
  }
}

/*************************************************************
 * dsr2mmq_tdrp_load()
 *
 * Loads up TDRP for a given module.
 *
 * This version of load gives the programmer the option to load
 * up more than one module for a single application. It is a
 * lower-level routine than dsr2mmq_tdrp_load_from_args,
 * and hence more flexible, but the programmer must do more work.
 *
 *   char *param_file_path: the parameter file to be read in.
 *
 *   dsr2mmq_tdrp_struct *params: loads up this struct
 *
 *   char **override_list: A null-terminated list of overrides
 *     to the parameter file.
 *     An override string has exactly the format of an entry
 *     in the parameter file itself.
 *
 *  expand_env: flag to control environment variable
 *                expansion during tokenization.
 *              If TRUE, environment expansion is set on.
 *              If FALSE, environment expansion is set off.
 *
 *  Returns 0 on success, -1 on failure.
 */

int dsr2mmq_tdrp_load(char *param_file_path,
               dsr2mmq_tdrp_struct *params,
               char **override_list,
               int expand_env, int debug)
{
  Params = params;
  dsr2mmq_tdrp_init(Params);
  if (tdrpLoad(param_file_path, Table,
               params, override_list,
               expand_env, debug)) {
    return (-1);
  } else {
    return (0);
  }
}

/*************************************************************
 * dsr2mmq_tdrp_load_defaults()
 *
 * Loads up defaults for a given module.
 *
 * See dsr2mmq_tdrp_load() for more details.
 *
 *  Returns 0 on success, -1 on failure.
 */

int dsr2mmq_tdrp_load_defaults(dsr2mmq_tdrp_struct *params,
                        int expand_env)
{
  Params = params;
  dsr2mmq_tdrp_init(Params);
  if (tdrpLoad(NULL, Table,
               params, NULL,
               expand_env, FALSE)) {
    return (-1);
  } else {
    return (0);
  }
}

/*************************************************************
 * dsr2mmq_tdrp_sync()
 *
 * Syncs the user struct data back into the parameter table,
 * in preparation for printing.
 */

void dsr2mmq_tdrp_sync(void)
{
  tdrpUser2Table(Table, Params);
}

/*************************************************************
 * dsr2mmq_tdrp_print()
 * 
 * Print params file
 *
 * The modes supported are:
 *
 *   PRINT_SHORT:   main comments only, no help or descriptions
 *                  structs and arrays on a single line
 *   PRINT_NORM:    short + descriptions and help
 *   PRINT_LONG:    norm  + arrays and structs expanded
 *   PRINT_VERBOSE: long  + private params included
 */

void dsr2mmq_tdrp_print(FILE *out, tdrp_print_mode_t mode)
{
  tdrpPrint(out, Table, Module, mode);
}

/*************************************************************
 * dsr2mmq_tdrp_check_all_set()
 *
 * Return TRUE if all set, FALSE if not.
 *
 * If out is non-NULL, prints out warning messages for those
 * parameters which are not set.
 */

int dsr2mmq_tdrp_check_all_set(FILE *out)
{
  return (tdrpCheckAllSet(out, Table, Params));
}

/*************************************************************
 * dsr2mmq_tdrp_check_is_set()
 *
 * Return TRUE if parameter is set, FALSE if not.
 *
 */

int dsr2mmq_tdrp_check_is_set(char *param_name)
{
  return (tdrpCheckIsSet(param_name, Table, Params));
}

/*************************************************************
 * dsr2mmq_tdrp_free_all()
 *
 * Frees up all TDRP dynamic memory.
 */

void dsr2mmq_tdrp_free_all(void)
{
  tdrpFreeAll(Table, Params);
}

/*************************************************************
 * dsr2mmq_tdrp_array_realloc()
 *
 * Realloc 1D array.
 *
 * If size is increased, the values from the last array entry is
 * copied into the new space.
 *
 * Returns 0 on success, -1 on error.
 */

int dsr2mmq_tdrp_array_realloc(char *param_name, int new_array_n)
{
  if (tdrpArrayRealloc(Table, Params, param_name, new_array_n)) {
    return (-1);
  } else {
    return (0);
  }
}

/*************************************************************
 * dsr2mmq_tdrp_array2D_realloc()
 *
 * Realloc 2D array.
 *
 * If size is increased, the values from the last array entry is
 * copied into the new space.
 *
 * Returns 0 on success, -1 on error.
 */

int dsr2mmq_tdrp_array2D_realloc(char *param_name,
                          int new_array_n1,
                          int new_array_n2)
{
  if (tdrpArray2DRealloc(Table, Params, param_name,
			 new_array_n1, new_array_n2)) {
    return (-1);
  } else {
    return (0);
  }
}

/*************************************************************
 * dsr2mmq_tdrp_table()
 *
 * Returns pointer to static Table for this module.
 */

TDRPtable *dsr2mmq_tdrp_table(void)
{
  return (Table);
}

/*************************************************************
 * dsr2mmq_tdrp_init()
 *
 * Module table initialization function.
 *
 *
 * Returns pointer to static Table for this module.
 */

TDRPtable *dsr2mmq_tdrp_init(dsr2mmq_tdrp_struct *params)

{

  TDRPtable *tt = Table;

  dsr2mmq_tdrp_struct pp; /* for computing byte_offsets */

  /* zero out struct, and store size */

  memset(params, 0, sizeof(dsr2mmq_tdrp_struct));
  params->struct_size = sizeof(dsr2mmq_tdrp_struct);

  /* Parameter 'debug' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("debug");
  tt->descr = tdrpStrDup("Debug option");
  tt->help = tdrpStrDup("Print debug messages");
  tt->val_offset = (char *) &(pp.debug) - (char *) &pp;
  tt->single_val.b = pFALSE;
  tt++;
  
  /* Parameter 'instance' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("instance");
  tt->descr = tdrpStrDup("Process instance");
  tt->help = tdrpStrDup("Used for registration with the process mapper");
  tt->val_offset = (char *) &(pp.instance) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("Test");
  tt++;
  
  /* Parameter 'fmq_url' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("fmq_url");
  tt->descr = tdrpStrDup("Input URL for DsRadar data via FMQ");
  tt->help = tdrpStrDup("");
  tt->val_offset = (char *) &(pp.fmq_url) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("fmqp:://localhost::./fmq.dsRadar");
  tt++;
  
  /* Parameter 'rdi_mmq_key' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("rdi_mmq_key");
  tt->descr = tdrpStrDup("Key for shared memory with RDI");
  tt->help = tdrpStrDup(" ");
  tt->val_offset = (char *) &(pp.rdi_mmq_key) - (char *) &pp;
  tt->single_val.l = 3740201;
  tt++;
  
  /* Parameter 'print_summary' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("print_summary");
  tt->descr = tdrpStrDup("Option to print summary");
  tt->help = tdrpStrDup("If set to true, ray header information will be printed to standard output");
  tt->val_offset = (char *) &(pp.print_summary) - (char *) &pp;
  tt->single_val.b = pFALSE;
  tt++;
  
  /* Parameter 'summary_interval' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("summary_interval");
  tt->descr = tdrpStrDup("Summary interval");
  tt->help = tdrpStrDup("Beam interval at which the summary is printed");
  tt->val_offset = (char *) &(pp.summary_interval) - (char *) &pp;
  tt->single_val.l = 360;
  tt++;
  
  /* Parameter 'use_ngates' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("use_ngates");
  tt->descr = tdrpStrDup("Use constant number of gates");
  tt->help = tdrpStrDup("If set to true, a constant number of gates per beam will be sent to the mmq.  If there are less gates than this number, the beam will be padded with zeros.  If there are more gates than this number, the beam will be truncated");
  tt->val_offset = (char *) &(pp.use_ngates) - (char *) &pp;
  tt->single_val.b = pTRUE;
  tt++;
  
  /* Parameter 'ngates' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("ngates");
  tt->descr = tdrpStrDup("Number of gates");
  tt->help = tdrpStrDup("If use_ngates is set to true, this is the number of gates per beam that will be sent to the mmq");
  tt->val_offset = (char *) &(pp.ngates) - (char *) &pp;
  tt->single_val.l = 460;
  tt++;
  
  /* Parameter 'clip_beams' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("clip_beams");
  tt->descr = tdrpStrDup("Clip beams");
  tt->help = tdrpStrDup("If set to true, each beam will be clipped");
  tt->val_offset = (char *) &(pp.clip_beams) - (char *) &pp;
  tt->single_val.b = pTRUE;
  tt++;
  
  /* Parameter 'clipping_alt' */
  /* ctype is 'double' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = DOUBLE_TYPE;
  tt->param_name = tdrpStrDup("clipping_alt");
  tt->descr = tdrpStrDup("Altitude (in km) above which data will be clipped");
  tt->help = tdrpStrDup("For each beam with an elevation angle greater than or equal to min_clipping_elev (see below), data above this altitude will be clipped");
  tt->val_offset = (char *) &(pp.clipping_alt) - (char *) &pp;
  tt->single_val.d = 1000;
  tt++;
  
  /* Parameter 'min_clipping_elev' */
  /* ctype is 'double' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = DOUBLE_TYPE;
  tt->param_name = tdrpStrDup("min_clipping_elev");
  tt->descr = tdrpStrDup("Minimum elevation for which clipping will be applied");
  tt->help = tdrpStrDup("Each beam with an elevation angle greater than or equal to this value wil be clipped (if clipping is activated)");
  tt->val_offset = (char *) &(pp.min_clipping_elev) - (char *) &pp;
  tt->single_val.d = 1;
  tt++;
  
  /* Parameter 'check_elev' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("check_elev");
  tt->descr = tdrpStrDup("Check elevation");
  tt->help = tdrpStrDup("If set to true, the elevation angle will be checked for each beam");
  tt->val_offset = (char *) &(pp.check_elev) - (char *) &pp;
  tt->single_val.b = pTRUE;
  tt++;
  
  /* Parameter 'min_elev' */
  /* ctype is 'double' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = DOUBLE_TYPE;
  tt->param_name = tdrpStrDup("min_elev");
  tt->descr = tdrpStrDup("Minimum elevation");
  tt->help = tdrpStrDup("If checking elevation, beams with elevation angles less than this will not be sent on to the mmq");
  tt->val_offset = (char *) &(pp.min_elev) - (char *) &pp;
  tt->single_val.d = 0;
  tt++;
  
  /* Parameter 'max_elev' */
  /* ctype is 'double' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = DOUBLE_TYPE;
  tt->param_name = tdrpStrDup("max_elev");
  tt->descr = tdrpStrDup("Maximum elevation");
  tt->help = tdrpStrDup("If checking elevation, beams with elevation angles greater than this will not be sent on to the mmq");
  tt->val_offset = (char *) &(pp.max_elev) - (char *) &pp;
  tt->single_val.d = 90;
  tt++;
  
  /* Parameter 'check_prf' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("check_prf");
  tt->descr = tdrpStrDup("Check prf");
  tt->help = tdrpStrDup("If set to true, the prf will be checked for each beam");
  tt->val_offset = (char *) &(pp.check_prf) - (char *) &pp;
  tt->single_val.b = pTRUE;
  tt++;
  
  /* Parameter 'min_prf' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("min_prf");
  tt->descr = tdrpStrDup("Minimum prf");
  tt->help = tdrpStrDup("If checking prf, beams with prf values less than this will not be sent on to the mmq");
  tt->val_offset = (char *) &(pp.min_prf) - (char *) &pp;
  tt->single_val.l = 0;
  tt++;
  
  /* Parameter 'max_prf' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("max_prf");
  tt->descr = tdrpStrDup("Maximum prf");
  tt->help = tdrpStrDup("If checking prf, beams with prf values less than this will not be ssent on to the mmq");
  tt->val_offset = (char *) &(pp.max_prf) - (char *) &pp;
  tt->single_val.l = 100000;
  tt++;
  
  /* trailing entry has param_name set to NULL */
  
  tt->param_name = NULL;
  
  return (Table);

}
