/*******************************************
 * bdry_spdb2symprod_tdrp.c
 *
 * TDRP C code file 'bdry_spdb2symprod' module.
 *
 * Code for program bdry_spdb2symprod
 *
 * This file has been automatically
 * generated by TDRP, do not modify.
 *
 *******************************************/

#include "bdry_spdb2symprod_tdrp.h"
#include <string.h>

/*
 * file scope variables
 */

static TDRPtable Table[32];
static bdry_spdb2symprod_tdrp_struct *Params;
static char *Module = "bdry_spdb2symprod";

/*************************************************************
 * bdry_spdb2symprod_tdrp_load_from_args()
 *
 * Loads up TDRP using the command line args.
 *
 * Check TDRP_usage() for command line actions associated with
 * this function.
 *
 *   argc, argv: command line args
 *
 *   bdry_spdb2symprod_tdrp_struct *params: loads up this struct
 * 
 *   char **override_list: A null-terminated list of overrides
 *     to the parameter file.
 *     An override string has exactly the format of an entry
 *     in the parameter file itself.
 *
 *   char **params_path_p: if non-NULL, this is set to point to
 *                         the path of the params file used.
 *
 *  Returns 0 on success, -1 on failure.
 */

int bdry_spdb2symprod_tdrp_load_from_args(int argc, char **argv,
                         bdry_spdb2symprod_tdrp_struct *params,
                         char **override_list,
                         char **params_path_p)
{
  Params = params;
  bdry_spdb2symprod_tdrp_init(Params);
  if (tdrpLoadFromArgs(argc, argv,
                       Table, Params,
                       override_list, params_path_p)) {
    return (-1);
  } else {
    return (0);
  }
}

/*************************************************************
 * bdry_spdb2symprod_tdrp_load()
 *
 * Loads up TDRP for a given module.
 *
 * This version of load gives the programmer the option to load
 * up more than one module for a single application. It is a
 * lower-level routine than bdry_spdb2symprod_tdrp_load_from_args,
 * and hence more flexible, but the programmer must do more work.
 *
 *   char *param_file_path: the parameter file to be read in.
 *
 *   bdry_spdb2symprod_tdrp_struct *params: loads up this struct
 *
 *   char **override_list: A null-terminated list of overrides
 *     to the parameter file.
 *     An override string has exactly the format of an entry
 *     in the parameter file itself.
 *
 *  expand_env: flag to control environment variable
 *                expansion during tokenization.
 *              If TRUE, environment expansion is set on.
 *              If FALSE, environment expansion is set off.
 *
 *  Returns 0 on success, -1 on failure.
 */

int bdry_spdb2symprod_tdrp_load(char *param_file_path,
               bdry_spdb2symprod_tdrp_struct *params,
               char **override_list,
               int expand_env, int debug)
{
  Params = params;
  bdry_spdb2symprod_tdrp_init(Params);
  if (tdrpLoad(param_file_path, Table,
               params, override_list,
               expand_env, debug)) {
    return (-1);
  } else {
    return (0);
  }
}

/*************************************************************
 * bdry_spdb2symprod_tdrp_load_defaults()
 *
 * Loads up defaults for a given module.
 *
 * See bdry_spdb2symprod_tdrp_load() for more details.
 *
 *  Returns 0 on success, -1 on failure.
 */

int bdry_spdb2symprod_tdrp_load_defaults(bdry_spdb2symprod_tdrp_struct *params,
                        int expand_env)
{
  Params = params;
  bdry_spdb2symprod_tdrp_init(Params);
  if (tdrpLoad(NULL, Table,
               params, NULL,
               expand_env, FALSE)) {
    return (-1);
  } else {
    return (0);
  }
}

/*************************************************************
 * bdry_spdb2symprod_tdrp_sync()
 *
 * Syncs the user struct data back into the parameter table,
 * in preparation for printing.
 */

void bdry_spdb2symprod_tdrp_sync(void)
{
  tdrpUser2Table(Table, Params);
}

/*************************************************************
 * bdry_spdb2symprod_tdrp_print()
 * 
 * Print params file
 *
 * The modes supported are:
 *
 *   PRINT_SHORT:   main comments only, no help or descriptions
 *                  structs and arrays on a single line
 *   PRINT_NORM:    short + descriptions and help
 *   PRINT_LONG:    norm  + arrays and structs expanded
 *   PRINT_VERBOSE: long  + private params included
 */

void bdry_spdb2symprod_tdrp_print(FILE *out, tdrp_print_mode_t mode)
{
  tdrpPrint(out, Table, Module, mode);
}

/*************************************************************
 * bdry_spdb2symprod_tdrp_check_all_set()
 *
 * Return TRUE if all set, FALSE if not.
 *
 * If out is non-NULL, prints out warning messages for those
 * parameters which are not set.
 */

int bdry_spdb2symprod_tdrp_check_all_set(FILE *out)
{
  return (tdrpCheckAllSet(out, Table, Params));
}

/*************************************************************
 * bdry_spdb2symprod_tdrp_check_is_set()
 *
 * Return TRUE if parameter is set, FALSE if not.
 *
 */

int bdry_spdb2symprod_tdrp_check_is_set(char *param_name)
{
  return (tdrpCheckIsSet(param_name, Table, Params));
}

/*************************************************************
 * bdry_spdb2symprod_tdrp_free_all()
 *
 * Frees up all TDRP dynamic memory.
 */

void bdry_spdb2symprod_tdrp_free_all(void)
{
  tdrpFreeAll(Table, Params);
}

/*************************************************************
 * bdry_spdb2symprod_tdrp_array_realloc()
 *
 * Realloc 1D array.
 *
 * If size is increased, the values from the last array entry is
 * copied into the new space.
 *
 * Returns 0 on success, -1 on error.
 */

int bdry_spdb2symprod_tdrp_array_realloc(char *param_name, int new_array_n)
{
  if (tdrpArrayRealloc(Table, Params, param_name, new_array_n)) {
    return (-1);
  } else {
    return (0);
  }
}

/*************************************************************
 * bdry_spdb2symprod_tdrp_array2D_realloc()
 *
 * Realloc 2D array.
 *
 * If size is increased, the values from the last array entry is
 * copied into the new space.
 *
 * Returns 0 on success, -1 on error.
 */

int bdry_spdb2symprod_tdrp_array2D_realloc(char *param_name,
                          int new_array_n1,
                          int new_array_n2)
{
  if (tdrpArray2DRealloc(Table, Params, param_name,
			 new_array_n1, new_array_n2)) {
    return (-1);
  } else {
    return (0);
  }
}

/*************************************************************
 * bdry_spdb2symprod_tdrp_table()
 *
 * Returns pointer to static Table for this module.
 */

TDRPtable *bdry_spdb2symprod_tdrp_table(void)
{
  return (Table);
}

/*************************************************************
 * bdry_spdb2symprod_tdrp_init()
 *
 * Module table initialization function.
 *
 *
 * Returns pointer to static Table for this module.
 */

TDRPtable *bdry_spdb2symprod_tdrp_init(bdry_spdb2symprod_tdrp_struct *params)

{

  TDRPtable *tt = Table;

  bdry_spdb2symprod_tdrp_struct pp; /* for computing byte_offsets */

  /* zero out struct, and store size */

  memset(params, 0, sizeof(bdry_spdb2symprod_tdrp_struct));
  params->struct_size = sizeof(bdry_spdb2symprod_tdrp_struct);

  /* Parameter 'debug' */
  /* ctype is 'bdry_spdb2symprod_debug_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = ENUM_TYPE;
  tt->param_name = tdrpStrDup("debug");
  tt->descr = tdrpStrDup("debug level");
  tt->help = tdrpStrDup("Debug level: DEBUG_OFF, DEBUG_ERRORS, DEBUG_MSGS, DEBUG_ROUTINES, DEBUG_ALL.");
  tt->val_offset = (char *) &(pp.debug) - (char *) &pp;
  tt->enum_def.name = tdrpStrDup("debug_t");
  tt->enum_def.nfields = 5;
  tt->enum_def.fields = (enum_field_t *)
      tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
    tt->enum_def.fields[0].name = tdrpStrDup("DEBUG_OFF");
    tt->enum_def.fields[0].val = DEBUG_OFF;
    tt->enum_def.fields[1].name = tdrpStrDup("DEBUG_ERRORS");
    tt->enum_def.fields[1].val = DEBUG_ERRORS;
    tt->enum_def.fields[2].name = tdrpStrDup("DEBUG_MSGS");
    tt->enum_def.fields[2].val = DEBUG_MSGS;
    tt->enum_def.fields[3].name = tdrpStrDup("DEBUG_ROUTINES");
    tt->enum_def.fields[3].val = DEBUG_ROUTINES;
    tt->enum_def.fields[4].name = tdrpStrDup("DEBUG_ALL");
    tt->enum_def.fields[4].val = DEBUG_ALL;
  tt->single_val.e = DEBUG_OFF;
  tt++;
  
  /* Parameter 'malloc_debug_level' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("malloc_debug_level");
  tt->descr = tdrpStrDup("malloc debug level");
  tt->help = tdrpStrDup("0 = none, 1 = corruption checking, 2 = record all malloc blocks and checks, 3 = printout of all mallocs, etc.");
  tt->val_offset = (char *) &(pp.malloc_debug_level) - (char *) &pp;
  tt->has_min = TRUE;
  tt->has_max = TRUE;
  tt->min_val.l = 0;
  tt->max_val.l = 3;
  tt->single_val.l = 0;
  tt++;
  
  /* Parameter 'wait_msecs' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("wait_msecs");
  tt->descr = tdrpStrDup("wait msecs");
  tt->help = tdrpStrDup("Number of milliseconds to wait before timing out socket operations.");
  tt->val_offset = (char *) &(pp.wait_msecs) - (char *) &pp;
  tt->single_val.l = 100;
  tt++;
  
  /* Parameter 'latitude_shift' */
  /* ctype is 'double' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = DOUBLE_TYPE;
  tt->param_name = tdrpStrDup("latitude_shift");
  tt->descr = tdrpStrDup("vertex latitude shift");
  tt->help = tdrpStrDup("This value is added to the latitude of each vertex in each boundary to shift the boundaries relative to a new location.");
  tt->val_offset = (char *) &(pp.latitude_shift) - (char *) &pp;
  tt->single_val.d = 0;
  tt++;
  
  /* Parameter 'longitude_shift' */
  /* ctype is 'double' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = DOUBLE_TYPE;
  tt->param_name = tdrpStrDup("longitude_shift");
  tt->descr = tdrpStrDup("vertex longitude shift");
  tt->help = tdrpStrDup("This value is added to the longitude of each vertex in each boundary to shift the boundaries relative to a new location.");
  tt->val_offset = (char *) &(pp.longitude_shift) - (char *) &pp;
  tt->single_val.d = 0;
  tt++;
  
  /* Parameter 'database_dir' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("database_dir");
  tt->descr = tdrpStrDup("database directory");
  tt->help = tdrpStrDup("Directory containing SPDB database.");
  tt->val_offset = (char *) &(pp.database_dir) - (char *) &pp;
  tt->single_val.s = tdrpStrDup(".");
  tt++;
  
  /* Parameter 'product_label' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("product_label");
  tt->descr = tdrpStrDup("product label");
  tt->help = tdrpStrDup("The product label used in the SPDB database to uniquely identify this product.");
  tt->val_offset = (char *) &(pp.product_label) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("Boundary Data");
  tt++;
  
  /* Parameter 'product_id' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("product_id");
  tt->descr = tdrpStrDup("product id");
  tt->help = tdrpStrDup("Number which uniquely identifies this product in the SPDB database.");
  tt->val_offset = (char *) &(pp.product_id) - (char *) &pp;
  tt->single_val.l = 300;
  tt++;
  
  /* Parameter 'port' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("port");
  tt->descr = tdrpStrDup("port");
  tt->help = tdrpStrDup("Server port number.");
  tt->val_offset = (char *) &(pp.port) - (char *) &pp;
  tt->single_val.l = 62000;
  tt++;
  
  /* Parameter 'servmap_type' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("servmap_type");
  tt->descr = tdrpStrDup("servmap type");
  tt->help = tdrpStrDup("Server mapper type for this server.");
  tt->val_offset = (char *) &(pp.servmap_type) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("Spdb");
  tt++;
  
  /* Parameter 'servmap_subtype' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("servmap_subtype");
  tt->descr = tdrpStrDup("servmap subtype");
  tt->help = tdrpStrDup("Server mapper subtype for this server.  The type is always Spdb.");
  tt->val_offset = (char *) &(pp.servmap_subtype) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("Symprod");
  tt++;
  
  /* Parameter 'servmap_instance' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("servmap_instance");
  tt->descr = tdrpStrDup("servmap instance");
  tt->help = tdrpStrDup("Server mapper instance for this server.  The type is always Spdb.");
  tt->val_offset = (char *) &(pp.servmap_instance) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("Test");
  tt++;
  
  /* Parameter 'realtime_avail' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("realtime_avail");
  tt->descr = tdrpStrDup("realtime available flag");
  tt->help = tdrpStrDup("Flag indicating if realtime data is available from this server.");
  tt->val_offset = (char *) &(pp.realtime_avail) - (char *) &pp;
  tt->single_val.b = pTRUE;
  tt++;
  
  /* Parameter 'display_detections' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("display_detections");
  tt->descr = tdrpStrDup("display detection flag");
  tt->help = tdrpStrDup("If FALSE, the detections will not be displayed.");
  tt->val_offset = (char *) &(pp.display_detections) - (char *) &pp;
  tt->single_val.b = pTRUE;
  tt++;
  
  /* Parameter 'detection_color' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("detection_color");
  tt->descr = tdrpStrDup("detection color");
  tt->help = tdrpStrDup("Name of color suggested for rendering the detection polyline.");
  tt->val_offset = (char *) &(pp.detection_color) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("purple");
  tt++;
  
  /* Parameter 'display_extrapolations' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("display_extrapolations");
  tt->descr = tdrpStrDup("display extrapolation flag");
  tt->help = tdrpStrDup("If FALSE, the extrapolations will not be displayed.");
  tt->val_offset = (char *) &(pp.display_extrapolations) - (char *) &pp;
  tt->single_val.b = pTRUE;
  tt++;
  
  /* Parameter 'extrapolation_color' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("extrapolation_color");
  tt->descr = tdrpStrDup("extrapolation color");
  tt->help = tdrpStrDup("Name of color suggested for rendering the extrapolation polyline.");
  tt->val_offset = (char *) &(pp.extrapolation_color) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("blue");
  tt++;
  
  /* Parameter 'display_line_type' */
  /* ctype is 'bdry_spdb2symprod_line_type_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = ENUM_TYPE;
  tt->param_name = tdrpStrDup("display_line_type");
  tt->descr = tdrpStrDup("display line type");
  tt->help = tdrpStrDup("Line type suggested for using on the display.");
  tt->val_offset = (char *) &(pp.display_line_type) - (char *) &pp;
  tt->enum_def.name = tdrpStrDup("line_type_t");
  tt->enum_def.nfields = 3;
  tt->enum_def.fields = (enum_field_t *)
      tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
    tt->enum_def.fields[0].name = tdrpStrDup("LINETYPE_SOLID");
    tt->enum_def.fields[0].val = LINETYPE_SOLID;
    tt->enum_def.fields[1].name = tdrpStrDup("LINETYPE_DASH");
    tt->enum_def.fields[1].val = LINETYPE_DASH;
    tt->enum_def.fields[2].name = tdrpStrDup("LINETYPE_DOT_DASH");
    tt->enum_def.fields[2].val = LINETYPE_DOT_DASH;
  tt->single_val.e = LINETYPE_SOLID;
  tt++;
  
  /* Parameter 'display_line_width' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("display_line_width");
  tt->descr = tdrpStrDup("display line width");
  tt->help = tdrpStrDup("Line width suggested for using on the display.");
  tt->val_offset = (char *) &(pp.display_line_width) - (char *) &pp;
  tt->single_val.l = 1;
  tt++;
  
  /* Parameter 'display_capstyle' */
  /* ctype is 'bdry_spdb2symprod_capstyle_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = ENUM_TYPE;
  tt->param_name = tdrpStrDup("display_capstyle");
  tt->descr = tdrpStrDup("display capstyle");
  tt->help = tdrpStrDup("Capstyle suggested for using on the display.");
  tt->val_offset = (char *) &(pp.display_capstyle) - (char *) &pp;
  tt->enum_def.name = tdrpStrDup("capstyle_t");
  tt->enum_def.nfields = 4;
  tt->enum_def.fields = (enum_field_t *)
      tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
    tt->enum_def.fields[0].name = tdrpStrDup("CAPSTYLE_BUTT");
    tt->enum_def.fields[0].val = CAPSTYLE_BUTT;
    tt->enum_def.fields[1].name = tdrpStrDup("CAPSTYLE_NOT_LAST");
    tt->enum_def.fields[1].val = CAPSTYLE_NOT_LAST;
    tt->enum_def.fields[2].name = tdrpStrDup("CAPSTYLE_PROJECTING");
    tt->enum_def.fields[2].val = CAPSTYLE_PROJECTING;
    tt->enum_def.fields[3].name = tdrpStrDup("CAPSTYLE_ROUND");
    tt->enum_def.fields[3].val = CAPSTYLE_ROUND;
  tt->single_val.e = CAPSTYLE_BUTT;
  tt++;
  
  /* Parameter 'display_joinstyle' */
  /* ctype is 'bdry_spdb2symprod_joinstyle_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = ENUM_TYPE;
  tt->param_name = tdrpStrDup("display_joinstyle");
  tt->descr = tdrpStrDup("display joinstyle");
  tt->help = tdrpStrDup("Joinstyle suggested for using on the display.");
  tt->val_offset = (char *) &(pp.display_joinstyle) - (char *) &pp;
  tt->enum_def.name = tdrpStrDup("joinstyle_t");
  tt->enum_def.nfields = 3;
  tt->enum_def.fields = (enum_field_t *)
      tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
    tt->enum_def.fields[0].name = tdrpStrDup("JOINSTYLE_BEVEL");
    tt->enum_def.fields[0].val = JOINSTYLE_BEVEL;
    tt->enum_def.fields[1].name = tdrpStrDup("JOINSTYLE_MITER");
    tt->enum_def.fields[1].val = JOINSTYLE_MITER;
    tt->enum_def.fields[2].name = tdrpStrDup("JOINSTYLE_ROUND");
    tt->enum_def.fields[2].val = JOINSTYLE_ROUND;
  tt->single_val.e = JOINSTYLE_BEVEL;
  tt++;
  
  /* Parameter 'display_label' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("display_label");
  tt->descr = tdrpStrDup("display label flag");
  tt->help = tdrpStrDup("If TRUE, the boundary label will be displayed with the boundary.");
  tt->val_offset = (char *) &(pp.display_label) - (char *) &pp;
  tt->single_val.b = pTRUE;
  tt++;
  
  /* Parameter 'label_source' */
  /* ctype is 'bdry_spdb2symprod_label_source' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = ENUM_TYPE;
  tt->param_name = tdrpStrDup("label_source");
  tt->descr = tdrpStrDup("label source flag");
  tt->help = tdrpStrDup("Label indicating where to get the label for the boundary.  For COLIDE boundaries, the label should come from the description field in the shape.  For other boundaries, I would expect the label to come from within the polyline itself since each shape is allowed to contain more than one polyline.");
  tt->val_offset = (char *) &(pp.label_source) - (char *) &pp;
  tt->enum_def.name = tdrpStrDup("label_source");
  tt->enum_def.nfields = 2;
  tt->enum_def.fields = (enum_field_t *)
      tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
    tt->enum_def.fields[0].name = tdrpStrDup("LABEL_DESCRIP");
    tt->enum_def.fields[0].val = LABEL_DESCRIP;
    tt->enum_def.fields[1].name = tdrpStrDup("LABEL_POLYLINE");
    tt->enum_def.fields[1].val = LABEL_POLYLINE;
  tt->single_val.e = LABEL_POLYLINE;
  tt++;
  
  /* Parameter 'label_font' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("label_font");
  tt->descr = tdrpStrDup("label font name");
  tt->help = tdrpStrDup("The name of the X font to be used when rendering the label.");
  tt->val_offset = (char *) &(pp.label_font) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("8x13");
  tt++;
  
  /* Parameter 'display_vector' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("display_vector");
  tt->descr = tdrpStrDup("display vector flag");
  tt->help = tdrpStrDup("If TRUE, the motion vector will be displayed with the boundary.");
  tt->val_offset = (char *) &(pp.display_vector) - (char *) &pp;
  tt->single_val.b = pFALSE;
  tt++;
  
  /* Parameter 'vector_color' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("vector_color");
  tt->descr = tdrpStrDup("motion vector color");
  tt->help = tdrpStrDup("Name of color suggested for rendering the motion vector.");
  tt->val_offset = (char *) &(pp.vector_color) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("purple");
  tt++;
  
  /* Parameter 'extrap_secs' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("extrap_secs");
  tt->descr = tdrpStrDup("extrapolation seconds to use when rendering the motion vector");
  tt->help = tdrpStrDup("Since we are now extrapolating the boundaries upon request, we don't know the extrapolation time period anymore.  So, we must now supply it.");
  tt->val_offset = (char *) &(pp.extrap_secs) - (char *) &pp;
  tt->has_min = TRUE;
  tt->min_val.l = 0;
  tt->single_val.l = 0;
  tt++;
  
  /* Parameter 'head_length' */
  /* ctype is 'double' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = DOUBLE_TYPE;
  tt->param_name = tdrpStrDup("head_length");
  tt->descr = tdrpStrDup("Vector arrowhead length in km");
  tt->help = tdrpStrDup("");
  tt->val_offset = (char *) &(pp.head_length) - (char *) &pp;
  tt->single_val.d = 5;
  tt++;
  
  /* Parameter 'head_half_angle' */
  /* ctype is 'double' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = DOUBLE_TYPE;
  tt->param_name = tdrpStrDup("head_half_angle");
  tt->descr = tdrpStrDup("Vector arrowhead half angle in degrees");
  tt->help = tdrpStrDup("This is the angle between the arrowhead line and the vector line.");
  tt->val_offset = (char *) &(pp.head_half_angle) - (char *) &pp;
  tt->single_val.d = 45;
  tt++;
  
  /* Parameter 'calc_extrapolations' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("calc_extrapolations");
  tt->descr = tdrpStrDup("calculate extrapolations flag");
  tt->help = tdrpStrDup("If TRUE, the server will calculate the extrapolation polylines rather than using the extrapolations in the database.");
  tt->val_offset = (char *) &(pp.calc_extrapolations) - (char *) &pp;
  tt->single_val.b = pFALSE;
  tt++;
  
  /* Parameter 'point_extrapolations' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("point_extrapolations");
  tt->descr = tdrpStrDup("use point motion extrapolation method");
  tt->help = tdrpStrDup("If TRUE, and calc_extrapolations is TRUE, extrapolate each point of the boundary based on speed of the boundary at that point.  If FALSE, the average motion vector will be used to calculate the extrapolation");
  tt->val_offset = (char *) &(pp.point_extrapolations) - (char *) &pp;
  tt->single_val.b = pFALSE;
  tt++;
  
  /* trailing entry has param_name set to NULL */
  
  tt->param_name = NULL;
  
  return (Table);

}
