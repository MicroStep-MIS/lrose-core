/*******************************************
 * ac_spdb2symprod_tdrp.c
 *
 * TDRP C code file 'ac_spdb2symprod' module.
 *
 * Code for program ac_spdb2symprod
 *
 * This file has been automatically
 * generated by TDRP, do not modify.
 *
 *******************************************/

#include "ac_spdb2symprod_tdrp.h"
#include <string.h>

/*
 * file scope variables
 */

static TDRPtable Table[43];
static ac_spdb2symprod_tdrp_struct *Params;
static char *Module = "ac_spdb2symprod";

/*************************************************************
 * ac_spdb2symprod_tdrp_load_from_args()
 *
 * Loads up TDRP using the command line args.
 *
 * Check TDRP_usage() for command line actions associated with
 * this function.
 *
 *   argc, argv: command line args
 *
 *   ac_spdb2symprod_tdrp_struct *params: loads up this struct
 * 
 *   char **override_list: A null-terminated list of overrides
 *     to the parameter file.
 *     An override string has exactly the format of an entry
 *     in the parameter file itself.
 *
 *   char **params_path_p: if non-NULL, this is set to point to
 *                         the path of the params file used.
 *
 *  Returns 0 on success, -1 on failure.
 */

int ac_spdb2symprod_tdrp_load_from_args(int argc, char **argv,
                         ac_spdb2symprod_tdrp_struct *params,
                         char **override_list,
                         char **params_path_p)
{
  Params = params;
  ac_spdb2symprod_tdrp_init(Params);
  if (tdrpLoadFromArgs(argc, argv,
                       Table, Params,
                       override_list, params_path_p)) {
    return (-1);
  } else {
    return (0);
  }
}

/*************************************************************
 * ac_spdb2symprod_tdrp_load()
 *
 * Loads up TDRP for a given module.
 *
 * This version of load gives the programmer the option to load
 * up more than one module for a single application. It is a
 * lower-level routine than ac_spdb2symprod_tdrp_load_from_args,
 * and hence more flexible, but the programmer must do more work.
 *
 *   char *param_file_path: the parameter file to be read in.
 *
 *   ac_spdb2symprod_tdrp_struct *params: loads up this struct
 *
 *   char **override_list: A null-terminated list of overrides
 *     to the parameter file.
 *     An override string has exactly the format of an entry
 *     in the parameter file itself.
 *
 *  expand_env: flag to control environment variable
 *                expansion during tokenization.
 *              If TRUE, environment expansion is set on.
 *              If FALSE, environment expansion is set off.
 *
 *  Returns 0 on success, -1 on failure.
 */

int ac_spdb2symprod_tdrp_load(char *param_file_path,
               ac_spdb2symprod_tdrp_struct *params,
               char **override_list,
               int expand_env, int debug)
{
  Params = params;
  ac_spdb2symprod_tdrp_init(Params);
  if (tdrpLoad(param_file_path, Table,
               params, override_list,
               expand_env, debug)) {
    return (-1);
  } else {
    return (0);
  }
}

/*************************************************************
 * ac_spdb2symprod_tdrp_load_defaults()
 *
 * Loads up defaults for a given module.
 *
 * See ac_spdb2symprod_tdrp_load() for more details.
 *
 *  Returns 0 on success, -1 on failure.
 */

int ac_spdb2symprod_tdrp_load_defaults(ac_spdb2symprod_tdrp_struct *params,
                        int expand_env)
{
  Params = params;
  ac_spdb2symprod_tdrp_init(Params);
  if (tdrpLoad(NULL, Table,
               params, NULL,
               expand_env, FALSE)) {
    return (-1);
  } else {
    return (0);
  }
}

/*************************************************************
 * ac_spdb2symprod_tdrp_sync()
 *
 * Syncs the user struct data back into the parameter table,
 * in preparation for printing.
 */

void ac_spdb2symprod_tdrp_sync(void)
{
  tdrpUser2Table(Table, Params);
}

/*************************************************************
 * ac_spdb2symprod_tdrp_print()
 * 
 * Print params file
 *
 * The modes supported are:
 *
 *   PRINT_SHORT:   main comments only, no help or descriptions
 *                  structs and arrays on a single line
 *   PRINT_NORM:    short + descriptions and help
 *   PRINT_LONG:    norm  + arrays and structs expanded
 *   PRINT_VERBOSE: long  + private params included
 */

void ac_spdb2symprod_tdrp_print(FILE *out, tdrp_print_mode_t mode)
{
  tdrpPrint(out, Table, Module, mode);
}

/*************************************************************
 * ac_spdb2symprod_tdrp_check_all_set()
 *
 * Return TRUE if all set, FALSE if not.
 *
 * If out is non-NULL, prints out warning messages for those
 * parameters which are not set.
 */

int ac_spdb2symprod_tdrp_check_all_set(FILE *out)
{
  return (tdrpCheckAllSet(out, Table, Params));
}

/*************************************************************
 * ac_spdb2symprod_tdrp_check_is_set()
 *
 * Return TRUE if parameter is set, FALSE if not.
 *
 */

int ac_spdb2symprod_tdrp_check_is_set(char *param_name)
{
  return (tdrpCheckIsSet(param_name, Table, Params));
}

/*************************************************************
 * ac_spdb2symprod_tdrp_free_all()
 *
 * Frees up all TDRP dynamic memory.
 */

void ac_spdb2symprod_tdrp_free_all(void)
{
  tdrpFreeAll(Table, Params);
}

/*************************************************************
 * ac_spdb2symprod_tdrp_array_realloc()
 *
 * Realloc 1D array.
 *
 * If size is increased, the values from the last array entry is
 * copied into the new space.
 *
 * Returns 0 on success, -1 on error.
 */

int ac_spdb2symprod_tdrp_array_realloc(char *param_name, int new_array_n)
{
  if (tdrpArrayRealloc(Table, Params, param_name, new_array_n)) {
    return (-1);
  } else {
    return (0);
  }
}

/*************************************************************
 * ac_spdb2symprod_tdrp_array2D_realloc()
 *
 * Realloc 2D array.
 *
 * If size is increased, the values from the last array entry is
 * copied into the new space.
 *
 * Returns 0 on success, -1 on error.
 */

int ac_spdb2symprod_tdrp_array2D_realloc(char *param_name,
                          int new_array_n1,
                          int new_array_n2)
{
  if (tdrpArray2DRealloc(Table, Params, param_name,
			 new_array_n1, new_array_n2)) {
    return (-1);
  } else {
    return (0);
  }
}

/*************************************************************
 * ac_spdb2symprod_tdrp_table()
 *
 * Returns pointer to static Table for this module.
 */

TDRPtable *ac_spdb2symprod_tdrp_table(void)
{
  return (Table);
}

/*************************************************************
 * ac_spdb2symprod_tdrp_init()
 *
 * Module table initialization function.
 *
 *
 * Returns pointer to static Table for this module.
 */

TDRPtable *ac_spdb2symprod_tdrp_init(ac_spdb2symprod_tdrp_struct *params)

{

  TDRPtable *tt = Table;

  ac_spdb2symprod_tdrp_struct pp; /* for computing byte_offsets */

  /* zero out struct, and store size */

  memset(params, 0, sizeof(ac_spdb2symprod_tdrp_struct));
  params->struct_size = sizeof(ac_spdb2symprod_tdrp_struct);

  /* Parameter 'debug' */
  /* ctype is 'ac_spdb2symprod_debug_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = ENUM_TYPE;
  tt->param_name = tdrpStrDup("debug");
  tt->descr = tdrpStrDup("debug level");
  tt->help = tdrpStrDup("Level of debug messages to be displayed.");
  tt->val_offset = (char *) &(pp.debug) - (char *) &pp;
  tt->enum_def.name = tdrpStrDup("debug_t");
  tt->enum_def.nfields = 5;
  tt->enum_def.fields = (enum_field_t *)
      tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
    tt->enum_def.fields[0].name = tdrpStrDup("DEBUG_OFF");
    tt->enum_def.fields[0].val = DEBUG_OFF;
    tt->enum_def.fields[1].name = tdrpStrDup("DEBUG_ERRORS");
    tt->enum_def.fields[1].val = DEBUG_ERRORS;
    tt->enum_def.fields[2].name = tdrpStrDup("DEBUG_MSGS");
    tt->enum_def.fields[2].val = DEBUG_MSGS;
    tt->enum_def.fields[3].name = tdrpStrDup("DEBUG_ROUTINES");
    tt->enum_def.fields[3].val = DEBUG_ROUTINES;
    tt->enum_def.fields[4].name = tdrpStrDup("DEBUG_ALL");
    tt->enum_def.fields[4].val = DEBUG_ALL;
  tt->single_val.e = DEBUG_OFF;
  tt++;
  
  /* Parameter 'malloc_debug_level' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("malloc_debug_level");
  tt->descr = tdrpStrDup("malloc debug level");
  tt->help = tdrpStrDup("0 = none, 1 = corruption checking, 2 = record all malloc blocks and checks, 3 = printout of all mallocs, etc.");
  tt->val_offset = (char *) &(pp.malloc_debug_level) - (char *) &pp;
  tt->has_min = TRUE;
  tt->has_max = TRUE;
  tt->min_val.l = 0;
  tt->max_val.l = 3;
  tt->single_val.l = 0;
  tt++;
  
  /* Parameter 'wait_msecs' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("wait_msecs");
  tt->descr = tdrpStrDup("wait msecs");
  tt->help = tdrpStrDup("Number of milliseconds to wait before timing out socket operations.");
  tt->val_offset = (char *) &(pp.wait_msecs) - (char *) &pp;
  tt->single_val.l = 100;
  tt++;
  
  /* Parameter 'database_dir' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("database_dir");
  tt->descr = tdrpStrDup("database directory");
  tt->help = tdrpStrDup("Directory containing SPDB database.");
  tt->val_offset = (char *) &(pp.database_dir) - (char *) &pp;
  tt->single_val.s = tdrpStrDup(".");
  tt++;
  
  /* Parameter 'product_label' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("product_label");
  tt->descr = tdrpStrDup("product label");
  tt->help = tdrpStrDup("The product label used in the SPDB database to uniquely identify this product.");
  tt->val_offset = (char *) &(pp.product_label) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("AC_POSN");
  tt++;
  
  /* Parameter 'product_id' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("product_id");
  tt->descr = tdrpStrDup("product id");
  tt->help = tdrpStrDup("Number which uniquely identifies this product in the SPDB database.");
  tt->val_offset = (char *) &(pp.product_id) - (char *) &pp;
  tt->single_val.l = 20001;
  tt++;
  
  /* Parameter 'port' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("port");
  tt->descr = tdrpStrDup("port");
  tt->help = tdrpStrDup("Server port number.");
  tt->val_offset = (char *) &(pp.port) - (char *) &pp;
  tt->single_val.l = 62000;
  tt++;
  
  /* Parameter 'servmap_type' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("servmap_type");
  tt->descr = tdrpStrDup("servmap type");
  tt->help = tdrpStrDup("Server mapper type for this server.");
  tt->val_offset = (char *) &(pp.servmap_type) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("Spdb");
  tt++;
  
  /* Parameter 'servmap_subtype' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("servmap_subtype");
  tt->descr = tdrpStrDup("servmap subtype");
  tt->help = tdrpStrDup("Server mapper subtype for this server.");
  tt->val_offset = (char *) &(pp.servmap_subtype) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("Spdb");
  tt++;
  
  /* Parameter 'servmap_instance' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("servmap_instance");
  tt->descr = tdrpStrDup("servmap instance");
  tt->help = tdrpStrDup("Server mapper instance for this server.");
  tt->val_offset = (char *) &(pp.servmap_instance) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("Test");
  tt++;
  
  /* Parameter 'realtime_avail' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("realtime_avail");
  tt->descr = tdrpStrDup("realtime available flag");
  tt->help = tdrpStrDup("Flag indicating if realtime data is available from this server.");
  tt->val_offset = (char *) &(pp.realtime_avail) - (char *) &pp;
  tt->single_val.b = pTRUE;
  tt++;
  
  /* Parameter 'display_ga' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("display_ga");
  tt->descr = tdrpStrDup("display GA aircraft flag");
  tt->help = tdrpStrDup("If TRUE, all aircraft, including GA aircraft, will be displayed.  If FALSE, GA aircraft won't be displayed.  For this purporse, a GA aircraft is assumed to be any aircraft with a number somewhere in the first 3 characters of its callsign.");
  tt->val_offset = (char *) &(pp.display_ga) - (char *) &pp;
  tt->single_val.b = pTRUE;
  tt++;
  
  /* Parameter 'polyline_width' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("polyline_width");
  tt->descr = tdrpStrDup("Width of polylines");
  tt->help = tdrpStrDup("");
  tt->val_offset = (char *) &(pp.polyline_width) - (char *) &pp;
  tt->has_min = TRUE;
  tt->min_val.l = 1;
  tt->single_val.l = 1;
  tt++;
  
  /* Parameter 'plot_dirn_arrow' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("plot_dirn_arrow");
  tt->descr = tdrpStrDup("Plot the arrow for direction");
  tt->help = tdrpStrDup("If TRUE, an arrow will be added to the end of the polyline to indicate the direction of travel of the aircraft.\n");
  tt->val_offset = (char *) &(pp.plot_dirn_arrow) - (char *) &pp;
  tt->single_val.b = pFALSE;
  tt++;
  
  /* Parameter 'dirn_arrow_head_len' */
  /* ctype is 'double' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = DOUBLE_TYPE;
  tt->param_name = tdrpStrDup("dirn_arrow_head_len");
  tt->descr = tdrpStrDup("Length of head of dirn arrow (km)");
  tt->help = tdrpStrDup("");
  tt->val_offset = (char *) &(pp.dirn_arrow_head_len) - (char *) &pp;
  tt->has_min = TRUE;
  tt->min_val.d = 0;
  tt->single_val.d = 2;
  tt++;
  
  /* Parameter 'sparse_icons' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("sparse_icons");
  tt->descr = tdrpStrDup("Option to check space between icons.");
  tt->help = tdrpStrDup("If TRUE, the distance between consecutive icons will be computed.");
  tt->val_offset = (char *) &(pp.sparse_icons) - (char *) &pp;
  tt->single_val.b = pFALSE;
  tt++;
  
  /* Parameter 'sparse_icons_min_distance' */
  /* ctype is 'double' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = DOUBLE_TYPE;
  tt->param_name = tdrpStrDup("sparse_icons_min_distance");
  tt->descr = tdrpStrDup("Minimum distance between sparse icons (km).");
  tt->help = tdrpStrDup("Applicable if sparse_icons is TRUE. Icon rendering will be limited so that this minimum distance is exceeded bewteen consecutive icons.");
  tt->val_offset = (char *) &(pp.sparse_icons_min_distance) - (char *) &pp;
  tt->has_min = TRUE;
  tt->min_val.d = 0;
  tt->single_val.d = 0;
  tt++;
  
  /* Parameter 'before_secs' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("before_secs");
  tt->descr = tdrpStrDup("number of seconds of before track");
  tt->help = tdrpStrDup("Number of seconds of track information to display before the current position.");
  tt->val_offset = (char *) &(pp.before_secs) - (char *) &pp;
  tt->single_val.l = 0;
  tt++;
  
  /* Parameter 'display_before_icon' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("display_before_icon");
  tt->descr = tdrpStrDup("display before icon flag");
  tt->help = tdrpStrDup("If TRUE, the before icon (described in the before_icon parameter) is displayed at each aircraft position before the current position.\n");
  tt->val_offset = (char *) &(pp.display_before_icon) - (char *) &pp;
  tt->single_val.b = pTRUE;
  tt++;
  
  /* Parameter 'before_icon' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("before_icon");
  tt->descr = tdrpStrDup("before icon");
  tt->help = tdrpStrDup("Array defining the icon to be used for the before positions.  The icon is a bit-mapped square icon.  You put 1's in the positions of the icon where the bit should be displayed, and 0's in the positions that are not a part of the icon.  You may want to look at an example parameter file to see how this is done.");
  tt->val_offset = (char *) &(pp.before_icon.val) - (char *) &pp;
  tt->len_offset = (char *) &(pp.before_icon.len) - (char *) &pp;
  tt->array_offset = (char *) &(pp._before_icon) - (char *) &pp;
  tt->array_n_offset = (char *) &(pp.before_icon_n) - (char *) &pp;
  tt->is_array = TRUE;
  tt->array_len_fixed = FALSE;
  tt->array_elem_size = sizeof(long);
  tt->array_n = 1;
  tt->array_vals = (tdrpVal_t *)
      tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
    tt->array_vals[0].l = 0;
  tt++;
  
  /* Parameter 'before_icon_color' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("before_icon_color");
  tt->descr = tdrpStrDup("before icon color");
  tt->help = tdrpStrDup("Name of X color to be used when rendering the before icon(s).");
  tt->val_offset = (char *) &(pp.before_icon_color) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("yellow");
  tt++;
  
  /* Parameter 'display_before_polyline' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("display_before_polyline");
  tt->descr = tdrpStrDup("display before polyline flag");
  tt->help = tdrpStrDup("If TRUE, the before positions will be connected with a polyline.");
  tt->val_offset = (char *) &(pp.display_before_polyline) - (char *) &pp;
  tt->single_val.b = pFALSE;
  tt++;
  
  /* Parameter 'before_polyline_color' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("before_polyline_color");
  tt->descr = tdrpStrDup("before polyline color");
  tt->help = tdrpStrDup("Name of X color to be used when rendering the before polyline.");
  tt->val_offset = (char *) &(pp.before_polyline_color) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("yellow");
  tt++;
  
  /* Parameter 'display_current_icon' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("display_current_icon");
  tt->descr = tdrpStrDup("display current icon flag");
  tt->help = tdrpStrDup("If TRUE, the current icon (described in the current_icon parameter) is displayed at the current position.\n");
  tt->val_offset = (char *) &(pp.display_current_icon) - (char *) &pp;
  tt->single_val.b = pTRUE;
  tt++;
  
  /* Parameter 'current_icon' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("current_icon");
  tt->descr = tdrpStrDup("current icon");
  tt->help = tdrpStrDup("Array defining the icon to be used for the current position.  The icon is a bit-mapped square icon.  You put 1's in the positions of the icon where the bit should be displayed, and 0's in the positions that are not a part of the icon.  You may want to look at an example parameter file to see how this is done.");
  tt->val_offset = (char *) &(pp.current_icon.val) - (char *) &pp;
  tt->len_offset = (char *) &(pp.current_icon.len) - (char *) &pp;
  tt->array_offset = (char *) &(pp._current_icon) - (char *) &pp;
  tt->array_n_offset = (char *) &(pp.current_icon_n) - (char *) &pp;
  tt->is_array = TRUE;
  tt->array_len_fixed = FALSE;
  tt->array_elem_size = sizeof(long);
  tt->array_n = 1;
  tt->array_vals = (tdrpVal_t *)
      tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
    tt->array_vals[0].l = 0;
  tt++;
  
  /* Parameter 'current_icon_color' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("current_icon_color");
  tt->descr = tdrpStrDup("current icon color");
  tt->help = tdrpStrDup("Name of X color to be used when rendering the current icon.");
  tt->val_offset = (char *) &(pp.current_icon_color) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("yellow");
  tt++;
  
  /* Parameter 'display_label' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("display_label");
  tt->descr = tdrpStrDup("display label flag");
  tt->help = tdrpStrDup("If TRUE, the callsign of the aircraft will be displayed by the current position icon (or where the current position icon would be if it isn't being displayed.");
  tt->val_offset = (char *) &(pp.display_label) - (char *) &pp;
  tt->single_val.b = pFALSE;
  tt++;
  
  /* Parameter 'label_color' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("label_color");
  tt->descr = tdrpStrDup("label color");
  tt->help = tdrpStrDup("Name of the X color to be used when rendering the aircraft label.");
  tt->val_offset = (char *) &(pp.label_color) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("yellow");
  tt++;
  
  /* Parameter 'label_font' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("label_font");
  tt->descr = tdrpStrDup("label font");
  tt->help = tdrpStrDup("Suggested X font to use for rendering label.");
  tt->val_offset = (char *) &(pp.label_font) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("8x13");
  tt++;
  
  /* Parameter 'label_horiz_align' */
  /* ctype is 'ac_spdb2symprod_label_horiz_align_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = ENUM_TYPE;
  tt->param_name = tdrpStrDup("label_horiz_align");
  tt->descr = tdrpStrDup("label horizontal alignment");
  tt->help = tdrpStrDup("Desired horizontal alignment for the label.");
  tt->val_offset = (char *) &(pp.label_horiz_align) - (char *) &pp;
  tt->enum_def.name = tdrpStrDup("label_horiz_align_t");
  tt->enum_def.nfields = 3;
  tt->enum_def.fields = (enum_field_t *)
      tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
    tt->enum_def.fields[0].name = tdrpStrDup("HORIZ_ALIGN_LEFT");
    tt->enum_def.fields[0].val = HORIZ_ALIGN_LEFT;
    tt->enum_def.fields[1].name = tdrpStrDup("HORIZ_ALIGN_CENTER");
    tt->enum_def.fields[1].val = HORIZ_ALIGN_CENTER;
    tt->enum_def.fields[2].name = tdrpStrDup("HORIZ_ALIGN_RIGHT");
    tt->enum_def.fields[2].val = HORIZ_ALIGN_RIGHT;
  tt->single_val.e = HORIZ_ALIGN_CENTER;
  tt++;
  
  /* Parameter 'label_vert_align' */
  /* ctype is 'ac_spdb2symprod_label_vert_align_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = ENUM_TYPE;
  tt->param_name = tdrpStrDup("label_vert_align");
  tt->descr = tdrpStrDup("label vertical alignment");
  tt->help = tdrpStrDup("Desired vertical alignment for the label.");
  tt->val_offset = (char *) &(pp.label_vert_align) - (char *) &pp;
  tt->enum_def.name = tdrpStrDup("label_vert_align_t");
  tt->enum_def.nfields = 3;
  tt->enum_def.fields = (enum_field_t *)
      tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
    tt->enum_def.fields[0].name = tdrpStrDup("VERT_ALIGN_TOP");
    tt->enum_def.fields[0].val = VERT_ALIGN_TOP;
    tt->enum_def.fields[1].name = tdrpStrDup("VERT_ALIGN_CENTER");
    tt->enum_def.fields[1].val = VERT_ALIGN_CENTER;
    tt->enum_def.fields[2].name = tdrpStrDup("VERT_ALIGN_BOTTOM");
    tt->enum_def.fields[2].val = VERT_ALIGN_BOTTOM;
  tt->single_val.e = VERT_ALIGN_CENTER;
  tt++;
  
  /* Parameter 'label_offset' */
  /* ctype is 'ac_spdb2symprod_label_offset_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRUCT_TYPE;
  tt->param_name = tdrpStrDup("label_offset");
  tt->descr = tdrpStrDup("label offset");
  tt->help = tdrpStrDup("Pixel offsets for label rendering.  The label is rendered at the given offsets from the current position location.  A positive x_offset moves the label to the right; a positive y_offset moves the label up.");
  tt->val_offset = (char *) &(pp.label_offset) - (char *) &pp;
  tt->struct_def.name = tdrpStrDup("label_offset_t");
  tt->struct_def.nfields = 2;
  tt->struct_def.fields = (struct_field_t *)
      tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
    tt->struct_def.fields[0].ftype = tdrpStrDup("long");
    tt->struct_def.fields[0].fname = tdrpStrDup("x_offset");
    tt->struct_def.fields[0].ptype = LONG_TYPE;
    tt->struct_def.fields[0].rel_offset = 
      (char *) &(pp.label_offset.x_offset) - (char *) &(pp.label_offset);
    tt->struct_def.fields[1].ftype = tdrpStrDup("long");
    tt->struct_def.fields[1].fname = tdrpStrDup("y_offset");
    tt->struct_def.fields[1].ptype = LONG_TYPE;
    tt->struct_def.fields[1].rel_offset = 
      (char *) &(pp.label_offset.y_offset) - (char *) &(pp.label_offset);
  tt->n_struct_vals = 2;
  tt->struct_vals = (tdrpVal_t *)
      tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt->struct_vals[0].l = 0;
    tt->struct_vals[1].l = 0;
  tt++;
  
  /* Parameter 'after_secs' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("after_secs");
  tt->descr = tdrpStrDup("number of seconds of after track");
  tt->help = tdrpStrDup("Number of seconds of track information to display after the current position.  Of course, when displaying realtime aircraft data, there will be no track information after the current position, so this value will be ignored.");
  tt->val_offset = (char *) &(pp.after_secs) - (char *) &pp;
  tt->single_val.l = 0;
  tt++;
  
  /* Parameter 'display_after_icon' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("display_after_icon");
  tt->descr = tdrpStrDup("display after icon flag");
  tt->help = tdrpStrDup("If TRUE, the after icon (described in the after_icon parameter) is displayed at each aircraft position after the current position.\n");
  tt->val_offset = (char *) &(pp.display_after_icon) - (char *) &pp;
  tt->single_val.b = pTRUE;
  tt++;
  
  /* Parameter 'after_icon' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("after_icon");
  tt->descr = tdrpStrDup("after icon");
  tt->help = tdrpStrDup("Array defining the icon to be used for the after positions.  The icon is a bit-mapped square icon.  You put 1's in the positions of the icon where the bit should be displayed, and 0's in the positions that are not a part of the icon.  You may want to look at an example parameter file to see how this is done.");
  tt->val_offset = (char *) &(pp.after_icon.val) - (char *) &pp;
  tt->len_offset = (char *) &(pp.after_icon.len) - (char *) &pp;
  tt->array_offset = (char *) &(pp._after_icon) - (char *) &pp;
  tt->array_n_offset = (char *) &(pp.after_icon_n) - (char *) &pp;
  tt->is_array = TRUE;
  tt->array_len_fixed = FALSE;
  tt->array_elem_size = sizeof(long);
  tt->array_n = 1;
  tt->array_vals = (tdrpVal_t *)
      tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
    tt->array_vals[0].l = 0;
  tt++;
  
  /* Parameter 'after_icon_color' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("after_icon_color");
  tt->descr = tdrpStrDup("after icon color");
  tt->help = tdrpStrDup("Name of X color to be used when rendering the after icon(s).");
  tt->val_offset = (char *) &(pp.after_icon_color) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("yellow");
  tt++;
  
  /* Parameter 'display_after_polyline' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("display_after_polyline");
  tt->descr = tdrpStrDup("display after polyline flag");
  tt->help = tdrpStrDup("If TRUE, the after positions will be connected with a polyline.");
  tt->val_offset = (char *) &(pp.display_after_polyline) - (char *) &pp;
  tt->single_val.b = pFALSE;
  tt++;
  
  /* Parameter 'after_polyline_color' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("after_polyline_color");
  tt->descr = tdrpStrDup("after polyline color");
  tt->help = tdrpStrDup("Name of X color to be used when rendering the after polyline.");
  tt->val_offset = (char *) &(pp.after_polyline_color) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("yellow");
  tt++;
  
  /* Parameter 'color_by_altitude' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("color_by_altitude");
  tt->descr = tdrpStrDup("Option to set color based on altitude field.");
  tt->help = tdrpStrDup("If TRUE, this option overrides the other color options and sets the color based on the aircraft altitude. The colors used are set in the altitude_color array.");
  tt->val_offset = (char *) &(pp.color_by_altitude) - (char *) &pp;
  tt->single_val.b = pFALSE;
  tt++;
  
  /* Parameter 'altitude_color_scale' */
  /* ctype is 'ac_spdb2symprod_altitude_color_scale' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRUCT_TYPE;
  tt->param_name = tdrpStrDup("altitude_color_scale");
  tt->descr = tdrpStrDup("Color scale for altitude data - only used if color_by_altitude is TRUE");
  tt->help = tdrpStrDup("This is an array of entries, each of which has min_val, max_val and color for each altitude range selected. Altitude units are meters. If the true altitude is outside this range the color will default to the color which would have been used if color_by_altitude were FALSE.");
  tt->val_offset = (char *) &(pp.altitude_color_scale.val) - (char *) &pp;
  tt->len_offset = (char *) &(pp.altitude_color_scale.len) - (char *) &pp;
  tt->array_offset = (char *) &(pp._altitude_color_scale) - (char *) &pp;
  tt->array_n_offset = (char *) &(pp.altitude_color_scale_n) - (char *) &pp;
  tt->is_array = TRUE;
  tt->array_len_fixed = FALSE;
  tt->array_elem_size = sizeof(ac_spdb2symprod_altitude_color_scale);
  tt->array_n = 1;
  tt->struct_def.name = tdrpStrDup("altitude_color_scale");
  tt->struct_def.nfields = 3;
  tt->struct_def.fields = (struct_field_t *)
      tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
    tt->struct_def.fields[0].ftype = tdrpStrDup("double");
    tt->struct_def.fields[0].fname = tdrpStrDup("min_val");
    tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
    tt->struct_def.fields[0].rel_offset = 
      (char *) &(pp.altitude_color_scale.val->min_val) - (char *) pp.altitude_color_scale.val;
    tt->struct_def.fields[1].ftype = tdrpStrDup("double");
    tt->struct_def.fields[1].fname = tdrpStrDup("max_val");
    tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
    tt->struct_def.fields[1].rel_offset = 
      (char *) &(pp.altitude_color_scale.val->max_val) - (char *) pp.altitude_color_scale.val;
    tt->struct_def.fields[2].ftype = tdrpStrDup("char*");
    tt->struct_def.fields[2].fname = tdrpStrDup("color");
    tt->struct_def.fields[2].ptype = STRING_TYPE;
    tt->struct_def.fields[2].rel_offset = 
      (char *) &(pp.altitude_color_scale.val->color) - (char *) pp.altitude_color_scale.val;
  tt->n_struct_vals = 3;
  tt->struct_vals = (tdrpVal_t *)
      tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt->struct_vals[0].d = 0;
    tt->struct_vals[1].d = 0;
    tt->struct_vals[2].s = tdrpStrDup("not_set");
  tt++;
  
  /* Parameter 'plot_altitude_text' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("plot_altitude_text");
  tt->descr = tdrpStrDup("Option to plot altitude as text instead of icon.");
  tt->help = tdrpStrDup("If TRUE, the altitude value is plotted at the aircraft position instead of the icon. The altitude_font is used.");
  tt->val_offset = (char *) &(pp.plot_altitude_text) - (char *) &pp;
  tt->single_val.b = pFALSE;
  tt++;
  
  /* Parameter 'altitude_font' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("altitude_font");
  tt->descr = tdrpStrDup("altitude font");
  tt->help = tdrpStrDup("Suggested X font to use for rendering altitude.");
  tt->val_offset = (char *) &(pp.altitude_font) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("6x10");
  tt++;
  
  /* trailing entry has param_name set to NULL */
  
  tt->param_name = NULL;
  
  return (Table);

}
