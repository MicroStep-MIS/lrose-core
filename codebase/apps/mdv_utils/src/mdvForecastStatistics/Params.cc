// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* 
// ** Copyright UCAR (c) 1990 - 2016                                         
// ** University Corporation for Atmospheric Research (UCAR)                 
// ** National Center for Atmospheric Research (NCAR)                        
// ** Boulder, Colorado, USA                                                 
// ** BSD licence applies - redistribution and use in source and binary      
// ** forms, with or without modification, are permitted provided that       
// ** the following conditions are met:                                      
// ** 1) If the software is modified to produce derivative works,            
// ** such modified software should be clearly marked, so as not             
// ** to confuse it with the version available from UCAR.                    
// ** 2) Redistributions of source code must retain the above copyright      
// ** notice, this list of conditions and the following disclaimer.          
// ** 3) Redistributions in binary form must reproduce the above copyright   
// ** notice, this list of conditions and the following disclaimer in the    
// ** documentation and/or other materials provided with the distribution.   
// ** 4) Neither the name of UCAR nor the names of its contributors,         
// ** if any, may be used to endorse or promote products derived from        
// ** this software without specific prior written permission.               
// ** DISCLAIMER: THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS  
// ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      
// ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    
// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* 
////////////////////////////////////////////
// Params.cc
//
// TDRP C++ code file for class 'Params'.
//
// Code for program mdvForecastStatistics
//
// This file has been automatically
// generated by TDRP, do not modify.
//
/////////////////////////////////////////////

/**
 *
 * @file Params.cc
 *
 * @class Params
 *
 * This class is automatically generated by the Table
 * Driven Runtime Parameters (TDRP) system
 *
 * @note Source is automatically generated from
 *       paramdef file at compile time, do not modify
 *       since modifications will be overwritten.
 *
 *
 * @author Automatically generated
 *
 */
using namespace std;

#include "Params.hh"
#include <cstring>

  ////////////////////////////////////////////
  // Default constructor
  //

  Params::Params()

  {

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // initialize table

    _init();

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Copy constructor
  //

  Params::Params(const Params& source)

  {

    // sync the source object

    source.sync();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // copy table

    tdrpCopyTable((TDRPtable *) source._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Destructor
  //

  Params::~Params()

  {

    // free up

    freeAll();

  }

  ////////////////////////////////////////////
  // Assignment
  //

  void Params::operator=(const Params& other)

  {

    // sync the other object

    other.sync();

    // free up any existing memory

    freeAll();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // copy table

    tdrpCopyTable((TDRPtable *) other._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = other._exitDeferred;

  }

  ////////////////////////////////////////////
  // loadFromArgs()
  //
  // Loads up TDRP using the command line args.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   char **params_path_p:
  //     If this is non-NULL, it is set to point to the path
  //     of the params file used.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromArgs(int argc, char **argv,
                           char **override_list,
                           char **params_path_p,
                           bool defer_exit)
  {
    int exit_deferred;
    if (_tdrpLoadFromArgs(argc, argv,
                          _table, &_start_,
                          override_list, params_path_p,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadApplyArgs()
  //
  // Loads up TDRP using the params path passed in, and applies
  // the command line args for printing and checking.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   const char *param_file_path: the parameter file to be read in
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadApplyArgs(const char *params_path,
                            int argc, char **argv,
                            char **override_list,
                            bool defer_exit)
  {
    int exit_deferred;
    if (tdrpLoadApplyArgs(params_path, argc, argv,
                          _table, &_start_,
                          override_list,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  //

  bool Params::isArgValid(const char *arg)
  {
    return (tdrpIsArgValid(arg));
  }

  ////////////////////////////////////////////
  // load()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to load
  // up more than one class for a single application. It is a
  // lower-level routine than loadFromArgs, and hence more
  // flexible, but the programmer must do more work.
  //
  //   const char *param_file_path: the parameter file to be read in.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::load(const char *param_file_path,
                   char **override_list,
                   int expand_env, int debug)
  {
    if (tdrpLoad(param_file_path,
                 _table, &_start_,
                 override_list,
                 expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadFromBuf()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to
  // load up more than one module for a single application,
  // using buffers which have been read from a specified source.
  //
  //   const char *param_source_str: a string which describes the
  //     source of the parameter information. It is used for
  //     error reporting only.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   const char *inbuf: the input buffer
  //
  //   int inlen: length of the input buffer
  //
  //   int start_line_num: the line number in the source which
  //     corresponds to the start of the buffer.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromBuf(const char *param_source_str,
                          char **override_list,
                          const char *inbuf, int inlen,
                          int start_line_num,
                          int expand_env, int debug)
  {
    if (tdrpLoadFromBuf(param_source_str,
                        _table, &_start_,
                        override_list,
                        inbuf, inlen, start_line_num,
                        expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadDefaults()
  //
  // Loads up default params for a given class.
  //
  // See load() for more detailed info.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadDefaults(int expand_env)
  {
    if (tdrpLoad(NULL,
                 _table, &_start_,
                 NULL, expand_env, FALSE)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // sync()
  //
  // Syncs the user struct data back into the parameter table,
  // in preparation for printing.
  //
  // This function alters the table in a consistent manner.
  // Therefore it can be regarded as const.
  //

  void Params::sync(void) const
  {
    tdrpUser2Table(_table, (char *) &_start_);
  }

  ////////////////////////////////////////////
  // print()
  // 
  // Print params file
  //
  // The modes supported are:
  //
  //   PRINT_SHORT:   main comments only, no help or descriptions
  //                  structs and arrays on a single line
  //   PRINT_NORM:    short + descriptions and help
  //   PRINT_LONG:    norm  + arrays and structs expanded
  //   PRINT_VERBOSE: long  + private params included
  //

  void Params::print(FILE *out, tdrp_print_mode_t mode)
  {
    tdrpPrint(out, _table, _className, mode);
  }

  ////////////////////////////////////////////
  // checkAllSet()
  //
  // Return TRUE if all set, FALSE if not.
  //
  // If out is non-NULL, prints out warning messages for those
  // parameters which are not set.
  //

  int Params::checkAllSet(FILE *out)
  {
    return (tdrpCheckAllSet(out, _table, &_start_));
  }

  //////////////////////////////////////////////////////////////
  // checkIsSet()
  //
  // Return TRUE if parameter is set, FALSE if not.
  //
  //

  int Params::checkIsSet(const char *paramName)
  {
    return (tdrpCheckIsSet(paramName, _table, &_start_));
  }

  ////////////////////////////////////////////
  // freeAll()
  //
  // Frees up all TDRP dynamic memory.
  //

  void Params::freeAll(void)
  {
    tdrpFreeAll(_table, &_start_);
  }

  ////////////////////////////////////////////
  // usage()
  //
  // Prints out usage message for TDRP args as passed
  // in to loadFromArgs().
  //

  void Params::usage(ostream &out)
  {
    out << "TDRP args: [options as below]\n"
        << "   [ -params path ] specify params file path\n"
        << "   [ -check_params] check which params are not set\n"
        << "   [ -print_params [mode]] print parameters\n"
        << "     using following modes, default mode is 'norm'\n"
        << "       short:   main comments only, no help or descr\n"
        << "                structs and arrays on a single line\n"
        << "       norm:    short + descriptions and help\n"
        << "       long:    norm  + arrays and structs expanded\n"
        << "       verbose: long  + private params included\n"
        << "       short_expand:   short with env vars expanded\n"
        << "       norm_expand:    norm with env vars expanded\n"
        << "       long_expand:    long with env vars expanded\n"
        << "       verbose_expand: verbose with env vars expanded\n"
        << "   [ -tdrp_debug] debugging prints for tdrp\n"
        << "   [ -tdrp_usage] print this usage\n";
  }

  ////////////////////////////////////////////
  // arrayRealloc()
  //
  // Realloc 1D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::arrayRealloc(const char *param_name, int new_array_n)
  {
    if (tdrpArrayRealloc(_table, &_start_,
                         param_name, new_array_n)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // array2DRealloc()
  //
  // Realloc 2D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::array2DRealloc(const char *param_name,
                             int new_array_n1,
                             int new_array_n2)
  {
    if (tdrpArray2DRealloc(_table, &_start_, param_name,
                           new_array_n1, new_array_n2)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // _init()
  //
  // Class table initialization function.
  //
  //

  void Params::_init()

  {

    TDRPtable *tt = _table;

    // Parameter 'Comment 0'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 0");
    tt->comment_hdr = tdrpStrDup("This program has a somewhat tortured history.\n\nThe purpose of mdvForecastStatistics is to generate\nstatistics about how susscessful our forecasting is.\nThe input is, fundamentally, two parts - a set of\nforecast MDV grids (ie. what we said would happen)\nand a set of set of truth MDV grids (ie. what actually\nhappened). Typically the forecast field will be an\ninterest field or probablility field, depending on the\nnature of the forecast, and the truth field will be\nsome objective measurement such as a radar grid. Both\nfields are then thresholded into, essentially, binary\nstorm/no storm grids, and statistics are generated based\non these binary fields. The user also has the option of\nsaving out grids that what happened where, ie. where the\nprogram decided that the forecast was correct, and where it\nwas not.\n\nThe program has gone through several iterations. Initially,\nthe program VerifyGrid was ussed for this work. VerifyGrid was\nbased on the earlier mdv library (as opposed to Mdv).\nWhen a significant bug was found in verifyGrid the decision\nwas made to develop a new program, Validator, that was based\non Mdv (the bug in verifyGrid was also fixed).\n\nUnfortunately, the Mdv library was still evolving as Validator\nwas developed, with the result that Validator did not take full\nadvantage of the Mdv library. Further, at the time that\nValidator was being developed, there appeared to be strong\ninterest in validating on a county-by-county basis, and this\nwas coded into the Validator (the program can read map files\nand validate accordingly). This interest largely evaporated.\n\nAs a result, when interest in running with multiple threshold\nvalues developed, the decision was made to develop this program\nrather than modify the Validator.\n\nThe MdvVerify program was also written around this time, but\nits focus is somewhat different as I understand it, and it\ndoes not allow multiple thresholds.\n\nNiles Oien October 2006");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'Comment 1'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 1");
    tt->comment_hdr = tdrpStrDup("The program runs in archive mode only. Realtime mode\ndoes not make much sense, since the program triggers when\na new forecast is ready for validating and the truth will\nnot have eventuated at that time. The time specified on the\ncommand line are, thus, forecast times not truth times.\n\nPseudo-realtime operations can be orchestrated with cron.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'Comment 2'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 2");
    tt->comment_hdr = tdrpStrDup("The program is checked into CVS as\napps/mdv_utils/src/mdvForecastStatistics and examples of\nrunning it, setting up CIDD to display the results etc. are\nchecked in as apps/mdv_utils/src/mdvForecastStatistics/examples");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'thresholds'
    // ctype is '_threshold_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("thresholds");
    tt->descr = tdrpStrDup("Array of truth, forecast thresholds (thresholds are\nexclusive)and relaxation values. The name is used in the output\nfile name, so no spaces.");
    tt->help = tdrpStrDup("Leave the relaxation values set at 0 unless you have\na good understaning of relaxation (relaxation windows are 2N+1)");
    tt->array_offset = (char *) &_thresholds - &_start_;
    tt->array_n_offset = (char *) &thresholds_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(threshold_t);
    tt->array_n = 3;
    tt->struct_def.name = tdrpStrDup("threshold_t");
    tt->struct_def.nfields = 7;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("name");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_thresholds->name - (char *) _thresholds;
      tt->struct_def.fields[1].ftype = tdrpStrDup("double");
      tt->struct_def.fields[1].fname = tdrpStrDup("truth_min");
      tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_thresholds->truth_min - (char *) _thresholds;
      tt->struct_def.fields[2].ftype = tdrpStrDup("double");
      tt->struct_def.fields[2].fname = tdrpStrDup("truth_max");
      tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_thresholds->truth_max - (char *) _thresholds;
      tt->struct_def.fields[3].ftype = tdrpStrDup("double");
      tt->struct_def.fields[3].fname = tdrpStrDup("forecast_min");
      tt->struct_def.fields[3].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_thresholds->forecast_min - (char *) _thresholds;
      tt->struct_def.fields[4].ftype = tdrpStrDup("double");
      tt->struct_def.fields[4].fname = tdrpStrDup("forecast_max");
      tt->struct_def.fields[4].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &_thresholds->forecast_max - (char *) _thresholds;
      tt->struct_def.fields[5].ftype = tdrpStrDup("int");
      tt->struct_def.fields[5].fname = tdrpStrDup("truth_relax");
      tt->struct_def.fields[5].ptype = INT_TYPE;
      tt->struct_def.fields[5].rel_offset = 
        (char *) &_thresholds->truth_relax - (char *) _thresholds;
      tt->struct_def.fields[6].ftype = tdrpStrDup("int");
      tt->struct_def.fields[6].fname = tdrpStrDup("forecast_relax");
      tt->struct_def.fields[6].ptype = INT_TYPE;
      tt->struct_def.fields[6].rel_offset = 
        (char *) &_thresholds->forecast_relax - (char *) _thresholds;
    tt->n_struct_vals = 21;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("light_storms");
      tt->struct_vals[1].d = 30;
      tt->struct_vals[2].d = 1000;
      tt->struct_vals[3].d = 0.7;
      tt->struct_vals[4].d = 1000;
      tt->struct_vals[5].i = 0;
      tt->struct_vals[6].i = 0;
      tt->struct_vals[7].s = tdrpStrDup("moderate_storms");
      tt->struct_vals[8].d = 35;
      tt->struct_vals[9].d = 1000;
      tt->struct_vals[10].d = 0.8;
      tt->struct_vals[11].d = 1000;
      tt->struct_vals[12].i = 0;
      tt->struct_vals[13].i = 0;
      tt->struct_vals[14].s = tdrpStrDup("severe_storms");
      tt->struct_vals[15].d = 40;
      tt->struct_vals[16].d = 1000;
      tt->struct_vals[17].d = 0.9;
      tt->struct_vals[18].d = 1000;
      tt->struct_vals[19].i = 0;
      tt->struct_vals[20].i = 0;
    tt++;
    
    // Parameter 'Comment 3'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 3");
    tt->comment_hdr = tdrpStrDup("The specification of the truth and forecast inputs follows.\n\nSome things to note :\n\n * CLUMPING is the process of removing small clumps\n from an input dataset. For instance, if the truth dataset is\n a radar grid and the radar occasionally erroneously has a small\n number of geographically isolated grid points set to a high\n dbZ value, the user may want to require that each grid point\n be connected to (ie adjacent to) a minimum number of other\n grid points.\n\n * A MAP FILE can be used to set some regions of the input\n data to missing data values prior to proceeding with\n the statistics, thereby effectively excluding them from\n the calculation. The format of the map file is as follows :\n\n  OUTSIDE 30 <-- 30 lat/lon points follow. specifying a polygon.\n  40.1  -100.3   Data must be outside of this polygon to\n  40.2  -100.4   be considered valid, ie. all data inside\n  40.3  -100.5   this polygon will be set to missing. The\n  40.4  -100.6   polygon need not be closed in the file since\n  40.5  -100.7   closure is assumed.\n    .       .\n    .       .\n    .       .\n    .       .\n  40.0  -100.2  <----- last of the 30 points.\n  INSIDE 25 <---- Start of the next polygon - similar\n  30.0  -90.0     to the above but here data must be\n  30.1  -90.1     inside the polygon to be valid, ie.\n  30.2  -90.2     data ouside the polygon are marked missing.\n    .       .\n    .       .\n    .       .\n    .       .\n  29.9  -89.9 <---- Last of the 25 points.\n\nThe operations are done in the following order : first,\nclumps are removed, then, any relaxation criteria are\napplied, finally any map mask is applied.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'inputs'
    // ctype is '_input_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("inputs");
    tt->descr = tdrpStrDup("Input specifications for truth, forecast fields.");
    tt->help = tdrpStrDup("Fields have the following significance :\n url - mdvp URL from which to read data.\n fieldName - field to read.\n useMapFile - option to use a map file.\n mapFilename - name of map file, if one is being used.\n doClumping - option to remove small clumps.\n minClumpsize - minimum number of connected points in a clump\n                required to avoid removal if we're doing\n                clumping.\n vertAction - action to take re vertical levels.\n                 VERT_ACTION_NONE means take no action,\n                 VERT_ACTION_SET_LIMITS means set limits\n                 in the vertical according to the vlevelsSpecified,\n                 verticalMin and verticalMax parameters, ie.\n                 truncate in the vertical. VERT_ACTION_COMPOSITE\n                 means do a maximum value composite between the\n                 verticalMin and verticalMax levels.\n vlevelsSpecified - relevant only if vertAction is not NONE.\n                 If TRUE, the parameters verticalMin and\n                 verticalMax are taken to be doubles specifying\n                 the min and max levels. If this\n                 is FALSE the values are taken as integers\n                 specifying the min and max plane numbers.\n verticalMin - see comments for vlevelsSpecified.\n verticalMax - see comments for vlevelsSpecified.\n doGridRemap - option to remap grid.\n projType - Remapped projection type.  PROJ_FLAT,\n            PROJ_LATLON, or PROJ_LAMBERT\n nx - points in X in remapped grid.\n ny - points in Y in remapped grid.\n dx - remapped grid X spacing.\n dy - remapped grid Y spacing.\n trueLambertLat1 - relevant for remapping to Lambert.\n trueLambertLat2 - relevant for remapping to Lambert.\n flatRotation - relevant only for flat earth remapping.\n originLat - latitude of remapped origin.\n originLon - longitude of remapped origin.\n minX - lower left X offset for remapped grid.\n minY - lower left Y offset for remapped grid.\n");
    tt->array_offset = (char *) &_inputs - &_start_;
    tt->array_n_offset = (char *) &inputs_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = TRUE;
    tt->array_elem_size = sizeof(input_t);
    tt->array_n = 2;
    tt->struct_def.name = tdrpStrDup("input_t");
    tt->struct_def.nfields = 23;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("string");
      tt->struct_def.fields[0].fname = tdrpStrDup("url");
      tt->struct_def.fields[0].ptype = STRING_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_inputs->url - (char *) _inputs;
      tt->struct_def.fields[1].ftype = tdrpStrDup("string");
      tt->struct_def.fields[1].fname = tdrpStrDup("fieldName");
      tt->struct_def.fields[1].ptype = STRING_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_inputs->fieldName - (char *) _inputs;
      tt->struct_def.fields[2].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[2].fname = tdrpStrDup("useMapFile");
      tt->struct_def.fields[2].ptype = BOOL_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_inputs->useMapFile - (char *) _inputs;
      tt->struct_def.fields[3].ftype = tdrpStrDup("string");
      tt->struct_def.fields[3].fname = tdrpStrDup("mapFilename");
      tt->struct_def.fields[3].ptype = STRING_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &_inputs->mapFilename - (char *) _inputs;
      tt->struct_def.fields[4].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[4].fname = tdrpStrDup("doClumping");
      tt->struct_def.fields[4].ptype = BOOL_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &_inputs->doClumping - (char *) _inputs;
      tt->struct_def.fields[5].ftype = tdrpStrDup("int");
      tt->struct_def.fields[5].fname = tdrpStrDup("minClumpsize");
      tt->struct_def.fields[5].ptype = INT_TYPE;
      tt->struct_def.fields[5].rel_offset = 
        (char *) &_inputs->minClumpsize - (char *) _inputs;
      tt->struct_def.fields[6].ftype = tdrpStrDup("vertAction_t");
      tt->struct_def.fields[6].fname = tdrpStrDup("vertAction");
      tt->struct_def.fields[6].ptype = ENUM_TYPE;
      tt->struct_def.fields[6].rel_offset = 
        (char *) &_inputs->vertAction - (char *) _inputs;
        tt->struct_def.fields[6].enum_def.name = tdrpStrDup("vertAction_t");
        tt->struct_def.fields[6].enum_def.nfields = 3;
        tt->struct_def.fields[6].enum_def.fields = (enum_field_t *) tdrpMalloc
          (tt->struct_def.fields[6].enum_def.nfields * sizeof(enum_field_t));
        tt->struct_def.fields[6].enum_def.fields[0].name = tdrpStrDup("VERT_ACTION_NONE");
        tt->struct_def.fields[6].enum_def.fields[0].val = VERT_ACTION_NONE;
        tt->struct_def.fields[6].enum_def.fields[1].name = tdrpStrDup("VERT_ACTION_SET_LIMITS");
        tt->struct_def.fields[6].enum_def.fields[1].val = VERT_ACTION_SET_LIMITS;
        tt->struct_def.fields[6].enum_def.fields[2].name = tdrpStrDup("VERT_ACTION_COMPOSITE");
        tt->struct_def.fields[6].enum_def.fields[2].val = VERT_ACTION_COMPOSITE;
      tt->struct_def.fields[7].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[7].fname = tdrpStrDup("vlevelsSpecified");
      tt->struct_def.fields[7].ptype = BOOL_TYPE;
      tt->struct_def.fields[7].rel_offset = 
        (char *) &_inputs->vlevelsSpecified - (char *) _inputs;
      tt->struct_def.fields[8].ftype = tdrpStrDup("double");
      tt->struct_def.fields[8].fname = tdrpStrDup("verticalMin");
      tt->struct_def.fields[8].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[8].rel_offset = 
        (char *) &_inputs->verticalMin - (char *) _inputs;
      tt->struct_def.fields[9].ftype = tdrpStrDup("double");
      tt->struct_def.fields[9].fname = tdrpStrDup("verticalMax");
      tt->struct_def.fields[9].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[9].rel_offset = 
        (char *) &_inputs->verticalMax - (char *) _inputs;
      tt->struct_def.fields[10].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[10].fname = tdrpStrDup("doGridRemap");
      tt->struct_def.fields[10].ptype = BOOL_TYPE;
      tt->struct_def.fields[10].rel_offset = 
        (char *) &_inputs->doGridRemap - (char *) _inputs;
      tt->struct_def.fields[11].ftype = tdrpStrDup("projection_t");
      tt->struct_def.fields[11].fname = tdrpStrDup("projType");
      tt->struct_def.fields[11].ptype = ENUM_TYPE;
      tt->struct_def.fields[11].rel_offset = 
        (char *) &_inputs->projType - (char *) _inputs;
        tt->struct_def.fields[11].enum_def.name = tdrpStrDup("projection_t");
        tt->struct_def.fields[11].enum_def.nfields = 3;
        tt->struct_def.fields[11].enum_def.fields = (enum_field_t *) tdrpMalloc
          (tt->struct_def.fields[11].enum_def.nfields * sizeof(enum_field_t));
        tt->struct_def.fields[11].enum_def.fields[0].name = tdrpStrDup("PROJ_FLAT");
        tt->struct_def.fields[11].enum_def.fields[0].val = PROJ_FLAT;
        tt->struct_def.fields[11].enum_def.fields[1].name = tdrpStrDup("PROJ_LATLON");
        tt->struct_def.fields[11].enum_def.fields[1].val = PROJ_LATLON;
        tt->struct_def.fields[11].enum_def.fields[2].name = tdrpStrDup("PROJ_LAMBERT");
        tt->struct_def.fields[11].enum_def.fields[2].val = PROJ_LAMBERT;
      tt->struct_def.fields[12].ftype = tdrpStrDup("int");
      tt->struct_def.fields[12].fname = tdrpStrDup("nx");
      tt->struct_def.fields[12].ptype = INT_TYPE;
      tt->struct_def.fields[12].rel_offset = 
        (char *) &_inputs->nx - (char *) _inputs;
      tt->struct_def.fields[13].ftype = tdrpStrDup("int");
      tt->struct_def.fields[13].fname = tdrpStrDup("ny");
      tt->struct_def.fields[13].ptype = INT_TYPE;
      tt->struct_def.fields[13].rel_offset = 
        (char *) &_inputs->ny - (char *) _inputs;
      tt->struct_def.fields[14].ftype = tdrpStrDup("double");
      tt->struct_def.fields[14].fname = tdrpStrDup("dx");
      tt->struct_def.fields[14].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[14].rel_offset = 
        (char *) &_inputs->dx - (char *) _inputs;
      tt->struct_def.fields[15].ftype = tdrpStrDup("double");
      tt->struct_def.fields[15].fname = tdrpStrDup("dy");
      tt->struct_def.fields[15].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[15].rel_offset = 
        (char *) &_inputs->dy - (char *) _inputs;
      tt->struct_def.fields[16].ftype = tdrpStrDup("double");
      tt->struct_def.fields[16].fname = tdrpStrDup("trueLambertLat1");
      tt->struct_def.fields[16].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[16].rel_offset = 
        (char *) &_inputs->trueLambertLat1 - (char *) _inputs;
      tt->struct_def.fields[17].ftype = tdrpStrDup("double");
      tt->struct_def.fields[17].fname = tdrpStrDup("trueLambertLat2");
      tt->struct_def.fields[17].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[17].rel_offset = 
        (char *) &_inputs->trueLambertLat2 - (char *) _inputs;
      tt->struct_def.fields[18].ftype = tdrpStrDup("double");
      tt->struct_def.fields[18].fname = tdrpStrDup("flatRotation");
      tt->struct_def.fields[18].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[18].rel_offset = 
        (char *) &_inputs->flatRotation - (char *) _inputs;
      tt->struct_def.fields[19].ftype = tdrpStrDup("double");
      tt->struct_def.fields[19].fname = tdrpStrDup("originLat");
      tt->struct_def.fields[19].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[19].rel_offset = 
        (char *) &_inputs->originLat - (char *) _inputs;
      tt->struct_def.fields[20].ftype = tdrpStrDup("double");
      tt->struct_def.fields[20].fname = tdrpStrDup("originLon");
      tt->struct_def.fields[20].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[20].rel_offset = 
        (char *) &_inputs->originLon - (char *) _inputs;
      tt->struct_def.fields[21].ftype = tdrpStrDup("double");
      tt->struct_def.fields[21].fname = tdrpStrDup("minX");
      tt->struct_def.fields[21].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[21].rel_offset = 
        (char *) &_inputs->minX - (char *) _inputs;
      tt->struct_def.fields[22].ftype = tdrpStrDup("double");
      tt->struct_def.fields[22].fname = tdrpStrDup("minY");
      tt->struct_def.fields[22].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[22].rel_offset = 
        (char *) &_inputs->minY - (char *) _inputs;
    tt->n_struct_vals = 46;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].s = tdrpStrDup("mdvp:://localhost::mdv/truthDir");
      tt->struct_vals[1].s = tdrpStrDup("dbZ");
      tt->struct_vals[2].b = pFALSE;
      tt->struct_vals[3].s = tdrpStrDup("notRelevantHere.validationMap");
      tt->struct_vals[4].b = pFALSE;
      tt->struct_vals[5].i = 75;
      tt->struct_vals[6].e = VERT_ACTION_NONE;
      tt->struct_vals[7].b = pTRUE;
      tt->struct_vals[8].d = 1.5;
      tt->struct_vals[9].d = 10;
      tt->struct_vals[10].b = pFALSE;
      tt->struct_vals[11].e = PROJ_FLAT;
      tt->struct_vals[12].i = 400;
      tt->struct_vals[13].i = 400;
      tt->struct_vals[14].d = 0.5;
      tt->struct_vals[15].d = 0.5;
      tt->struct_vals[16].d = 35;
      tt->struct_vals[17].d = 40;
      tt->struct_vals[18].d = 0;
      tt->struct_vals[19].d = 40;
      tt->struct_vals[20].d = -100;
      tt->struct_vals[21].d = -99.75;
      tt->struct_vals[22].d = -99.75;
      tt->struct_vals[23].s = tdrpStrDup("mdvp:://localhost::mdv/forecastDir");
      tt->struct_vals[24].s = tdrpStrDup("interestField");
      tt->struct_vals[25].b = pFALSE;
      tt->struct_vals[26].s = tdrpStrDup("notRelevantHere.validationMap");
      tt->struct_vals[27].b = pFALSE;
      tt->struct_vals[28].i = 75;
      tt->struct_vals[29].e = VERT_ACTION_COMPOSITE;
      tt->struct_vals[30].b = pTRUE;
      tt->struct_vals[31].d = 1.5;
      tt->struct_vals[32].d = 10;
      tt->struct_vals[33].b = pFALSE;
      tt->struct_vals[34].e = PROJ_FLAT;
      tt->struct_vals[35].i = 400;
      tt->struct_vals[36].i = 400;
      tt->struct_vals[37].d = 0.5;
      tt->struct_vals[38].d = 0.5;
      tt->struct_vals[39].d = 35;
      tt->struct_vals[40].d = 40;
      tt->struct_vals[41].d = 0;
      tt->struct_vals[42].d = 40;
      tt->struct_vals[43].d = -100;
      tt->struct_vals[44].d = -99.75;
      tt->struct_vals[45].d = -99.75;
    tt++;
    
    // Parameter 'debug'
    // ctype is '_debug_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("debug");
    tt->descr = tdrpStrDup("Debug option");
    tt->help = tdrpStrDup("If set, debug messages will be printed with the appropriate level of detail.");
    tt->val_offset = (char *) &debug - &_start_;
    tt->enum_def.name = tdrpStrDup("debug_t");
    tt->enum_def.nfields = 3;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("DEBUG_OFF");
      tt->enum_def.fields[0].val = DEBUG_OFF;
      tt->enum_def.fields[1].name = tdrpStrDup("DEBUG_NORM");
      tt->enum_def.fields[1].val = DEBUG_NORM;
      tt->enum_def.fields[2].name = tdrpStrDup("DEBUG_VERBOSE");
      tt->enum_def.fields[2].val = DEBUG_VERBOSE;
    tt->single_val.e = DEBUG_OFF;
    tt++;
    
    // Parameter 'intermediateUrl'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("intermediateUrl");
    tt->descr = tdrpStrDup("Output URL to which intermediate grids will be written.");
    tt->help = tdrpStrDup("If string is empty, no intermediate grids are written.\nThe values that are written are : \n //\n  // Possible outcomes for thresholding operation.\n  //\n  const static int thresholdedIgnore = 0;\n  const static int thresholdedNoStorm = 1;\n  const static int thresholdedStorm = 2;\n\n  //\n  // Possible outcomes of validation.\n  //\n  const static int validatedIgnore = 0;\n  const static int validatedNonEvent = 1;\n  const static int validatedFalseAlarm = 2;\n  const static int validatedMiss = 3;\n  const static int validatedHit = 4;");
    tt->val_offset = (char *) &intermediateUrl - &_start_;
    tt->single_val.s = tdrpStrDup("");
    tt++;
    
    // Parameter 'outDir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("outDir");
    tt->descr = tdrpStrDup("Output directory in which ASCII statistics files will be written.");
    tt->help = tdrpStrDup("Set as appropriate. If empty, no ASCII ouput is generated. This\nmaynot work if forecast mode is invoked.");
    tt->val_offset = (char *) &outDir - &_start_;
    tt->single_val.s = tdrpStrDup("/Some/Output/Directory");
    tt++;
    
    // Parameter 'outputInterval'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("outputInterval");
    tt->descr = tdrpStrDup("Output interval for statistics files.");
    tt->help = tdrpStrDup("Relevant only if ASCII output is generated.");
    tt->val_offset = (char *) &outputInterval - &_start_;
    tt->single_val.i = 900;
    tt++;
    
    // Parameter 'badTruthValueAction'
    // ctype is '_bad_truth_value_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("badTruthValueAction");
    tt->descr = tdrpStrDup("Determines what to do with bad or missing truth data.");
    tt->help = tdrpStrDup("BAD_TRUTH_VALUE_IS_STORM - treat the grid point as\n having passed the threshold test, ie. it is a storm.\nBAD_TRUTH_VALUE_IS_NOT_STORM - treat the grid point as\n having failed the threshold test, ie. it is not a storm.\nBAD_TRUTH_VALUE_IS_IGNORED - ignore the point, do not include\n it in the calculations. This means that whatever forecast\n value is at the grid point location is also ignored.");
    tt->val_offset = (char *) &badTruthValueAction - &_start_;
    tt->enum_def.name = tdrpStrDup("bad_truth_value_t");
    tt->enum_def.nfields = 3;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("BAD_TRUTH_VALUE_IS_STORM");
      tt->enum_def.fields[0].val = BAD_TRUTH_VALUE_IS_STORM;
      tt->enum_def.fields[1].name = tdrpStrDup("BAD_TRUTH_VALUE_IS_NOT_STORM");
      tt->enum_def.fields[1].val = BAD_TRUTH_VALUE_IS_NOT_STORM;
      tt->enum_def.fields[2].name = tdrpStrDup("BAD_TRUTH_VALUE_IS_IGNORED");
      tt->enum_def.fields[2].val = BAD_TRUTH_VALUE_IS_IGNORED;
    tt->single_val.e = BAD_TRUTH_VALUE_IS_NOT_STORM;
    tt++;
    
    // Parameter 'badForecastValueAction'
    // ctype is '_bad_forecast_value_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("badForecastValueAction");
    tt->descr = tdrpStrDup("Determines what to do with bad or missing forecast data.");
    tt->help = tdrpStrDup("BAD_FORECAST_VALUE_IS_STORM - treat the grid point as\n having passed the threshold test, ie. it is a storm.\nBAD_FORECAST_VALUE_IS_NOT_STORM - treat the grid point as\n having failed the threshold test, ie. it is not a storm.\nBAD_FORECAST_VALUE_IS_IGNORED - ignore the point, do not include\n it in the calculations. This means that whatever truth\n value is at the grid point location is also ignored.");
    tt->val_offset = (char *) &badForecastValueAction - &_start_;
    tt->enum_def.name = tdrpStrDup("bad_forecast_value_t");
    tt->enum_def.nfields = 3;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("BAD_FORECAST_VALUE_IS_STORM");
      tt->enum_def.fields[0].val = BAD_FORECAST_VALUE_IS_STORM;
      tt->enum_def.fields[1].name = tdrpStrDup("BAD_FORECAST_VALUE_IS_NOT_STORM");
      tt->enum_def.fields[1].val = BAD_FORECAST_VALUE_IS_NOT_STORM;
      tt->enum_def.fields[2].name = tdrpStrDup("BAD_FORECAST_VALUE_IS_IGNORED");
      tt->enum_def.fields[2].val = BAD_FORECAST_VALUE_IS_IGNORED;
    tt->single_val.e = BAD_FORECAST_VALUE_IS_IGNORED;
    tt++;
    
    // Parameter 'temporalTolerance'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("temporalTolerance");
    tt->descr = tdrpStrDup("Maximum time difference between truth and forecast, seconds.");
    tt->help = tdrpStrDup("Set as appropriate.");
    tt->val_offset = (char *) &temporalTolerance - &_start_;
    tt->single_val.i = 600;
    tt++;
    
    // Parameter 'forecastMode'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("forecastMode");
    tt->descr = tdrpStrDup("Determines if the input forecast data are in forecast\nmode (filename has generate and lead time) or not.");
    tt->help = tdrpStrDup("If this is set then intermediate grids written out\nwill also be in forecast mode.");
    tt->val_offset = (char *) &forecastMode - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'forecastLeadtime'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("forecastLeadtime");
    tt->descr = tdrpStrDup("Forecast lead time, seconds.");
    tt->help = tdrpStrDup("Ignored if forecastMode is TRUE (the lead time is\ntaken from the forecast data in that case).");
    tt->val_offset = (char *) &forecastLeadtime - &_start_;
    tt->single_val.i = 3600;
    tt++;
    
    // Parameter 'model2Model'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("model2Model");
    tt->descr = tdrpStrDup("Option to compare two model runs by setting the truth\nto one model run and the forecast to another.");
    tt->help = tdrpStrDup("By default, mdvForecastStatistics will read forecast times\nand then read the truth data at the time nearest\nto the valid time of the forecast. It is assumed that the\ntruth data are actual measurements (ie. radar data) stored in MDV\nnon-forecast mode.\n\nBut if model2Model is set to TRUE, then is is assumed that both\nthe forecast and truth data are model data stored in MDV forecast\nmode. If a forecast at a certain gen and valid time exists, then\nit is assumed that truth data at this gen and valid time exists,\nand this is what is read for truth data.\n\nSetting model2Model to TRUE causes forecastMode to be set to TRUE\ninternally.");
    tt->val_offset = (char *) &model2Model - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 4'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 4");
    tt->comment_hdr = tdrpStrDup("The following options were added so that a false origin\ncan be added to the read for the truth or forecast fields\n(or both). Ideally these options would be part of the remapping\noptions presented earlier, however, for historical reasons that\ndid not eventuate and the options are now separate.\n\nThe options are :\n falseOrigin - set to TRUE to set a false origin for\n   this field. FALSE means the other parameters in this\n   structure are ignored.\n latLon - if this is TRUE then x is taken as the longitude\n   and y is taken as the latitude, both in decimal degrees.\n   If this is FALSE then x and y are taken to be the distance\n   in Km between the two origins, ie. x is the false easting\n   and y is the false northing.\n x,y - as discussed above.\n\nThese options only take effect if the grid is being remapped,\nie if doRemap is TRUE.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'truthFalseOrigin'
    // ctype is '_falseOrigin_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("truthFalseOrigin");
    tt->descr = tdrpStrDup("Option to set a false origin for the truth field.");
    tt->help = tdrpStrDup("Default is not to do this and that should be fine for most\ncases.");
    tt->val_offset = (char *) &truthFalseOrigin - &_start_;
    tt->struct_def.name = tdrpStrDup("falseOrigin_t");
    tt->struct_def.nfields = 4;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[0].fname = tdrpStrDup("falseOrigin");
      tt->struct_def.fields[0].ptype = BOOL_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &truthFalseOrigin.falseOrigin - (char *) &truthFalseOrigin;
      tt->struct_def.fields[1].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[1].fname = tdrpStrDup("latLon");
      tt->struct_def.fields[1].ptype = BOOL_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &truthFalseOrigin.latLon - (char *) &truthFalseOrigin;
      tt->struct_def.fields[2].ftype = tdrpStrDup("double");
      tt->struct_def.fields[2].fname = tdrpStrDup("x");
      tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &truthFalseOrigin.x - (char *) &truthFalseOrigin;
      tt->struct_def.fields[3].ftype = tdrpStrDup("double");
      tt->struct_def.fields[3].fname = tdrpStrDup("y");
      tt->struct_def.fields[3].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &truthFalseOrigin.y - (char *) &truthFalseOrigin;
    tt->n_struct_vals = 4;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].b = pFALSE;
      tt->struct_vals[1].b = pFALSE;
      tt->struct_vals[2].d = 0;
      tt->struct_vals[3].d = 0;
    tt++;
    
    // Parameter 'fcstFalseOrigin'
    // ctype is '_falseOrigin_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("fcstFalseOrigin");
    tt->descr = tdrpStrDup("Option to set a false origin for the forecast field.");
    tt->help = tdrpStrDup("Default is not to do this and that should be fine for most\ncases.");
    tt->val_offset = (char *) &fcstFalseOrigin - &_start_;
    tt->struct_def.name = tdrpStrDup("falseOrigin_t");
    tt->struct_def.nfields = 4;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[0].fname = tdrpStrDup("falseOrigin");
      tt->struct_def.fields[0].ptype = BOOL_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &fcstFalseOrigin.falseOrigin - (char *) &fcstFalseOrigin;
      tt->struct_def.fields[1].ftype = tdrpStrDup("boolean");
      tt->struct_def.fields[1].fname = tdrpStrDup("latLon");
      tt->struct_def.fields[1].ptype = BOOL_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &fcstFalseOrigin.latLon - (char *) &fcstFalseOrigin;
      tt->struct_def.fields[2].ftype = tdrpStrDup("double");
      tt->struct_def.fields[2].fname = tdrpStrDup("x");
      tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &fcstFalseOrigin.x - (char *) &fcstFalseOrigin;
      tt->struct_def.fields[3].ftype = tdrpStrDup("double");
      tt->struct_def.fields[3].fname = tdrpStrDup("y");
      tt->struct_def.fields[3].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &fcstFalseOrigin.y - (char *) &fcstFalseOrigin;
    tt->n_struct_vals = 4;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].b = pFALSE;
      tt->struct_vals[1].b = pFALSE;
      tt->struct_vals[2].d = 0;
      tt->struct_vals[3].d = 0;
    tt++;
    
    // Parameter 'useSpecifiedForecastLeadtimes'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("useSpecifiedForecastLeadtimes");
    tt->descr = tdrpStrDup("Option to use only specified forecast lead times.");
    tt->help = tdrpStrDup("Ignored if forecastMode is FALSE (the lead time is\nspecified in that case). If set to TRUE, forecast lead times\nthat are not in the specifiedForecastLeadtimes array\nare skipped.");
    tt->val_offset = (char *) &useSpecifiedForecastLeadtimes - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'specifiedForecastLeadtimes'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("specifiedForecastLeadtimes");
    tt->descr = tdrpStrDup("Forecast lead times, seconds.");
    tt->help = tdrpStrDup("Ignored if forecastMode is FALSE (the lead time is\nspecified in that case).");
    tt->array_offset = (char *) &_specifiedForecastLeadtimes - &_start_;
    tt->array_n_offset = (char *) &specifiedForecastLeadtimes_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(int);
    tt->array_n = 4;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].i = 1800;
      tt->array_vals[1].i = 3600;
      tt->array_vals[2].i = 5400;
      tt->array_vals[3].i = 7200;
    tt++;
    
    // Parameter 'useSpecifiedGentimes'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("useSpecifiedGentimes");
    tt->descr = tdrpStrDup("Option to use only specified generation times.");
    tt->help = tdrpStrDup("Ignored if forecastMode is FALSE (it has no meaining\nin that case). If set to TRUE, generate times\nthat are consistent with the specifiedGentimes parameter\nare skipped.");
    tt->val_offset = (char *) &useSpecifiedGentimes - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'specifiedGenTimes'
    // ctype is '_specifyGenTimes_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("specifiedGenTimes");
    tt->descr = tdrpStrDup("Specification of gen times if useSpecifiedGentimes\nis TRUE. Units are seconds.");
    tt->help = tdrpStrDup("Ignored if forecastMode is FALSE (it has no meaning\nin that case). Specification is as follows - if\nyou have gen times every 5 minutes, and want only to\nprocess every 15 minutes, and your gen times are on the hour\nthen you would set the interval to 900 (15 minutes) and\n the offset to 0, so that the gen times marked by a star\nbelow would be processed :\n17:00:00 *\n17:05:00\n17:10:00\n17:15:00 *\nIf your gen times were not on the hour but were offset by 2 minutes\nthen you would set the offset to 120 (two minutes) so that the\ngen times marked by a star\nbelow would be processed :\n17:02:00 *\n17:07:00\n17:12:00\n17:17:00 *\n");
    tt->val_offset = (char *) &specifiedGenTimes - &_start_;
    tt->struct_def.name = tdrpStrDup("specifyGenTimes_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("int");
      tt->struct_def.fields[0].fname = tdrpStrDup("interval");
      tt->struct_def.fields[0].ptype = INT_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &specifiedGenTimes.interval - (char *) &specifiedGenTimes;
      tt->struct_def.fields[1].ftype = tdrpStrDup("int");
      tt->struct_def.fields[1].fname = tdrpStrDup("offset");
      tt->struct_def.fields[1].ptype = INT_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &specifiedGenTimes.offset - (char *) &specifiedGenTimes;
    tt->n_struct_vals = 2;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].i = 900;
      tt->struct_vals[1].i = 0;
    tt++;
    
    // trailing entry has param_name set to NULL
    
    tt->param_name = NULL;
    
    return;
  
  }
