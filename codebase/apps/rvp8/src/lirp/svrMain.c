/******************************************************************************/
/******************************************************************************/
/* Function Name:
     svrMain.c

   Purpose:
      This is the main function for the server process that runs on the rvp8 
      for the Level I Data Recorder.  It performs two main tasks:  1) it checks
      for and responds to incoming messages from the client, and 2) it collects
      I/Q data from the rvp8 and sends it to the client to record.

   Formal Parameters:
      None.

   Global Variables:
      RequestInProgress - keeps track of state of data request
                            0 => no data request in progress
                            1 => data requested, no data sent yet
                            2 => data requested, data has been sent
      ReadBuffer[20] - generic buffer to hold the newly read incoming message.
                       Once the message type is determined, this buffer will be
                       cast to the appropriate message data structure.
      DataMsgOut - storage for the outgoing data message.
      InfoMsgOut - storage for outgoing error and warning messages.
      CntlMsgIn - pointer to incoming control message.
                       

   Function Calls:
      Routines written as a part of Time Series Record and Playback Server.  
      svrCleanUp - closes socket communications and disconnects from the rvp8
      svrError - builds and sends error messages.  Counts number of errors.
      svrGetData - gets data from rvp8, builds data message, and sends it to
                   the client.
      svrInitialize - attaches to the rvp8, establishes socket communications.
      svrWarning - builds and sends warning messages.

   Change History:
      7/18/03  Darcy Saxion   see svrSetUpSocket

*/
/******************************************************************************/

#include <stdio.h>   /* i/o calls */
#include <stdlib.h>  /* "exit" call */
#include <string.h>  /* "memcpy" */
#include <ctype.h>
#include <unistd.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <time.h>    /*  time related routines */
#include <errno.h>   /*  error related routines */
#include "lirpCommon.h"  /* message structs defined, global msgs declared */
#include "lirpErrors.h"  /* message structs defined, global msgs declared */
#include "rdasubs_lib.h"   /* defines rvp8 timeseries API calles */

/******************************************************************************/
/***********  the following is stuff from tsprClient.h  **********************/
/***********  maybe I need to move this all to tsrpCommon and include ********/
/**********   tsrpCommon.h in sock_io.c */
/*            OR  I need to figure out who needs what and split my include */
/*            files appropriately!!!!   */
#define EXTERN extern

#define MATCH 0
 /* Extra message sometimes used on error */
EXTERN char    ExtraMessage[STD_MSG_SIZE+1]; 
 /* Name of host where server program resides */
EXTERN char    HostName[STD_MSG_SIZE+1];    
 /* May contain message to send to log file */
char    LogMsg[STD_MSG_SIZE+1];     

/******************************************************************************/


/* 
 * Define Macros
 */

#define  STD_MSG_SIZE    80  /* Size of message buffer to print to stdout */
#define  LIRP_PORT     4999  /* Unused port number we will use for */
                             /*    socket connection */
#define  MAX_ATTEMPTS   500  /* Maximum number of times to try to connect */
                             /*    to server */
#define  MAX_CONNECTIONS  2  /* Maximum number of connections to server */
                             /*    allowed   */

/* Array indices in socket descriptor array */

#define  LIST  0        /* Listen socket descriptor */
#define  CNTL  1        /* Connection sd for control and information messages */
#define  DATA  2        /* Connection sd for data messages */

#define  MAX_DESC  3   /* Max number of socket descriptors:       */
                       /*       one listen socket descriptor and  */
                       /*       two connection socket descriptors */

/******************************************************************************/

/* Type Definitions */

typedef struct sockaddr_in sockaddr_t; /* Defined for convenience */

/******************************************************************************/

/* Global Variables */

static char  LogFileName[STD_MSG_SIZE+1] = "";   /* Name of log file */
static char  *ProgramName;   /* Points to name of this program without path */
FILE         *LogFp = NULL;  /* Log file pointer */

int   ErrorCode;    /* May contain error code generated by program */
int   ErrorNum;     /* Global copy of errno */
char  ExtraMessage[STD_MSG_SIZE+1];  /* Extra message sometimes */
                                            /*    used on error */
/*
 * Define GLOBAL Variables *
 */
                    /* constants associated with the RequestInProgress flag */
#define  NO       0  /* No request is in progress */
#define  FIRST    1  /* Collecting the first data message to go to the client */
#define  CONTINUE 2  /* Collecting the remaining data messages unit complete */
int RequestInProgress = NO;  /* global flag - tracks what stage of a */
                             /* data request */
#define INBUF_SIZE 36 
unsigned char ReadBuffer[INBUF_SIZE];    /* global incoming message buffer */
unsigned char DataWriteBuf[MAX_DATAMSG_SIZE]; /* global outgoing data buffer */

struct msgData *DataMsgOut;   /* pointer to data message to fill and send out */
struct msgCntl CntlMsgOut;    /* control message to fill and send out */
struct msgInfo InfoMsgOut;    /* information message to fill and send out */

struct msgCntl *CntlMsgIn;       /* incoming control messge pointer  */
/*  End GLOBAL Definitions */

/*
 * Protype the Functions called *
 */
int svrCleanUp (Rvp8TS * rvp8Att, int * sock_desc ) ; 
int svrInitialize (Rvp8TS ** rvp8Att, int * sock_desc ) ;
int svrGetData (time_t start_time, Rvp8TS * rvp8Att, int cntl_sd, int data_sd);
int svrError (UINT1 error_detail, int cntl_sd);
int svrPrintUsage (char * prog_name);
int svrWarning(UINT1 warn_type, int cntl_sd, UINT4 expSeqNum, UINT4 newSeqNum);  
static char *get_program_name (char *path_name); 
static int  svrGetReady ();
static int  svrSetUpSocket (int *sd, int cnt);

extern int  chk_and_read (int fd, void *buf, long bytes_to_read);
extern int  chk_and_write (int fd, void *buf, long bytes_to_write);

/*  End Prototyping */
int snrPack;					/* Type of packed data:  currently LOWSNRPACK or
										HIGHSNRPACK */
int snrFlag;					/* Boolean:  FALSE for LOWSNRPACK and
													 TRUE for HIGHSNRPACK */


/******************************************************************************/

int main (int argc, char *argv[])
{
   /* initialize local variables */
   Rvp8TS * rvp8Att ;     /* identifier for attach to rvp8 timeseries API*/
   int data_sd;        /* Input socket descriptor */
   int cntl_sd;        /* Outout socket descriptor */
   int error_count, status;
   int read_cnt = 0;
   size_t numbytes;
   int quit_requested = FALSE;  /* flag - stop looking for incoming messages */
   static time_t start_time;
   int   sock_desc[MAX_DESC];          /* Array of socket descriptors */
   char  *fn = "Server Main";

   /* Get program name without path */
   ProgramName = get_program_name (argv[0]);  

   /* if command line options exist (there should be none), then print usage */
   if (argc > 1)
   {
      svrPrintUsage(ProgramName);
      exit (0);
   }

   /* initialize socket communication and attach to rvp8 */
   status = svrInitialize (&rvp8Att, &sock_desc[0]);
   if (status != SUCCESS)
      exit (EXIT_FAILURE);

   cntl_sd = sock_desc[CNTL];  /* local copy of control socket descriptor */
   data_sd = sock_desc[DATA];  /* local copy of data socket descriptor */

   while (quit_requested == FALSE)  /* loop until told to stop */
   {
      /*** Check Control Socket, respond to incoming requests */
      if ( (numbytes = 
               chk_and_read (cntl_sd, ReadBuffer, sizeof (ReadBuffer))) 
                           == FAILURE)
      {
         /* ErrorCode is a global that is set in chk_and_read */
         error_count = svrError (ErrorCode, cntl_sd);
      }
      else if (numbytes == 0)  /* Count must be 0 indicating nothing */
      {                        /*     to read, yet, so continue on */
         /* How do deal with no response on control socket???  if the socket is not ready */
         /* then we go check for data, there is no loop here so checking for CONTIN_MISS  */
         /* does not make sense.  Therefore, do nothing */
         /* if ( ++read_cnt > CONTIN_MISS)  */    /* Not maxed read attempts so skip */
         /* {
            printf (" Reading from Control socket \n");
            printf (" socket not ready for write, failed test  %d\n", read_cnt);
            sprintf (ExtraMessage, "control socket not ready\n"); */
            /* Exceeded max attempts to read from socket */
         /*    return (ERR_MAX_TRY_READ);
         } */
      }
      else if (numbytes > 0)   /* numbytes > 0, then message was read */
      {                        /*         - parse it  */
         read_cnt = 0;  /* reset attempt to read counter */
         if (ReadBuffer[0] != MSG_CNTL)  /* for now, only expecting */
         {                               /*   control messages      */
            error_count = svrError (ERR_INVALID_MSG, cntl_sd);
         }
         else
         {                                /* "cast" read buffer into control */
            CntlMsgIn = (struct msgCntl *)ReadBuffer;     /*  message struct */
            sprintf (LogMsg, "%s:  CntlMsgIn->action = %d \n", 
                                       fn, CntlMsgIn->action);
            DEBUG_MSG(); 
            DEBUGPRT_MSG(); 
            switch (CntlMsgIn->action)
            {
               case CNTL_STOP:
               {
                  sprintf (LogMsg, "Received STOP control message\n", fn);
                  LOG_MSG();
                  PRT_MSG();
                  RequestInProgress = NO;     /* flag to stop collecting data */
                  /* tell the client we're stopping data collection */
                  svrWarning (WRN_DATA_REQ_STOP, cntl_sd, 0, 0);
                  break;
               }  /* end case Control Stop Message */
               case CNTL_QUIT:
               {
                  sprintf (LogMsg, "Received QUIT control message\n", fn);
                  LOG_MSG();
                  PRT_MSG();
                  RequestInProgress = NO;     /* do not collect any more data */
                  /* tell the client we're quitting */
                  svrWarning (WRN_SERVER_QUIT, cntl_sd, 0, 0);
                  svrCleanUp(rvp8Att, sock_desc);
                  quit_requested = TRUE;      /* break out of loop to exit */

                  break;
               }  /* end case Control Quit Message */
               case CNTL_DATA_REQ:
               {
                  sprintf (LogMsg, "Received DATA control message\n", fn);
                  LOG_MSG();
                  PRT_MSG();
                  /* if a data request is in progress then this data request is 
                   * interrupting it and overriding it
                   * send a message warning that previous request is ending */
                  if ((RequestInProgress == CONTINUE) || \
                        (RequestInProgress == FIRST)) 
                  {
                     svrWarning (WRN_START_NEW_REQ, cntl_sd, 0, 0);
                  }
                  RequestInProgress = FIRST;  /* reset the data request */
                  (void) time (&start_time);  /* record time at request start */
                  if (CntlMsgIn->packedData == TRUE)
                  {
                     volatile struct rvp8Global *rvp8GP;
                     rvp8GlobalMap( FALSE, FALSE ) ;
                     rvp8GP = rvp8GetGlobalPointer( ) ;
                     /*printf (" High SNR Packed? = %0x\n", (UINT4)rvp8GP->gparm.istat_i4);*/
                     snrPack = (((UINT4)rvp8GP->gparm.istat_i4 & 0x0010) == 0) ? LOWSNRPACK:HIGHSNRPACK;
                     /*printf (" lirpPulseHdr->packedData = %0x\n", lirpPulseHdr->packedData ) ;*/
                     rvp8GlobalUnmap( ) ;
                     sprintf (LogMsg, "Collecting data in Packed format\n");
                     LOG_MSG();
                     PRT_MSG();
                  }
                  else
                  {
                     sprintf (LogMsg, "Collecting data in Floating Point format\n");
                     LOG_MSG();
                     PRT_MSG();
                  }
                  
                  break;

                  }  /* end case Control Data Request Message */
               default: 
               {
                  error_count = svrError (ERR_INVALID_MSG, cntl_sd);
                  if (error_count >= MAXERROR)
                  {
                     error_count = svrError(ERR_EXCEED_MAXERR, cntl_sd) ;
                     svrCleanUp(rvp8Att, sock_desc);
                     exit (EXIT_FAILURE); /* terminate the server!!! */ 
                     /* or, reset error counter and request in progress ?*/
                  }
               }  /* end default */
            } /* end switch */
         }  /* end else Control Message */
      } /* end if (numbytes > 0) process incoming message */
     
      /* done processing incoming message, now get some data to send back */
      /* sprintf (LogMsg, "Checking for data - RequestInProgress = %d \n",
            RequestInProgress);
      DEBUG_MSG(); 
      DEBUGPRT_MSG();  */
      if ((RequestInProgress == FIRST) || (RequestInProgress == CONTINUE))
      {
         status = svrGetData (start_time, rvp8Att, cntl_sd, data_sd);
         if (status != SUCCESS)
         {
            if (status == DATA_REQ_DONE)
            { 
               svrWarning (DATA_REQ_DONE, cntl_sd, 0, 0);   /* tell client */
               /* clean up and set flag to exit */
            }
            else
            {
               error_count = svrError (status, cntl_sd); 
            }
            svrCleanUp(rvp8Att, sock_desc);
            quit_requested = TRUE;
         }
         /* send this chunk of data */
      }  /* end get next chunk for the data request */
      
   } /* end while loop */

   return 0;      /* exit (thus ending) from the server */
}  /* end main */



/******************************************************************************/
/******************************************************************************/
/* Function Name:
      svrCleanUp

   Purpose:
      This is the function to cleans up before exiting the server process.
      It closes the socket communications and disconnects from the rvp8.

   Formal Parameters:
      rvp8Att - identifier for connection to the rvp8 time series API
      data_sd - socket descriptor that identifies socket for incoming messages
      cntl_sd - socket descriptor that identifies socket for outgoing messages


   Global Variables:
      None.     

   Function Calls:
      rvp8tsRelease - Detaches from the rvp8 time series API.
      Close Socket stuff???
    
*/
/******************************************************************************/
/******************************************************************************/
int svrCleanUp (Rvp8TS * rvp8Att, int *sd )  
{
   int   *pSd;     /* Points to current socket descriptor */
   int   i;

   /* Close all open socket descriptors */
   for (pSd = sd, i = 0; i < MAX_DESC; pSd++, i++)  
   {
      sprintf (LogMsg, "Closing socket descriptor element %d with value %d\n", 
            i, *pSd);
      LOG_MSG();
      PRT_MSG();
      if (*pSd > 0)
      {
         close (*pSd);
      }
   }

   sprintf (LogMsg, "Closed socket descriptors \n");
   LOG_MSG();
   PRT_MSG();

   if (rvp8Att != NULL)  /* this only happens if svrInitialize fails */
   {
      rvp8tsRelease (rvp8Att);
   }
   sprintf (LogMsg, "Released RVP8 \n");
   LOG_MSG();
   PRT_MSG();

   if (LogFp != NULL)               /* Close log file, if open */
   {
      printf ("Closing log file %s\n", LogFileName);
      fclose (LogFp);
   }

   return (SUCCESS);   
   
} /* end svrCleanUp */

/******************************************************************************/
/******************************************************************************/
/* Function Name:
    svrError.c

   Purpose:
     This function builds and sends to the client the Information message 
     that contains error information.  It also keeps count of the number 
     of errors that have occurred.  The server routine checks to see if 
     the number of errors occurred exceeds the maximum allowable errors.

   Formal Parameters:
     None.


   Global Variables:
     

   Function Calls:
     None.
    
*/
/******************************************************************************/
/******************************************************************************/
int svrError (UINT1 err_type, int cntl_sd)  
{
   static int errcnt = 0;  /* since static, only init'd with first call */
   int bc;        /* byte count of bytes written */
   int writecnt = 0;  /* count of attempts to write */
   int done = FALSE;  /* flag to indicate success in writing */
   /* char  *fn = "svrError"; */

   InfoMsgOut.type = MSG_INFO;
   InfoMsgOut.severity = INFO_ERR;
   InfoMsgOut.detail = err_type; 
   errcnt++;

   do
   {
      /* Write Information (Error) message to the control socket */
      if ((bc = chk_and_write (cntl_sd, &InfoMsgOut, sizeof (struct msgInfo))) > 0)
      {
         sprintf (LogMsg, "\nSent Error message,  Error Number = %d \n", err_type);
         LOG_MSG();
         PRT_MSG();
         done = TRUE;
      }
      else if (bc == 0)  /* control socket is not ready to write */ 
      {           
         if ( ++writecnt > CONTIN_MISS)     /* if tried many times then error */
         {
            printf (" Writing Error \n");
            printf (" socket not ready for write, failed test  %d\n", writecnt);
            sprintf (ExtraMessage, "control socket not ready to write\n");
            /* Exceeded max attempts to read from socket */
            return (ERR_MAX_TRY_WRITE);
         }
      }
      else if (bc == FAILURE)         /* Some error occurred */
      {
         return (ErrorCode);  /* ErrorCode set in chk_and_write */
      }
   } while (!done);

   return errcnt;
} /* end svrError */

/******************************************************************************/
/******************************************************************************/
/* Function Name:
    svrGetData.c

   Purpose:
     This is the function that interacts with rvp8 time series API to retrieve
     the time series (I/Q) data.  It first collects all of the I/Q and header 
     information that is available.  Then, it determines if the data is within
     the area of interest specified by the user.  For now the area of interest
     is defined only by time duration.

   Formal Parameters:
     start_time - the time at which the request for data began.  This is input
                  from the calling routine.
     rvp8Att - descriptor for attaching to the rvp8 time series API. 
     cntl_sd - socket descriptor defining the output socket over which data
                 is sent.

   Global Variables:
      CntlMsgIn - Message requestion data collection - contains parameters
                  for data collection
      DataMsgOut - pointer to the structure of outgoing data message.
      DataWriteBuf - unsigned char storage for the outgoing data message.
      RequestInProgress - keeps track of state of data request
                            0 => no data request in progress
                            1 => data requested, no data sent yet
                            2 => data requested, data has been sent

   Function Calls:
      Calls provided by SIGMET rvp8 time series application programmer's 
      interface (API):
      rvp8tsCurrentSeqNum - Returns the sequence number of the pulse currently 
                            being filled by the rvp8.  A pulse contains a header
                            which describes that pulse and the associated I/Q
                            vectors for each range bin down that pulse. 
      rvp8tsGetPulses - Returns a pointer to all the pulse headers which contain
                        current I/Q data.
      rvp8tsIQDataFLT4 - Returns the I/Q data associated with a given header.
      rvp8tsIQiDataPackCopy - Returns the I/Q data associated with a given header.
      rvp8tsSeqNumOkay - Returns TRUE if the sequence number is okay.
      The following routine was deleted 9/8/03  DSS
      rvp8tsSeqNumExpired - Returns TRUE if the sequence number input has 
                            expired.  A sequence number is Expired if it 
                            is ???HOW OLD???

*/
/******************************************************************************/
/******************************************************************************/

#define  MAX_PULSES  500

int svrGetData (time_t start_time, Rvp8TS *rvp8Att, int cntl_sd, int data_sd)   
{
   /*
    * local variables
    */
   static UINT4 seq_num;    /* next sequence number to get */
                                    /* static => value remains between calls */
   static unsigned long temp_seq_num;    /* temporary for error reporting */
   static unsigned long sent_cnt = 0;    /* temporary for print statements */
   struct pulseData * lirpPulseHdr;       /* pulse header info added for lirp */
   const struct rvp8PulseHdr * pulseHdr;
   const struct rvp8PulseHdr * headers[MAXPULSES]; /* an array of    */
                                                 /* pointers to pulse headers */
                                                 /* MAXPULSES = 10            */
                                             /* !!! same macro in Sigmet code */
   unsigned long total_pulses;  /* number of pulses from rvp8 get IQ returns */
   signed long curr_pulse;    /* counter through pulses return from rvp8      */
   signed long bin_bytes;     /* num bytes TOTAL in pulse worth of I/Q data   */
   signed long rem_bytes;     /* num of bytes in remaining to write to socket */
   time_t current_time;  /* current time to compare with time to collect data */
   int error_count;           /* holds number of errors return from svrError  */
   int write_count;           /* counts the writes to send the data  */
   int attempts = 0;          /* attempts to write when socket not ready  */
   int bc;                    /* bytes written/read to/from socket  */
   int hdrsize;               /* size of header associated with I/Q data */
   int lirpHdrSize;           /* size of header associated w/data message */
   long int dmIndex = 0;      /* data message index */
   unsigned char * bufptr;    /* must cast output structure to unsigned char */
   char  *fn = "svrGetData";
   UINT2 * packedDataPtr;
   unsigned int idTag = DATAID;  /* int - little endian rep of "RVTS"  */
                                 /* unless BENDIAN is defined on compile */
   FLT4 late, threshold;
   UINT4 iBefore;

   /* be sure the data message is cleared out before filling */
   /* since it is an unsigned char array, use the macro for the size */
   memset (DataWriteBuf, 0, MAX_DATAMSG_SIZE);
   hdrsize = sizeof (struct rvp8PulseHdr);
   lirpHdrSize = sizeof (struct pulseData);

   if (RequestInProgress == FIRST) /* if getting first chunk of data,  */
   {                               /*  then must get seq_num from rvp8 */
      seq_num = rvp8tsCurrentSeqNum(rvp8Att) ;
      /* sleep (1); */  /* sleep for one second for data to be filled */
      sprintf (LogMsg,"Beginning data collection-Sequence Number = %ld\n", 
                            seq_num);
      LOG_MSG();
      PRT_MSG();
      /* for feedback messages to screen */
      sent_cnt = 1;
   }

   if ( rvp8tsSeqNumOkay( rvp8Att, seq_num)) /* sequence number is still ok and it is not expired */
   {                            
      /* do I want to use rvp8tsGetPulsesQuick???? */
      /* first get the headers associated with the time series data */

     /* UINT4 iAgeMS =    rvp8tsRealTimeAge( rvp8Att, seq_num) ;
      SINT4 iAfter = rvp8tsNumPulsesFwd( rvp8Att, seq_num) ;
      FLT4 fLateness = rvp8tsLateness(  rvp8Att, seq_num) ;
      iBefore = rvp8tsNumPulsesRev( rvp8Att, seq_num) ;
      
      sprintf (LogMsg, "Seq=%ld, Before=%ld, After=%ld, Age=%ld, Lateness=%7.5f\n",
                     seq_num, iBefore, iAfter, iAgeMS, fLateness);
      LOG_MSG(); */

      DataMsgOut = (struct msgData *) &DataWriteBuf[0];
      total_pulses = rvp8tsGetPulses(rvp8Att, headers, seq_num, MAXPULSES); 
      for (curr_pulse = 0; curr_pulse < total_pulses; curr_pulse++)
      {
         if (curr_pulse == 0) /* on the first pulse - fill in msg type */
         {
            DataMsgOut->type = MSG_DATA;
            DataMsgOut->numPulses = total_pulses;
            dmIndex = DATAINFO;
         }
         pulseHdr = headers[curr_pulse];  /* get the pointer to the header */

         /* get beginning location to write data header information */
         lirpPulseHdr = (struct pulseData *) &DataWriteBuf[dmIndex]; 
         /* idTag is an integer representation of the ascii string "RVTS" */
         lirpPulseHdr->id = idTag;
         lirpPulseHdr->version = VERSION;
         lirpPulseHdr->startGate = 0;     /* this may change in the future */
         dmIndex += (lirpHdrSize - hdrsize);

         memcpy (&DataWriteBuf[dmIndex], (void *)pulseHdr, hdrsize);
         dmIndex += hdrsize;

         if (CntlMsgIn->packedData == TRUE)
         {
            /* calculate number of bytes for IQ data packed */
            bin_bytes = pulseHdr->iNumVecs * 2 * sizeof(UINT2); 
            /* rvp8tsIQDAtaPackCopy fills the buffer for us */
            packedDataPtr = (UINT2 *) &DataWriteBuf[dmIndex];

				snrFlag = ( snrPack == LOWSNRPACK ) ? FALSE : TRUE;

            vecPackIQFromFloatIQ_ ( packedDataPtr, 
                  rvp8tsIQDataFLT4 (rvp8Att, pulseHdr, 0),
                  (2 * pulseHdr->iNumVecs),  snrFlag ) ;
            lirpPulseHdr->packedData = snrPack;
            dmIndex += bin_bytes;
         }
         else /* Packed Data == FALSE, Floating point data */
         {
            /* calculate number of bytes for IQ data floating point */
            bin_bytes = pulseHdr->iNumVecs * 2 * sizeof(float);  
            /* copy the data into DataWriteBuf */
            memcpy (&DataWriteBuf[dmIndex],   
                    (void *)rvp8tsIQDataFLT4(rvp8Att, pulseHdr, 0), 
                     bin_bytes); 
            lirpPulseHdr->packedData = FALSE;
            dmIndex += bin_bytes;
         }
         /* go back and fill in end gate number (not number of gates) */
         /*   and record size */
         lirpPulseHdr->endGate = pulseHdr->iNumVecs - 1; 
         lirpPulseHdr->recordSize += bin_bytes;

         /*sprintf (LogMsg, "pulseHdr->iNumVecs = %ld\n", pulseHdr->iNumVecs);
         DEBUG_MSG(); 
         DEBUGPRT_MSG(); 
         sprintf (LogMsg, "lirpPulseHdr->recordSize = %ld\n", 
                  lirpPulseHdr->recordSize);
         DEBUG_MSG(); 
         DEBUGPRT_MSG(); */
      } /* end for to get IQ data */

      /* fill the total number of bytes in message field */
      /*    leaving out the bytes for data message header*/
      DataMsgOut->totalBytes = dmIndex - DATAINFO;

      /* The second check to see if the sequence number is NOT ok tells us */
      /* that the data was overwritten while fetching it from the rvp8.    */
      /* Therefore, get a new sequence number, discard the current chunk   */
      /* of data, and continue.  On the next pass, the data for this new   */
      /* sequence number will be fetched from the rvp8.                    */
      if (!rvp8tsSeqNumOkay (rvp8Att, seq_num)) 
      {      
                                                    /* data overwritten, */
         error_count = svrError (ERR_DATA_CLOBBERED, cntl_sd); /* don't   */ 
                                                  /* send it, instead   */
                                                  /* send error message */
         if (error_count >= MAXERROR)
         {
            error_count = svrError(ERR_EXCEED_MAXERR, cntl_sd);
            return ERR_EXCEED_MAXERR; /* terminate the server!!! */ 
         }

         temp_seq_num = seq_num;   /* get a new sequence number - continue */
         seq_num = rvp8tsCurrentSeqNum(rvp8Att);
         /* since data was corrupted, don't send it */
         /* send done message? */
         /* set RequestInProgress = NO ? */
      }
      else  /* seq_num still ok meaning the data was not corrupted */
      {
         (void) time (&current_time);

         if ((current_time - start_time) <= CntlMsgIn->duration)
         {
            /* remaining bytes = total bytes to begin */
            /*   dmIndex includes the 12 byte header! */
            rem_bytes = dmIndex; 
            write_count = 0;
            /* loop to write all the data to the socket */
            do   /* while there's data left to write */ 
            {
               bc = chk_and_write(data_sd, &DataWriteBuf, rem_bytes); 
               if (bc == FAILURE)
               {
                  /* put error messages into log buffer then return error */
                  /*  the error will be processed upon returning from this */
                  /*  routine */
                  sprintf(LogMsg, "*** FAIL on Write to data socket \n %s\n", strerror(ErrorNum)); 
                  LOG_MSG();
                  PRT_MSG();
                  sprintf(LogMsg, "EXITING!\n"); 
                  LOG_MSG();
                  PRT_MSG();
                  
                  return (ErrorCode);  /* set in chk_and_write */
                                       /* as is ExtraMessage */
               }
               else if (bc == 0)
               {
                  /* socket is not ready, count the number of attempts */
                  /* before exiting with an error */
                  attempts++;
                  if (attempts > CONTIN_MISS)
                  {
                     printf (" Writing Data  \n");
                     printf (" socket not ready for write, failed test  %d\n", attempts);
                     /* This case happens often, so the error reporting */
                     /* is removed for now.  Since the wait period has  */
                     /* been added in chk_and_write, this does not occur */
                     /* as often.  Perform more testing to see if it    */
                     /* should be added back in.  Perhaps this should be */
                     /* a warning and not an error (which terminates) */
                  
                     error_count = svrError (ERR_MAX_TRY_WRITE, cntl_sd); 
                     if (error_count >= MAXERROR)
                     {
                        /* error_count = svrError(ERR_EXCEED_MAXERR, cntl_sd); */
                        sprintf(LogMsg,"%s:  MAX ERRORS! Socket not ready\n",
                                       fn); 
                        LOG_MSG(); 
                        PRT_MSG(); 
                     }
                  }
               }
               else  /* bc > 0 ...bytes were written! */
               {
                  rem_bytes -= bc;
                  bufptr += bc;
                  write_count++;
                  sent_cnt++;
                  attempts = 0;  /* reset attempts to write to socket cntr */
                  if ((sent_cnt % 100) == 0) printf (".");
               }

            } while (rem_bytes > 0);
               
            seq_num  += total_pulses;  /* next sequence number to get */
            if ((sent_cnt % 1000) == 0) 
            {
               /* always print this to the screen for a warm and fuzzy */
               printf ("\n Next Sequence number = %ld\n", seq_num);
               sprintf (LogMsg, "\n Next Sequence number = %ld\n", seq_num);
               LOG_MSG();
            }
            
            {
               /* UINT4 iAgeMS =    rvp8tsRealTimeAge( rvp8Att, seq_num) ;
               SINT4 iAfter = rvp8tsNumPulsesFwd( rvp8Att, seq_num) ;
               FLT4 fLateness = rvp8tsLateness(  rvp8Att, seq_num) ;
               iBefore = rvp8tsNumPulsesRev( rvp8Att, seq_num) ;
               
               sprintf (LogMsg, "After Write Loop: Seq=%ld, Before=%ld, After=%ld, Age=%ld, Lateness=%7.5f\n",
                              seq_num, iBefore, iAfter, iAgeMS, fLateness);
               LOG_MSG(); */
            }

            /* if the sequence number became "Late" while writing to the   */
            /* socket then get a sequence number now instead of waiting    */
            /* for the sequence number to expire.  This happened when the  */
            /* Linux asynchronous buffering was not tuned properly.  I     */
            /* left it in just in case.                                    */
            threshold = 1.0;
            if (((late = rvp8tsLateness (rvp8Att, seq_num)) >= threshold) &&
                  ((iBefore = rvp8tsNumPulsesRev( rvp8Att, seq_num)) == 1))
            {
               temp_seq_num = seq_num;
               seq_num = rvp8tsCurrentSeqNum(rvp8Att);
               /* send warning to Client to notify the user */
               sprintf (ExtraMessage, "Sequence Number is late\n");
               LOG_MSG();
               PRT_MSG();
               sprintf (LogMsg, "Expired Seq Num = %ld, New Sequence Num = %ld\n", 
                                 temp_seq_num, seq_num);
               LOG_MSG();
               PRT_MSG();
               svrWarning (WRN_EXPIRED_SEQNUM, cntl_sd, temp_seq_num, seq_num);
            } 
               
            /* indicate to continue to get data from rvp8 */
            RequestInProgress = CONTINUE; 
         }  /* end if within requested time limit */
         else   /* time to collect data has expired */
         {
            RequestInProgress = NO;
            return (DATA_REQ_DONE);
         }
      } /* end else second check of seq_num is okay */
   } /* end if seq_num is okay */
   /* If the sequence number is not ok, send a warning message to the     */
   /* client, but continue to record data.  Keep the current sequence     */
   /* number and leave the RequestInProgress flag unchanged.  This means  */
   /* that on the NEXT pass through svrGetData, data will be sent to the  */
   /* client.  On this pass, only the information message will be sent    */
   else if (rvp8tsSeqNumOkay( rvp8Att, seq_num-1)) 
   {
      /* FLT4 late, threshold = 0.5;
      if ((late = rvp8tsLateness (rvp8Att, seq_num)) > threshold)
      {
         sprintf (LogMsg, "First OK: Lateness = %5.3f, New Sequence Num = %ld\n", \
                                             late, seq_num);
         LOG_MSG();
      } */
          
      /* without this sleep command, lirpServer hogs 95% of CPU usage! */
      sig_microSleep(100000); 

      /* do NOT send a warning, this happens WAY too many times */
      /* svrWarning (WRN_SEQNUM_NOTOK, cntl_sd); *//* tell client*/
   } 
   /* If the sequence number has expired, send a warning message to the   */
   /* client, but continue to record data.  Therefore, get a new sequence */
   /* number and leave the RequestInProgress flag unchanged.  This means  */
   /* that on the NEXT pass through svrGetData, data will be sent to the  */
   /* client.  On this pass, only the information message will be sent    */
   else
   {
      temp_seq_num = seq_num;
      seq_num = rvp8tsCurrentSeqNum(rvp8Att);
      /* send warning to Client to notify the user */
      svrWarning (WRN_EXPIRED_SEQNUM, cntl_sd, temp_seq_num, seq_num);
      sprintf (LogMsg, "Expired Seq Num = %ld, New Sequence Num = %ld\n", \
                                             temp_seq_num, seq_num);
      LOG_MSG();
      PRT_MSG();
   }
   return 0;   
}  /* end svrGetData */

/******************************************************************************/
/*  THIS MAY BE MOVED TO SOCK_IO WHICH IS USED BY BOTH SERVER AND CLIENT!!!!! */         
/* Function Name:
 *    get_program_name
 *
 * Purpose:
 *   This function strips the path from the program name and returns a pointer to
 *   just the name.  If there is no path before the name, it returns a pointer to
 *   the string passed as the formal parameter.
 *        
 * Formal Parameters:
 *   char  *path_name Full name of program
 *
 * Global Variables:
 *   none
 *
 * Function Call:
 *     none
 *     */

static char *get_program_name (char *path_name)
{
   char  *name;      /* Points to first character after path */

   if ( (name = strrchr (path_name, '/')) != NULL ) 
   {
      name++;         /* Increment to point past the slash */
   }
   else        /* No forward slash, '/', in name */
   {           /* so simply set name to argv[0]  */
      name = path_name;
   }

   return (name);

}  /* End of function GET_PROGRAM_NAME */


/******************************************************************************/

/* Function Name:
 *    svrGetReady 
 *
 * Purpose:
 *    This function opens file(s) and whatever else is necessary to prepare the
 *    process for running.
 *
 * Formal Parameters:
 *    none
 *
 * Global Variables:
 *    none
 *
 * Function Calls:
 *    none
 *                               */
/******************************************************************************/

static int svrGetReady ()

{

   setbuf (stdout, NULL);          /* Ensure output is flushed (unbufferred) */
   setbuf (stderr, NULL);

   strcpy (ExtraMessage, "");                /* Initialize to null string */

   /* Create log file name */
   strcat ( strcpy (LogFileName, ProgramName), ".log" );  

   if ( (LogFp = fopen (LogFileName, "w")) == NULL ) /* Now, open up log file */
   {
       ErrorNum = errno;
       return (ERR_FILE_OPEN);
   }
   /* Turn off buffering of log file forcing data to file after every fprintf */
   setbuf (LogFp, NULL);

   return (SUCCESS);

}  /* End of function svrGetReady */

/******************************************************************************/
/******************************************************************************/
/* Function Name:
      svrInitialize.c

   Purpose:
      This is the function that initializes the socket connections and 
      connects to the rvp8. 

   Formal Parameters:
      All of the following parameters are defined in this routine.
      rvp8Att - pointer to the rvp8 time series API.
      data_sd - socket descriptor to socket for incoming messages
      cntl_sd - socket descriptor to socket for outgoing messages (or will
                  this be data only?)

   Global Variables:

   Function Calls:
      rvp8tsAttach - Attaches to rvp8 time series API.  Returns a pointer 
                     by which the attachment is referenced.
     socket communications routine???
    
*/
/******************************************************************************/
/******************************************************************************/
int svrInitialize (Rvp8TS ** rvp8Att, int * sock_desc) 
{
   int error_count, ret_val;
   MESSAGE status;   /* rvp8 message type (UINT4) */

   char  *fn = "svrInitialize";
   /* initalize sockets and rvp8 connection */

   if ( (ret_val = svrGetReady ()) != SUCCESS )
   {
      if (ret_val != ERR_FILE_OPEN)    /* Only log_error if log file was */
      {                                /* successfully opened .... duhhh */
         sprintf (LogMsg, "Error returned from svrGetReady!\n", fn);
         LOG_MSG();
         PRT_MSG();
      }

      fprintf (stdout, "\n Could not open error log file!\n");

      /* clean_up (sock_desc); */ /* ??? clean up here ??? */
      return (ret_val);
   }

   if ( (ret_val = svrSetUpSocket (sock_desc, MAX_DESC)) != SUCCESS )
   {
      sprintf (LogMsg, "Could not open socket\n");
      LOG_MSG();
      PRT_MSG();
      /*  svrCleanUp (sock_desc); */
      /* could pose a problem, try to disconnect from rvp8 before connecting */
      /*  therefore set pointer to NULL so that svrCleanUp can test for it */
      *rvp8Att = NULL;
      svrCleanUp(*rvp8Att, sock_desc);
      return (ret_val); 
   }

   /* connect to rvp8 time series API - and eventually rcp8?  */
   if ((*rvp8Att = rvp8tsAttach_ (&status, RVP8TS_UNIT_MAIN, RVP8TS_CLIENT_READER)) == NULL)
   {
      sprintf (LogMsg, 
            "Could not attach to time series API, Error Code: = %ld\n", 
                  status);
      LOG_MSG();
      PRT_MSG();

      error_count = svrError (ERR_RVP8_NOT_RESP, sock_desc[CNTL]); 
      return (ERR_RVP8_NOT_RESP); /* terminate the server!!! */ 
   }
   sprintf (LogMsg, "Attached to RVP8\n");
   LOG_MSG();
   PRT_MSG();

   return (SUCCESS);
} /* end svrInitialize */

/******************************************************************************/
/*   Function Name:
 *      svrPrintUsage
 *
 *   Purpose:
 *     This function displays the usage information.
 *           
 *   Formal Parameters:
 *     char   *prog_name         Program name
 *
 *   Global Variables:
 *     none
 *
 *  Function Calls:
 *     none
 *                                 */
/******************************************************************************/

int svrPrintUsage (char * prog_name)
{
         printf ("\nUsage:  %s \n\n", prog_name);
         printf ("      No command line options exist at this time.\n\n");
         return (0);
   
} /* end svrPrintUsage */

/******************************************************************************/

/* Function Name:
 *    set_up_socket
 *
 * Purpose:
 *    This function creates the listen socket, binds the ip address/port pair
 *    to the socket, and creates the socket connection queue.
 *
 * Formal Parameters:
 *    int   *sd     Array containing three socket descirptors:  one
 *                  listen sd and two connection sd
 *    int   cnt     Number of elements in the socket descriptor array
 *
 * Global Variables:
 *     none
 *
 * Function Calls:
 *     none
 *
 * Change History:
 *    7/18/03  Darcy Saxion   Time Series data from the RVP8 became too stale
 *                            during the time it took to write to the socket.
 *                            Changed max_sock_buf to 16000000 from 8388608/2
 *                            corrected this.  BE SURE TO CHANGE THE OS as well
 *                            with the following commands issued as root:
 *                               echo 16000000 >> /proc/sys/net/core/rmem_max
 *                               echo 16000000 >> /proc/sys/net/core/wmem_max
 * */

static int svrSetUpSocket (int *sd, int cnt)
{
   int   cli_len;       /* Length of client socket address strucgure */
   int   data_sd;       /* socket descriptor for data messages */
   int   listen_sd;     /* Listen socket descriptor */
   int   cntl_sd;       /* Socket descriptor for request messages */
   int   value;         /* To be used to set the REUSEADDR option for socket */
   int   i;
   unsigned int   max_sock_buf = 16000000;      /* Max send buffer */
                                                /*    for socket   */

   struct sockaddr_in   cli_addr;    /* Contains Internet address information */
   struct sockaddr_in   srv_addr;    /*  for the client and server processes  */

   for (i = 0; i < MAX_DESC; i++)      /* Initialize socket descirptors to  */
   {                                   /* -1 to indicate descriptor not set */
       sd[i] = -1;
   }

   if ( (listen_sd = socket (AF_INET, SOCK_STREAM, 0)) < 0 ) /* Create socket */
   {
       return (ERR_SOCK_GEN);
   }

   /* Now let's increase the size of the socket send buffer */
   if ( setsockopt (listen_sd, SOL_SOCKET, SO_SNDBUF, &max_sock_buf,
                          sizeof (max_sock_buf)) < 0 )
   {
      perror ("Error in setting socket send buffer\n");
      return (ERR_SOCK_GEN);
   }

   /* Now let's allow the reuse of the ip address/port pair */

   value = 1;           /* A nonzero value sets the option */
   
   if ( setsockopt (listen_sd, SOL_SOCKET, SO_REUSEADDR, &value,
                          sizeof (value)) < 0 )
   {
      perror ("Error in setting REUSEADDR for listening socket\n");
      return (ERR_SOCK_GEN);
   }

   memset (&srv_addr, 0, sizeof (srv_addr));   /* Clear server address space */

   srv_addr.sin_family = AF_INET;                  /* Internet type socket */
   srv_addr.sin_addr.s_addr = htonl (INADDR_ANY);  /* Use any local interface */
   srv_addr.sin_port = htons (LIRP_PORT);          /* Use our port */

   /*    Associate address/port pair with socket    */
   if ( bind (listen_sd, (struct sockaddr *) &srv_addr, sizeof (srv_addr)) < 0 )
   {
       return (ERR_BIND);
   }

   /* Create connection queue (up to NUM_CONNECTIONS) */
   if ( listen (listen_sd, MAX_CONNECTIONS) < 0 ) 
   {
      return (ERR_LISTEN);
   }

   /* Get length of client socket address structure */
   cli_len = sizeof (cli_addr); 

    do  /* Now wait for first connection from client */
    {
                /*   for client to connect   */
       if ( (cntl_sd = 
              accept (listen_sd, (struct sockaddr *) &cli_addr, &cli_len)) < 0 )
       {       
           return (ERR_ACCEPT);
       }
    } while (cntl_sd < 0);

    do          /* Wait for second connection from client */
    {
       if ( (data_sd = 
             accept (listen_sd, (struct sockaddr *) &cli_addr, &cli_len)) < 0 )
                                                           /*   for client   */
       {                                                   /*   to connect   */
           return (ERR_ACCEPT);
       }
    } while (data_sd < 0);

    /* We got this far, so we have successfully created the listen socket, bound
     *    it to an ipaddress/port pair, created the connection queue, accepted
     *       client connections and obtained valid connection sockets */

     /* Finally, copy the socket descriptors into array */
    sd[LIST] = listen_sd; 
    sd[CNTL] = cntl_sd;
    sd[DATA] = data_sd;

    sprintf (LogMsg, "Server connected to two clients:  ");
    LOG_MSG();
    PRT_MSG();
    sprintf (LogMsg, "listen_sd = %d, cntl_sd = %d, data_sd = %d\n", 
                                             listen_sd, cntl_sd, data_sd);
    LOG_MSG();
    PRT_MSG();

    return (SUCCESS);

}  /* End of function SET_UP_SOCKET */

/******************************************************************************/
/******************************************************************************/
                                                                                      

/******************************************************************************/
/******************************************************************************/
/* Function Name:
    svrWarning.c

   Purpose:
     This function builds and sends to the client the Information message 
     that contains warning information.  

   Formal Parameters:
     warn_type - defines the specific warning.  It is passed to this function
                 from the calling routine.
     cntl_sd - defines the socket connection over which the message is sent.


   Global Variables:
     

   Function Calls:
     socket comm???
    
*/
/******************************************************************************/
/******************************************************************************/
int svrWarning(UINT1 warn_type, int cntl_sd, UINT4 expSeqNum, UINT4 newSeqNum)  
{
   int bc;        /* byte count of bytes written */
   int writecnt = 0; /* count of number of attempts to write to socket */
   int done = FALSE; /* flag to tell when write was successful */
   /* char  *fn = "svrWarning"; */

   InfoMsgOut.type = MSG_INFO;
   InfoMsgOut.severity = INFO_WARN;
   InfoMsgOut.detail = warn_type; 
   InfoMsgOut.expSeqNum = expSeqNum; 
   InfoMsgOut.newSeqNum = newSeqNum; 

   do 
   {
      /* Write Information (Error) message to the control socket */
      if ((bc = chk_and_write (cntl_sd, &InfoMsgOut, sizeof (struct msgInfo))) > 0)
      {
         sprintf (LogMsg, "\nSent Warning Message to Client \n");
         LOG_MSG();
         PRT_MSG();
         done = TRUE;
      }
      else if (bc == 0)  /* control socket is not ready to write */ 
      {           
         if ( ++writecnt > CONTIN_MISS)     /* if tried many times then error */
         {
            printf (" Writing Warning \n");
            printf (" socket not ready for write, failed test  %d\n", writecnt);
            sprintf (ExtraMessage, "control socket not ready to write\n");
            /* Exceeded max attempts to read from socket */
            return (ERR_MAX_TRY_WRITE);
         }
      }
      else if (bc == FAILURE)         /* Some error occurred */
      {
         sprintf (LogMsg, "\nCould not send warning on control socket\n");
         LOG_MSG();
         PRT_MSG();
         return (ErrorCode);  /* ErrorCode set in chk_and_write */
      }
   }
   while (!done);
   
   return (SUCCESS);

} /* end svrWarning */
