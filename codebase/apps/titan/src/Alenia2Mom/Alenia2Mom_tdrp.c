/*******************************************
 * Alenia2Mom_tdrp.c
 *
 * TDRP C code file 'Alenia2Mom' module.
 *
 * Code for program Alenia2Mom
 *
 * This file has been automatically
 * generated by TDRP, do not modify.
 *
 *******************************************/

#include "Alenia2Mom_tdrp.h"
#include <string.h>

/*
 * file scope variables
 */

static TDRPtable Table[45];
static Alenia2Mom_tdrp_struct *Params;
static char *Module = "Alenia2Mom";

/*************************************************************
 * Alenia2Mom_tdrp_load_from_args()
 *
 * Loads up TDRP using the command line args.
 *
 * Check TDRP_usage() for command line actions associated with
 * this function.
 *
 *   argc, argv: command line args
 *
 *   Alenia2Mom_tdrp_struct *params: loads up this struct
 * 
 *   char **override_list: A null-terminated list of overrides
 *     to the parameter file.
 *     An override string has exactly the format of an entry
 *     in the parameter file itself.
 *
 *   char **params_path_p: if non-NULL, this is set to point to
 *                         the path of the params file used.
 *
 *  Returns 0 on success, -1 on failure.
 */

int Alenia2Mom_tdrp_load_from_args(int argc, char **argv,
                         Alenia2Mom_tdrp_struct *params,
                         char **override_list,
                         char **params_path_p)
{
  Params = params;
  Alenia2Mom_tdrp_init(Params);
  if (tdrpLoadFromArgs(argc, argv,
                       Table, Params,
                       override_list, params_path_p)) {
    return (-1);
  } else {
    return (0);
  }
}

/*************************************************************
 * Alenia2Mom_tdrp_load()
 *
 * Loads up TDRP for a given module.
 *
 * This version of load gives the programmer the option to load
 * up more than one module for a single application. It is a
 * lower-level routine than Alenia2Mom_tdrp_load_from_args,
 * and hence more flexible, but the programmer must do more work.
 *
 *   char *param_file_path: the parameter file to be read in.
 *
 *   Alenia2Mom_tdrp_struct *params: loads up this struct
 *
 *   char **override_list: A null-terminated list of overrides
 *     to the parameter file.
 *     An override string has exactly the format of an entry
 *     in the parameter file itself.
 *
 *  expand_env: flag to control environment variable
 *                expansion during tokenization.
 *              If TRUE, environment expansion is set on.
 *              If FALSE, environment expansion is set off.
 *
 *  Returns 0 on success, -1 on failure.
 */

int Alenia2Mom_tdrp_load(char *param_file_path,
               Alenia2Mom_tdrp_struct *params,
               char **override_list,
               int expand_env, int debug)
{
  Params = params;
  Alenia2Mom_tdrp_init(Params);
  if (tdrpLoad(param_file_path, Table,
               params, override_list,
               expand_env, debug)) {
    return (-1);
  } else {
    return (0);
  }
}

/*************************************************************
 * Alenia2Mom_tdrp_load_defaults()
 *
 * Loads up defaults for a given module.
 *
 * See Alenia2Mom_tdrp_load() for more details.
 *
 *  Returns 0 on success, -1 on failure.
 */

int Alenia2Mom_tdrp_load_defaults(Alenia2Mom_tdrp_struct *params,
                        int expand_env)
{
  Params = params;
  Alenia2Mom_tdrp_init(Params);
  if (tdrpLoad(NULL, Table,
               params, NULL,
               expand_env, FALSE)) {
    return (-1);
  } else {
    return (0);
  }
}

/*************************************************************
 * Alenia2Mom_tdrp_sync()
 *
 * Syncs the user struct data back into the parameter table,
 * in preparation for printing.
 */

void Alenia2Mom_tdrp_sync(void)
{
  tdrpUser2Table(Table, Params);
}

/*************************************************************
 * Alenia2Mom_tdrp_print()
 * 
 * Print params file
 *
 * The modes supported are:
 *
 *   PRINT_SHORT:   main comments only, no help or descriptions
 *                  structs and arrays on a single line
 *   PRINT_NORM:    short + descriptions and help
 *   PRINT_LONG:    norm  + arrays and structs expanded
 *   PRINT_VERBOSE: long  + private params included
 */

void Alenia2Mom_tdrp_print(FILE *out, tdrp_print_mode_t mode)
{
  tdrpPrint(out, Table, Module, mode);
}

/*************************************************************
 * Alenia2Mom_tdrp_check_all_set()
 *
 * Return TRUE if all set, FALSE if not.
 *
 * If out is non-NULL, prints out warning messages for those
 * parameters which are not set.
 */

int Alenia2Mom_tdrp_check_all_set(FILE *out)
{
  return (tdrpCheckAllSet(out, Table, Params));
}

/*************************************************************
 * Alenia2Mom_tdrp_check_is_set()
 *
 * Return TRUE if parameter is set, FALSE if not.
 *
 */

int Alenia2Mom_tdrp_check_is_set(char *param_name)
{
  return (tdrpCheckIsSet(param_name, Table, Params));
}

/*************************************************************
 * Alenia2Mom_tdrp_free_all()
 *
 * Frees up all TDRP dynamic memory.
 */

void Alenia2Mom_tdrp_free_all(void)
{
  tdrpFreeAll(Table, Params);
}

/*************************************************************
 * Alenia2Mom_tdrp_array_realloc()
 *
 * Realloc 1D array.
 *
 * If size is increased, the values from the last array entry is
 * copied into the new space.
 *
 * Returns 0 on success, -1 on error.
 */

int Alenia2Mom_tdrp_array_realloc(char *param_name, int new_array_n)
{
  if (tdrpArrayRealloc(Table, Params, param_name, new_array_n)) {
    return (-1);
  } else {
    return (0);
  }
}

/*************************************************************
 * Alenia2Mom_tdrp_array2D_realloc()
 *
 * Realloc 2D array.
 *
 * If size is increased, the values from the last array entry is
 * copied into the new space.
 *
 * Returns 0 on success, -1 on error.
 */

int Alenia2Mom_tdrp_array2D_realloc(char *param_name,
                          int new_array_n1,
                          int new_array_n2)
{
  if (tdrpArray2DRealloc(Table, Params, param_name,
			 new_array_n1, new_array_n2)) {
    return (-1);
  } else {
    return (0);
  }
}

/*************************************************************
 * Alenia2Mom_tdrp_table()
 *
 * Returns pointer to static Table for this module.
 */

TDRPtable *Alenia2Mom_tdrp_table(void)
{
  return (Table);
}

/*************************************************************
 * Alenia2Mom_tdrp_init()
 *
 * Module table initialization function.
 *
 *
 * Returns pointer to static Table for this module.
 */

TDRPtable *Alenia2Mom_tdrp_init(Alenia2Mom_tdrp_struct *params)

{

  TDRPtable *tt = Table;

  Alenia2Mom_tdrp_struct pp; /* for computing byte_offsets */

  /* zero out struct, and store size */

  memset(params, 0, sizeof(Alenia2Mom_tdrp_struct));
  params->struct_size = sizeof(Alenia2Mom_tdrp_struct);

  /* Parameter 'debug' */
  /* ctype is 'Alenia2Mom_debug' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = ENUM_TYPE;
  tt->param_name = tdrpStrDup("debug");
  tt->descr = tdrpStrDup("Debug option");
  tt->help = tdrpStrDup("If set, debug messages will be printed appropriately. Use DEBUG_VERBOSE for all debug messages.");
  tt->val_offset = (char *) &(pp.debug) - (char *) &pp;
  tt->enum_def.name = tdrpStrDup("debug");
  tt->enum_def.nfields = 3;
  tt->enum_def.fields = (enum_field_t *)
      tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
    tt->enum_def.fields[0].name = tdrpStrDup("DEBUG_OFF");
    tt->enum_def.fields[0].val = DEBUG_OFF;
    tt->enum_def.fields[1].name = tdrpStrDup("DEBUG_NORM");
    tt->enum_def.fields[1].val = DEBUG_NORM;
    tt->enum_def.fields[2].name = tdrpStrDup("DEBUG_VERBOSE");
    tt->enum_def.fields[2].val = DEBUG_VERBOSE;
  tt->single_val.e = DEBUG_OFF;
  tt++;
  
  /* Parameter 'instance' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("instance");
  tt->descr = tdrpStrDup("Process instance.");
  tt->help = tdrpStrDup("This is used by procmap utilities for registering the process with procmap.");
  tt->val_offset = (char *) &(pp.instance) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("Test");
  tt++;
  
  /* Parameter 'malloc_debug_level' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("malloc_debug_level");
  tt->descr = tdrpStrDup("Malloc debug level");
  tt->help = tdrpStrDup("0 - none, 1 - corruption checking, 2 - records all malloc blocks and checks, 3 - printout of all mallocs etc.");
  tt->val_offset = (char *) &(pp.malloc_debug_level) - (char *) &pp;
  tt->has_min = TRUE;
  tt->has_max = TRUE;
  tt->min_val.l = 0;
  tt->max_val.l = 3;
  tt->single_val.l = 0;
  tt++;
  
  /* Parameter 'input_device' */
  /* ctype is 'Alenia2Mom_input_device' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = ENUM_TYPE;
  tt->param_name = tdrpStrDup("input_device");
  tt->descr = tdrpStrDup("Input device type.");
  tt->help = tdrpStrDup("For IN_TAPE, set input_tape_name, input_tape wait and short_tape. For IN_UDP, set input_udp_port. For IN_SHMEM, set input_shmem_key.");
  tt->val_offset = (char *) &(pp.input_device) - (char *) &pp;
  tt->enum_def.name = tdrpStrDup("input_device");
  tt->enum_def.nfields = 2;
  tt->enum_def.fields = (enum_field_t *)
      tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
    tt->enum_def.fields[0].name = tdrpStrDup("IN_TAPE");
    tt->enum_def.fields[0].val = IN_TAPE;
    tt->enum_def.fields[1].name = tdrpStrDup("IN_UDP");
    tt->enum_def.fields[1].val = IN_UDP;
  tt->single_val.e = IN_UDP;
  tt++;
  
  /* Parameter 'input_tape_name' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("input_tape_name");
  tt->descr = tdrpStrDup("Tape device name for input");
  tt->help = tdrpStrDup("");
  tt->val_offset = (char *) &(pp.input_tape_name) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("/dev/nrst0");
  tt++;
  
  /* Parameter 'input_tape_wait' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("input_tape_wait");
  tt->descr = tdrpStrDup("Tape input read delay (millisecs).");
  tt->help = tdrpStrDup("Wait between beam reads, to allow the user to simulate varying data rates.");
  tt->val_offset = (char *) &(pp.input_tape_wait) - (char *) &pp;
  tt->single_val.l = 30;
  tt++;
  
  /* Parameter 'input_udp_port' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("input_udp_port");
  tt->descr = tdrpStrDup("Input udp port number.");
  tt->help = tdrpStrDup("");
  tt->val_offset = (char *) &(pp.input_udp_port) - (char *) &pp;
  tt->single_val.l = 3280;
  tt++;
  
  /* Parameter 'output_format' */
  /* ctype is 'Alenia2Mom_output_format' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = ENUM_TYPE;
  tt->param_name = tdrpStrDup("output_format");
  tt->descr = tdrpStrDup("Output format type.");
  tt->help = tdrpStrDup("Output may be in Lincoln format (LL_FORMAT), DsRadar format (DS_FORMAT) or unchanged from input (NATIVE_FORMAT).");
  tt->val_offset = (char *) &(pp.output_format) - (char *) &pp;
  tt->enum_def.name = tdrpStrDup("output_format");
  tt->enum_def.nfields = 3;
  tt->enum_def.fields = (enum_field_t *)
      tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
    tt->enum_def.fields[0].name = tdrpStrDup("LL_FORMAT");
    tt->enum_def.fields[0].val = LL_FORMAT;
    tt->enum_def.fields[1].name = tdrpStrDup("DS_FORMAT");
    tt->enum_def.fields[1].val = DS_FORMAT;
    tt->enum_def.fields[2].name = tdrpStrDup("NATIVE_FORMAT");
    tt->enum_def.fields[2].val = NATIVE_FORMAT;
  tt->single_val.e = LL_FORMAT;
  tt++;
  
  /* Parameter 'write_fmq_output' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("write_fmq_output");
  tt->descr = tdrpStrDup("Option to output FMQ.");
  tt->help = tdrpStrDup("If set to TRUE, FMQ stream is output.");
  tt->val_offset = (char *) &(pp.write_fmq_output) - (char *) &pp;
  tt->single_val.b = pFALSE;
  tt++;
  
  /* Parameter 'write_udp_output' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("write_udp_output");
  tt->descr = tdrpStrDup("Option to output UDP.");
  tt->help = tdrpStrDup("If set to TRUE, UDP stream is output.");
  tt->val_offset = (char *) &(pp.write_udp_output) - (char *) &pp;
  tt->single_val.b = pFALSE;
  tt++;
  
  /* Parameter 'output_udp_port' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("output_udp_port");
  tt->descr = tdrpStrDup("Output udp port number.");
  tt->help = tdrpStrDup("");
  tt->val_offset = (char *) &(pp.output_udp_port) - (char *) &pp;
  tt->single_val.l = 54321;
  tt++;
  
  /* Parameter 'output_udp_address' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("output_udp_address");
  tt->descr = tdrpStrDup("Broadcast address for UDP output.");
  tt->help = tdrpStrDup("");
  tt->val_offset = (char *) &(pp.output_udp_address) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("128.117.197.255");
  tt++;
  
  /* Parameter 'output_fmq_path' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("output_fmq_path");
  tt->descr = tdrpStrDup("Path for output FMQ");
  tt->help = tdrpStrDup("");
  tt->val_offset = (char *) &(pp.output_fmq_path) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("output_fmq");
  tt++;
  
  /* Parameter 'output_fmq_size' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("output_fmq_size");
  tt->descr = tdrpStrDup("Size of output FMQ, in bytes.");
  tt->help = tdrpStrDup("This is the total size of the output FMQ buffer. Some of this buffer will be used for control bytes (12 bytes per message.");
  tt->val_offset = (char *) &(pp.output_fmq_size) - (char *) &pp;
  tt->single_val.l = 2000000;
  tt++;
  
  /* Parameter 'output_fmq_nslots' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("output_fmq_nslots");
  tt->descr = tdrpStrDup("Number of slots in output FMQ.");
  tt->help = tdrpStrDup("The number of slots corresponds to the maximum number of messages which may be written to the buffer before overwrites occur. However, overwrites may occur sooner if the size is not set large enough.");
  tt->val_offset = (char *) &(pp.output_fmq_nslots) - (char *) &pp;
  tt->single_val.l = 3600;
  tt++;
  
  /* Parameter 'output_fmq_compress' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("output_fmq_compress");
  tt->descr = tdrpStrDup("FMQ compression option.");
  tt->help = tdrpStrDup("If TRUE FMQ messages are compressed.");
  tt->val_offset = (char *) &(pp.output_fmq_compress) - (char *) &pp;
  tt->single_val.b = pFALSE;
  tt++;
  
  /* Parameter 'write_archive_fmq' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("write_archive_fmq");
  tt->descr = tdrpStrDup("Option to write an FMQ for archive purposes.");
  tt->help = tdrpStrDup("The archive FMQ is written in native RIDDS format. A separate program reads this FMQ and archives the data to tape.");
  tt->val_offset = (char *) &(pp.write_archive_fmq) - (char *) &pp;
  tt->single_val.b = pFALSE;
  tt++;
  
  /* Parameter 'archive_fmq_path' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("archive_fmq_path");
  tt->descr = tdrpStrDup("Path for archive FMQ");
  tt->help = tdrpStrDup("");
  tt->val_offset = (char *) &(pp.archive_fmq_path) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("archive_fmq");
  tt++;
  
  /* Parameter 'archive_fmq_size' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("archive_fmq_size");
  tt->descr = tdrpStrDup("Size of archive FMQ, in bytes.");
  tt->help = tdrpStrDup("This is the total size of the archive FMQ buffer. Some of this buffer will be used for control bytes (12 bytes per message.");
  tt->val_offset = (char *) &(pp.archive_fmq_size) - (char *) &pp;
  tt->single_val.l = 2000000;
  tt++;
  
  /* Parameter 'archive_fmq_nslots' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("archive_fmq_nslots");
  tt->descr = tdrpStrDup("Number of slots in archive FMQ.");
  tt->help = tdrpStrDup("The number of slots corresponds to the maximum number of messages which may be written to the buffer before overwrites occur. However, overwrites may occur sooner if the size is not set large enough.");
  tt->val_offset = (char *) &(pp.archive_fmq_nslots) - (char *) &pp;
  tt->single_val.l = 3600;
  tt++;
  
  /* Parameter 'archive_fmq_compress' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("archive_fmq_compress");
  tt->descr = tdrpStrDup("Archive FMQ compression option.");
  tt->help = tdrpStrDup("If TRUE FMQ messages are compressed.");
  tt->val_offset = (char *) &(pp.archive_fmq_compress) - (char *) &pp;
  tt->single_val.b = pFALSE;
  tt++;
  
  /* Parameter 'radar_name' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("radar_name");
  tt->descr = tdrpStrDup("Radar name.");
  tt->help = tdrpStrDup("");
  tt->val_offset = (char *) &(pp.radar_name) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("ALENIA");
  tt++;
  
  /* Parameter 'site_name' */
  /* ctype is 'char*' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRING_TYPE;
  tt->param_name = tdrpStrDup("site_name");
  tt->descr = tdrpStrDup("Site name.");
  tt->help = tdrpStrDup("");
  tt->val_offset = (char *) &(pp.site_name) - (char *) &pp;
  tt->single_val.s = tdrpStrDup("Fossalon");
  tt++;
  
  /* Parameter 'radar_location' */
  /* ctype is 'Alenia2Mom_ZR' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = STRUCT_TYPE;
  tt->param_name = tdrpStrDup("radar_location");
  tt->descr = tdrpStrDup("Radar location");
  tt->help = tdrpStrDup("Used if override_radar_location is TRUE. Lat and lon in degrees. Alt in km");
  tt->val_offset = (char *) &(pp.radar_location) - (char *) &pp;
  tt->struct_def.name = tdrpStrDup("ZR");
  tt->struct_def.nfields = 3;
  tt->struct_def.fields = (struct_field_t *)
      tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
    tt->struct_def.fields[0].ftype = tdrpStrDup("double");
    tt->struct_def.fields[0].fname = tdrpStrDup("latitude");
    tt->struct_def.fields[0].ptype = DOUBLE_TYPE;
    tt->struct_def.fields[0].rel_offset = 
      (char *) &(pp.radar_location.latitude) - (char *) &(pp.radar_location);
    tt->struct_def.fields[1].ftype = tdrpStrDup("double");
    tt->struct_def.fields[1].fname = tdrpStrDup("longitude");
    tt->struct_def.fields[1].ptype = DOUBLE_TYPE;
    tt->struct_def.fields[1].rel_offset = 
      (char *) &(pp.radar_location.longitude) - (char *) &(pp.radar_location);
    tt->struct_def.fields[2].ftype = tdrpStrDup("double");
    tt->struct_def.fields[2].fname = tdrpStrDup("altitude");
    tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
    tt->struct_def.fields[2].rel_offset = 
      (char *) &(pp.radar_location.altitude) - (char *) &(pp.radar_location);
  tt->n_struct_vals = 3;
  tt->struct_vals = (tdrpVal_t *)
      tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
    tt->struct_vals[0].d = 0;
    tt->struct_vals[1].d = 0;
    tt->struct_vals[2].d = 0;
  tt++;
  
  /* Parameter 'elev_table' */
  /* ctype is 'double' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = DOUBLE_TYPE;
  tt->param_name = tdrpStrDup("elev_table");
  tt->descr = tdrpStrDup("Elevation angle table");
  tt->help = tdrpStrDup("Array of expected elevation angles (deg).These are used to determine the tilt number for a beam.");
  tt->val_offset = (char *) &(pp.elev_table.val) - (char *) &pp;
  tt->len_offset = (char *) &(pp.elev_table.len) - (char *) &pp;
  tt->array_offset = (char *) &(pp._elev_table) - (char *) &pp;
  tt->array_n_offset = (char *) &(pp.elev_table_n) - (char *) &pp;
  tt->is_array = TRUE;
  tt->array_len_fixed = FALSE;
  tt->array_elem_size = sizeof(double);
  tt->array_n = 1;
  tt->array_vals = (tdrpVal_t *)
      tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
    tt->array_vals[0].d = 8.98847e+307;
  tt++;
  
  /* Parameter 'time_correction' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("time_correction");
  tt->descr = tdrpStrDup("Time correction (secs).");
  tt->help = tdrpStrDup("Data time is adjusted by this number of seconds before output.");
  tt->val_offset = (char *) &(pp.time_correction) - (char *) &pp;
  tt->single_val.l = 0;
  tt++;
  
  /* Parameter 'use_wallclock_time' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("use_wallclock_time");
  tt->descr = tdrpStrDup("Wallclock time override option.");
  tt->help = tdrpStrDup("If set, wallclock time will be used to override data time.");
  tt->val_offset = (char *) &(pp.use_wallclock_time) - (char *) &pp;
  tt->single_val.b = pFALSE;
  tt++;
  
  /* Parameter 'polarization_code' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("polarization_code");
  tt->descr = tdrpStrDup("Radar polarization code.");
  tt->help = tdrpStrDup("1 = hor, 2 = ver, 3 = circ, 4 = ellip. Should be 3; 1 for Jing compatibility.");
  tt->val_offset = (char *) &(pp.polarization_code) - (char *) &pp;
  tt->single_val.l = 3;
  tt++;
  
  /* Parameter 'beam_width' */
  /* ctype is 'double' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = DOUBLE_TYPE;
  tt->param_name = tdrpStrDup("beam_width");
  tt->descr = tdrpStrDup("Beam width");
  tt->help = tdrpStrDup("Radar half-power beam width (deg)");
  tt->val_offset = (char *) &(pp.beam_width) - (char *) &pp;
  tt->has_min = TRUE;
  tt->has_max = TRUE;
  tt->min_val.d = 0.01;
  tt->max_val.d = 45;
  tt->single_val.d = 0.95;
  tt++;
  
  /* Parameter 'wavelength' */
  /* ctype is 'double' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = DOUBLE_TYPE;
  tt->param_name = tdrpStrDup("wavelength");
  tt->descr = tdrpStrDup("Wavelength");
  tt->help = tdrpStrDup("Radar wavelength (cm)");
  tt->val_offset = (char *) &(pp.wavelength) - (char *) &pp;
  tt->has_min = TRUE;
  tt->has_max = TRUE;
  tt->min_val.d = 0.01;
  tt->max_val.d = 1000;
  tt->single_val.d = 10;
  tt++;
  
  /* Parameter 'avg_xmit_pwr' */
  /* ctype is 'double' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = DOUBLE_TYPE;
  tt->param_name = tdrpStrDup("avg_xmit_pwr");
  tt->descr = tdrpStrDup("Average transmitter power (kW)");
  tt->help = tdrpStrDup("");
  tt->val_offset = (char *) &(pp.avg_xmit_pwr) - (char *) &pp;
  tt->single_val.d = 7;
  tt++;
  
  /* Parameter 'noise_dbz_at_100km' */
  /* ctype is 'double' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = DOUBLE_TYPE;
  tt->param_name = tdrpStrDup("noise_dbz_at_100km");
  tt->descr = tdrpStrDup("Receiver noise.");
  tt->help = tdrpStrDup("Receiver noise in units of dBZ at a range of 100km.");
  tt->val_offset = (char *) &(pp.noise_dbz_at_100km) - (char *) &pp;
  tt->single_val.d = -8;
  tt++;
  
  /* Parameter 'output_dbz' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("output_dbz");
  tt->descr = tdrpStrDup("Option to include dBZ in output stream.");
  tt->help = tdrpStrDup("dBZ, if available, will be first field in output data. If this option is set, and no dBZ data is available, missing data will be inserted.");
  tt->val_offset = (char *) &(pp.output_dbz) - (char *) &pp;
  tt->single_val.b = pTRUE;
  tt++;
  
  /* Parameter 'output_zdr' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("output_zdr");
  tt->descr = tdrpStrDup("Option to include Zdr in output stream.");
  tt->help = tdrpStrDup("zdr, if available, will follow dBZ in output data. If this option is set, and no zdr data is available, missing data will be inserted.");
  tt->val_offset = (char *) &(pp.output_zdr) - (char *) &pp;
  tt->single_val.b = pTRUE;
  tt++;
  
  /* Parameter 'output_vel' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("output_vel");
  tt->descr = tdrpStrDup("Option to include vel in output stream.");
  tt->help = tdrpStrDup("vel, if available, will follow Zdr in output data. If this option is set, and no vel data is available, missing data will be inserted.");
  tt->val_offset = (char *) &(pp.output_vel) - (char *) &pp;
  tt->single_val.b = pTRUE;
  tt++;
  
  /* Parameter 'output_width' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("output_width");
  tt->descr = tdrpStrDup("Option to include width in output stream.");
  tt->help = tdrpStrDup("vel, if available, will follow vel in output data. If this option is set, and no width data is available, missing data will be inserted.");
  tt->val_offset = (char *) &(pp.output_width) - (char *) &pp;
  tt->single_val.b = pTRUE;
  tt++;
  
  /* Parameter 'valid_only' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("valid_only");
  tt->descr = tdrpStrDup("Option to output valid data only.");
  tt->help = tdrpStrDup("The radar processor inserts a bit-flag to indicate that the data is invalid because the elevation angle has not stabilized at the target value. If valid_only is set the invalid data is not output.");
  tt->val_offset = (char *) &(pp.valid_only) - (char *) &pp;
  tt->single_val.b = pTRUE;
  tt++;
  
  /* Parameter 'rescale_dbz' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("rescale_dbz");
  tt->descr = tdrpStrDup("Option to rescale dBZ so that the scale and bias are not affected when the radar changes dBZ scale.");
  tt->help = tdrpStrDup("If TRUE, the dBZ scale and bias will be set to 0.4 and -30 respectively. This gives a range of -30 to 101.");
  tt->val_offset = (char *) &(pp.rescale_dbz) - (char *) &pp;
  tt->single_val.b = pTRUE;
  tt++;
  
  /* Parameter 'final_dbz_scale' */
  /* ctype is 'double' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = DOUBLE_TYPE;
  tt->param_name = tdrpStrDup("final_dbz_scale");
  tt->descr = tdrpStrDup("dBZ scale if rescaling is used");
  tt->help = tdrpStrDup("If rescale_dbz is TRUE, the dBZ field will be rescaled using this sscale");
  tt->val_offset = (char *) &(pp.final_dbz_scale) - (char *) &pp;
  tt->single_val.d = 0.4;
  tt++;
  
  /* Parameter 'final_dbz_bias' */
  /* ctype is 'double' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = DOUBLE_TYPE;
  tt->param_name = tdrpStrDup("final_dbz_bias");
  tt->descr = tdrpStrDup("dBZ bias if rescaling is used");
  tt->help = tdrpStrDup("If rescale_dbz is TRUE, the dBZ field will be rescaled using this bias");
  tt->val_offset = (char *) &(pp.final_dbz_bias) - (char *) &pp;
  tt->single_val.d = -30;
  tt++;
  
  /* Parameter 'print_summary' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("print_summary");
  tt->descr = tdrpStrDup("Print summary option.");
  tt->help = tdrpStrDup("If TRUE summaries are printed at given interval.");
  tt->val_offset = (char *) &(pp.print_summary) - (char *) &pp;
  tt->single_val.b = pFALSE;
  tt++;
  
  /* Parameter 'summary_interval' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("summary_interval");
  tt->descr = tdrpStrDup("Interval for summary printouts.");
  tt->help = tdrpStrDup("See print_summary.");
  tt->val_offset = (char *) &(pp.summary_interval) - (char *) &pp;
  tt->single_val.l = 90;
  tt++;
  
  /* Parameter 'print_header' */
  /* ctype is 'tdrp_bool_t' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = BOOL_TYPE;
  tt->param_name = tdrpStrDup("print_header");
  tt->descr = tdrpStrDup("Print header option.");
  tt->help = tdrpStrDup("If TRUE headers are printed at given interval.");
  tt->val_offset = (char *) &(pp.print_header) - (char *) &pp;
  tt->single_val.b = pFALSE;
  tt++;
  
  /* Parameter 'header_interval' */
  /* ctype is 'long' */
  
  memset(tt, 0, sizeof(TDRPtable));
  tt->ptype = LONG_TYPE;
  tt->param_name = tdrpStrDup("header_interval");
  tt->descr = tdrpStrDup("Interval for header printouts.");
  tt->help = tdrpStrDup("See print_header.");
  tt->val_offset = (char *) &(pp.header_interval) - (char *) &pp;
  tt->single_val.l = 360;
  tt++;
  
  /* trailing entry has param_name set to NULL */
  
  tt->param_name = NULL;
  
  return (Table);

}
