// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* 
// ** Copyright UCAR (c) 1990 - 2016                                         
// ** University Corporation for Atmospheric Research (UCAR)                 
// ** National Center for Atmospheric Research (NCAR)                        
// ** Boulder, Colorado, USA                                                 
// ** BSD licence applies - redistribution and use in source and binary      
// ** forms, with or without modification, are permitted provided that       
// ** the following conditions are met:                                      
// ** 1) If the software is modified to produce derivative works,            
// ** such modified software should be clearly marked, so as not             
// ** to confuse it with the version available from UCAR.                    
// ** 2) Redistributions of source code must retain the above copyright      
// ** notice, this list of conditions and the following disclaimer.          
// ** 3) Redistributions in binary form must reproduce the above copyright   
// ** notice, this list of conditions and the following disclaimer in the    
// ** documentation and/or other materials provided with the distribution.   
// ** 4) Neither the name of UCAR nor the names of its contributors,         
// ** if any, may be used to endorse or promote products derived from        
// ** this software without specific prior written permission.               
// ** DISCLAIMER: THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS  
// ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      
// ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    
// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* 
////////////////////////////////////////////
// Params.cc
//
// TDRP C++ code file for class 'Params'.
//
// Code for program StormIdent
//
// This file has been automatically
// generated by TDRP, do not modify.
//
/////////////////////////////////////////////

/**
 *
 * @file Params.cc
 *
 * @class Params
 *
 * This class is automatically generated by the Table
 * Driven Runtime Parameters (TDRP) system
 *
 * @note Source is automatically generated from
 *       paramdef file at compile time, do not modify
 *       since modifications will be overwritten.
 *
 *
 * @author Automatically generated
 *
 */
using namespace std;

#include "Params.hh"
#include <cstring>

  ////////////////////////////////////////////
  // Default constructor
  //

  Params::Params()

  {

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // initialize table

    _init();

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Copy constructor
  //

  Params::Params(const Params& source)

  {

    // sync the source object

    source.sync();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // copy table

    tdrpCopyTable((TDRPtable *) source._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Destructor
  //

  Params::~Params()

  {

    // free up

    freeAll();

  }

  ////////////////////////////////////////////
  // Assignment
  //

  void Params::operator=(const Params& other)

  {

    // sync the other object

    other.sync();

    // free up any existing memory

    freeAll();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // copy table

    tdrpCopyTable((TDRPtable *) other._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = other._exitDeferred;

  }

  ////////////////////////////////////////////
  // loadFromArgs()
  //
  // Loads up TDRP using the command line args.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   char **params_path_p:
  //     If this is non-NULL, it is set to point to the path
  //     of the params file used.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromArgs(int argc, char **argv,
                           char **override_list,
                           char **params_path_p,
                           bool defer_exit)
  {
    int exit_deferred;
    if (_tdrpLoadFromArgs(argc, argv,
                          _table, &_start_,
                          override_list, params_path_p,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadApplyArgs()
  //
  // Loads up TDRP using the params path passed in, and applies
  // the command line args for printing and checking.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   const char *param_file_path: the parameter file to be read in
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadApplyArgs(const char *params_path,
                            int argc, char **argv,
                            char **override_list,
                            bool defer_exit)
  {
    int exit_deferred;
    if (tdrpLoadApplyArgs(params_path, argc, argv,
                          _table, &_start_,
                          override_list,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  //

  bool Params::isArgValid(const char *arg)
  {
    return (tdrpIsArgValid(arg));
  }

  ////////////////////////////////////////////
  // load()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to load
  // up more than one class for a single application. It is a
  // lower-level routine than loadFromArgs, and hence more
  // flexible, but the programmer must do more work.
  //
  //   const char *param_file_path: the parameter file to be read in.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::load(const char *param_file_path,
                   char **override_list,
                   int expand_env, int debug)
  {
    if (tdrpLoad(param_file_path,
                 _table, &_start_,
                 override_list,
                 expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadFromBuf()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to
  // load up more than one module for a single application,
  // using buffers which have been read from a specified source.
  //
  //   const char *param_source_str: a string which describes the
  //     source of the parameter information. It is used for
  //     error reporting only.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   const char *inbuf: the input buffer
  //
  //   int inlen: length of the input buffer
  //
  //   int start_line_num: the line number in the source which
  //     corresponds to the start of the buffer.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromBuf(const char *param_source_str,
                          char **override_list,
                          const char *inbuf, int inlen,
                          int start_line_num,
                          int expand_env, int debug)
  {
    if (tdrpLoadFromBuf(param_source_str,
                        _table, &_start_,
                        override_list,
                        inbuf, inlen, start_line_num,
                        expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadDefaults()
  //
  // Loads up default params for a given class.
  //
  // See load() for more detailed info.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadDefaults(int expand_env)
  {
    if (tdrpLoad(NULL,
                 _table, &_start_,
                 NULL, expand_env, FALSE)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // sync()
  //
  // Syncs the user struct data back into the parameter table,
  // in preparation for printing.
  //
  // This function alters the table in a consistent manner.
  // Therefore it can be regarded as const.
  //

  void Params::sync(void) const
  {
    tdrpUser2Table(_table, (char *) &_start_);
  }

  ////////////////////////////////////////////
  // print()
  // 
  // Print params file
  //
  // The modes supported are:
  //
  //   PRINT_SHORT:   main comments only, no help or descriptions
  //                  structs and arrays on a single line
  //   PRINT_NORM:    short + descriptions and help
  //   PRINT_LONG:    norm  + arrays and structs expanded
  //   PRINT_VERBOSE: long  + private params included
  //

  void Params::print(FILE *out, tdrp_print_mode_t mode)
  {
    tdrpPrint(out, _table, _className, mode);
  }

  ////////////////////////////////////////////
  // checkAllSet()
  //
  // Return TRUE if all set, FALSE if not.
  //
  // If out is non-NULL, prints out warning messages for those
  // parameters which are not set.
  //

  int Params::checkAllSet(FILE *out)
  {
    return (tdrpCheckAllSet(out, _table, &_start_));
  }

  //////////////////////////////////////////////////////////////
  // checkIsSet()
  //
  // Return TRUE if parameter is set, FALSE if not.
  //
  //

  int Params::checkIsSet(const char *paramName)
  {
    return (tdrpCheckIsSet(paramName, _table, &_start_));
  }

  ////////////////////////////////////////////
  // freeAll()
  //
  // Frees up all TDRP dynamic memory.
  //

  void Params::freeAll(void)
  {
    tdrpFreeAll(_table, &_start_);
  }

  ////////////////////////////////////////////
  // usage()
  //
  // Prints out usage message for TDRP args as passed
  // in to loadFromArgs().
  //

  void Params::usage(ostream &out)
  {
    out << "TDRP args: [options as below]\n"
        << "   [ -params path ] specify params file path\n"
        << "   [ -check_params] check which params are not set\n"
        << "   [ -print_params [mode]] print parameters\n"
        << "     using following modes, default mode is 'norm'\n"
        << "       short:   main comments only, no help or descr\n"
        << "                structs and arrays on a single line\n"
        << "       norm:    short + descriptions and help\n"
        << "       long:    norm  + arrays and structs expanded\n"
        << "       verbose: long  + private params included\n"
        << "       short_expand:   short with env vars expanded\n"
        << "       norm_expand:    norm with env vars expanded\n"
        << "       long_expand:    long with env vars expanded\n"
        << "       verbose_expand: verbose with env vars expanded\n"
        << "   [ -tdrp_debug] debugging prints for tdrp\n"
        << "   [ -tdrp_usage] print this usage\n";
  }

  ////////////////////////////////////////////
  // arrayRealloc()
  //
  // Realloc 1D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::arrayRealloc(const char *param_name, int new_array_n)
  {
    if (tdrpArrayRealloc(_table, &_start_,
                         param_name, new_array_n)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // array2DRealloc()
  //
  // Realloc 2D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::array2DRealloc(const char *param_name,
                             int new_array_n1,
                             int new_array_n2)
  {
    if (tdrpArray2DRealloc(_table, &_start_, param_name,
                           new_array_n1, new_array_n2)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // _init()
  //
  // Class table initialization function.
  //
  //

  void Params::_init()

  {

    TDRPtable *tt = _table;

    // Parameter 'Comment 0'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 0");
    tt->comment_hdr = tdrpStrDup("DEBUGGING AND PROCESS CONTROL");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'debug'
    // ctype is '_debug_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("debug");
    tt->descr = tdrpStrDup("Debug option");
    tt->help = tdrpStrDup("If set, debug messages will be printed appropriately");
    tt->val_offset = (char *) &debug - &_start_;
    tt->enum_def.name = tdrpStrDup("debug_t");
    tt->enum_def.nfields = 3;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("DEBUG_OFF");
      tt->enum_def.fields[0].val = DEBUG_OFF;
      tt->enum_def.fields[1].name = tdrpStrDup("DEBUG_NORM");
      tt->enum_def.fields[1].val = DEBUG_NORM;
      tt->enum_def.fields[2].name = tdrpStrDup("DEBUG_VERBOSE");
      tt->enum_def.fields[2].val = DEBUG_VERBOSE;
    tt->single_val.e = DEBUG_OFF;
    tt++;
    
    // Parameter 'malloc_debug_level'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("malloc_debug_level");
    tt->descr = tdrpStrDup("Malloc debug level");
    tt->help = tdrpStrDup("0 - none, 1 - corruption checking, 2 - records all malloc blocks and checks, 3 - printout of all mallocs etc.");
    tt->val_offset = (char *) &malloc_debug_level - &_start_;
    tt->has_min = TRUE;
    tt->has_max = TRUE;
    tt->min_val.i = 0;
    tt->max_val.i = 3;
    tt->single_val.i = 0;
    tt++;
    
    // Parameter 'instance'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("instance");
    tt->descr = tdrpStrDup("Process instance");
    tt->help = tdrpStrDup("Used for registration with procmap.");
    tt->val_offset = (char *) &instance - &_start_;
    tt->single_val.s = tdrpStrDup("Test");
    tt++;
    
    // Parameter 'Comment 1'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 1");
    tt->comment_hdr = tdrpStrDup("PROGRAM MODE OF OPERATION.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'mode'
    // ctype is '_mode_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("mode");
    tt->descr = tdrpStrDup("Operating mode");
    tt->help = tdrpStrDup("In realtime mode, storm_ident waits for a new input file. In archive mode, it moves through the files between the times set by the user.");
    tt->val_offset = (char *) &mode - &_start_;
    tt->enum_def.name = tdrpStrDup("mode_t");
    tt->enum_def.nfields = 2;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("ARCHIVE");
      tt->enum_def.fields[0].val = ARCHIVE;
      tt->enum_def.fields[1].name = tdrpStrDup("REALTIME");
      tt->enum_def.fields[1].val = REALTIME;
    tt->single_val.e = ARCHIVE;
    tt++;
    
    // Parameter 'max_missing_data_gap'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("max_missing_data_gap");
    tt->descr = tdrpStrDup("Max missing data gap (secs)");
    tt->help = tdrpStrDup("In realtime mode, if auto_restart is false, storm_ident looks back from latest data time for the first gap exceeding max_missing_data_gap. Files since this gap are processed.");
    tt->val_offset = (char *) &max_missing_data_gap - &_start_;
    tt->has_min = TRUE;
    tt->min_val.i = 1;
    tt->single_val.i = 3600;
    tt++;
    
    // Parameter 'Comment 2'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 2");
    tt->comment_hdr = tdrpStrDup("TRACKING OPTIONS.");
    tt->comment_text = tdrpStrDup("Options for using and/or starting storm tracking.");
    tt++;
    
    // Parameter 'perform_tracking'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("perform_tracking");
    tt->descr = tdrpStrDup("Option to run tracking automatically.");
    tt->help = tdrpStrDup("If this is set, StormIdent will communicate with the storm tracking program, so that the tracking is performed after each scan.");
    tt->val_offset = (char *) &perform_tracking - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'start_storm_track'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("start_storm_track");
    tt->descr = tdrpStrDup("Option to start storm_track automatically");
    tt->help = tdrpStrDup("If this is set, storm_track will be started from within storm_ident.");
    tt->val_offset = (char *) &start_storm_track - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'storm_track_command_line'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("storm_track_command_line");
    tt->descr = tdrpStrDup("Command line for starting storm_track");
    tt->help = tdrpStrDup("The storm tracking program MUST be started in the BACKGROUND. Therefore make sure you include an '&' at the end of the command line.");
    tt->val_offset = (char *) &storm_track_command_line - &_start_;
    tt->single_val.s = tdrpStrDup("&");
    tt++;
    
    // Parameter 'shmem_key'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("shmem_key");
    tt->descr = tdrpStrDup("Shared mem key.");
    tt->help = tdrpStrDup("This key is used for shared memory communication with storm_track.");
    tt->val_offset = (char *) &shmem_key - &_start_;
    tt->single_val.i = 44000;
    tt++;
    
    // Parameter 'Comment 3'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 3");
    tt->comment_hdr = tdrpStrDup("DATA DIRECTORIES.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'rdata_dir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("rdata_dir");
    tt->descr = tdrpStrDup("Radar data directory - input");
    tt->help = tdrpStrDup("The input MDV files are stored in this directory. In REALTIME mode the program watches the latest_data_info file in this directory and processes a new scan each time the info file updates.");
    tt->val_offset = (char *) &rdata_dir - &_start_;
    tt->single_val.s = tdrpStrDup("null");
    tt++;
    
    // Parameter 'max_realtime_valid_age'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("max_realtime_valid_age");
    tt->descr = tdrpStrDup("Max valid age of rdata input files in realtime mode (secs)");
    tt->help = tdrpStrDup("This the max valid age for an incoming file. The program will wait for a data file more recent than this age.");
    tt->val_offset = (char *) &max_realtime_valid_age - &_start_;
    tt->has_min = TRUE;
    tt->min_val.i = 1;
    tt->single_val.i = 360;
    tt++;
    
    // Parameter 'vel_to_m_per_sec_scale'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("vel_to_m_per_sec_scale");
    tt->descr = tdrpStrDup("Factor to convert velocity field units to m/s.");
    tt->help = tdrpStrDup("This is included in case the velocity is not in m/s units.");
    tt->val_offset = (char *) &vel_to_m_per_sec_scale - &_start_;
    tt->has_min = TRUE;
    tt->min_val.f = 0;
    tt->single_val.f = 1;
    tt++;
    
    // Parameter 'storm_data_dir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("storm_data_dir");
    tt->descr = tdrpStrDup("Storms data directory - output");
    tt->help = tdrpStrDup("The storm files are placed in this directory.");
    tt->val_offset = (char *) &storm_data_dir - &_start_;
    tt->single_val.s = tdrpStrDup("null");
    tt++;
    
    // Parameter 'Comment 4'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 4");
    tt->comment_hdr = tdrpStrDup("DATA FIELDS IN INPUT FILES.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'dbz_field'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("dbz_field");
    tt->descr = tdrpStrDup("dBZ field number");
    tt->help = tdrpStrDup("Field number for dBZ data in radar volumes.");
    tt->val_offset = (char *) &dbz_field - &_start_;
    tt->has_min = TRUE;
    tt->min_val.i = 0;
    tt->single_val.i = 0;
    tt++;
    
    // Parameter 'vel_field'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("vel_field");
    tt->descr = tdrpStrDup("Velocity field number");
    tt->help = tdrpStrDup("Field number for velocity data in radar volumes.");
    tt->val_offset = (char *) &vel_field - &_start_;
    tt->has_min = TRUE;
    tt->min_val.i = 0;
    tt->single_val.i = 1;
    tt++;
    
    // Parameter 'vel_available'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("vel_available");
    tt->descr = tdrpStrDup("Flag to indicate if velocity data is available");
    tt->help = tdrpStrDup("If this is set, velocity data is available in the radar volumes. Velocity-based computations will be carried out. If not, velocity-based computations will be omitted.");
    tt->val_offset = (char *) &vel_available - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 5'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 5");
    tt->comment_hdr = tdrpStrDup("STORM IDENTIFICATION PARAMETERS.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'low_dbz_threshold'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("low_dbz_threshold");
    tt->descr = tdrpStrDup("Lower dBZ threshold for storm identification (dBZ).");
    tt->help = tdrpStrDup("Storms are defined as regions with reflectivity values in excess of this value.");
    tt->val_offset = (char *) &low_dbz_threshold - &_start_;
    tt->single_val.f = 35;
    tt++;
    
    // Parameter 'high_dbz_threshold'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("high_dbz_threshold");
    tt->descr = tdrpStrDup("Upper dBZ threshold (dBZ).");
    tt->help = tdrpStrDup("If a storm contains reflectivity in excess of this value, it will not be processed.");
    tt->val_offset = (char *) &high_dbz_threshold - &_start_;
    tt->single_val.f = 80;
    tt++;
    
    // Parameter 'min_grid_overlap'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("min_grid_overlap");
    tt->descr = tdrpStrDup("Min overlap between storm fragments.");
    tt->help = tdrpStrDup("A storm is made up of a series of adjacent 'runs' of data in the EW direction. When testing for overlap, some minimum number of overlap grids must be used. This is that minimum overlap in grid units.");
    tt->val_offset = (char *) &min_grid_overlap - &_start_;
    tt->has_min = TRUE;
    tt->min_val.i = 1;
    tt->single_val.i = 1;
    tt++;
    
    // Parameter 'use_dual_threshold'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("use_dual_threshold");
    tt->descr = tdrpStrDup("Option to perform identification using dual thresholds.");
    tt->help = tdrpStrDup("If set, the identification is performed in multiple stages. First, an outer storm envelope is computed, using the low_dbz_threshold. This is the default method which has always been used in TITAN. Then, using the dual_threshold parameters, a search is performed for storms within the envelope exceeding the dbz_threshold. If there is only one region at the higher reflectivity, the entire outer envelope is used. If there are two or more regions which meet or exceed the required characteristics, these regions are grown back out to the original envelop, but stop growing where they meet between the higher-reflectivity areas. The final storms are computed by breaking the original storm into regions based upon these secondary areas.");
    tt->val_offset = (char *) &use_dual_threshold - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'dual_threshold'
    // ctype is '_dual_threshold_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("dual_threshold");
    tt->descr = tdrpStrDup("Parameters for dual threshold identification.");
    tt->help = tdrpStrDup("See 'use_dual_threshold'. dbz_threshold: threshold for this stage. A number of regions may be identified at the higher threshold. min_frction_all_parts: we sum the sizes of the parts at the higher threshold, and the sum divided by the original size of the envelope must exceed this fraction. If it does not the original envelope is used. min_fraction_each_part: for any part to be valid its size as a fraction of all of the parts must exceed this value. min_area_each_part: for any part to be valid its area must exceed this value. If it does not the part is ignored. If only 1 part is valid, the entire envelope is used.");
    tt->val_offset = (char *) &dual_threshold - &_start_;
    tt->struct_def.name = tdrpStrDup("dual_threshold_t");
    tt->struct_def.nfields = 4;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("float");
      tt->struct_def.fields[0].fname = tdrpStrDup("dbz_threshold");
      tt->struct_def.fields[0].ptype = FLOAT_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &dual_threshold.dbz_threshold - (char *) &dual_threshold;
      tt->struct_def.fields[1].ftype = tdrpStrDup("float");
      tt->struct_def.fields[1].fname = tdrpStrDup("min_fraction_all_parts");
      tt->struct_def.fields[1].ptype = FLOAT_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &dual_threshold.min_fraction_all_parts - (char *) &dual_threshold;
      tt->struct_def.fields[2].ftype = tdrpStrDup("float");
      tt->struct_def.fields[2].fname = tdrpStrDup("min_fraction_each_part");
      tt->struct_def.fields[2].ptype = FLOAT_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &dual_threshold.min_fraction_each_part - (char *) &dual_threshold;
      tt->struct_def.fields[3].ftype = tdrpStrDup("float");
      tt->struct_def.fields[3].fname = tdrpStrDup("min_area_each_part");
      tt->struct_def.fields[3].ptype = FLOAT_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &dual_threshold.min_area_each_part - (char *) &dual_threshold;
    tt->n_struct_vals = 4;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].f = 45;
      tt->struct_vals[1].f = 0.5;
      tt->struct_vals[2].f = 0.05;
      tt->struct_vals[3].f = 20;
    tt++;
    
    // Parameter 'create_dual_threshold_files'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("create_dual_threshold_files");
    tt->descr = tdrpStrDup("Option to create dual threshold files for debugging.");
    tt->help = tdrpStrDup("If this is set, dual threshold files will be stored in dual_threshold_dir.");
    tt->val_offset = (char *) &create_dual_threshold_files - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'dual_threshold_dir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("dual_threshold_dir");
    tt->descr = tdrpStrDup("Dual_threshold data directory.");
    tt->help = tdrpStrDup("If create_dual_threshold_files is TRUE, the dual_threshold debugging files are stored in this directory.");
    tt->val_offset = (char *) &dual_threshold_dir - &_start_;
    tt->single_val.s = tdrpStrDup("null");
    tt++;
    
    // Parameter 'base_threshold'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("base_threshold");
    tt->descr = tdrpStrDup("Storm base threshold (km).");
    tt->help = tdrpStrDup("Storms identification is only performed using CAPPIs at or above this threshold. Reflectivity values in CAPPIs below the base are ignored.");
    tt->val_offset = (char *) &base_threshold - &_start_;
    tt->has_min = TRUE;
    tt->has_max = TRUE;
    tt->min_val.f = 0;
    tt->max_val.f = 25;
    tt->single_val.f = 0;
    tt++;
    
    // Parameter 'top_threshold'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("top_threshold");
    tt->descr = tdrpStrDup("Storm top threshold (km).");
    tt->help = tdrpStrDup("Storms identification is only performed using CAPPIs at or below this threshold. Reflectivity values in CAPPIs above the top are ignored.");
    tt->val_offset = (char *) &top_threshold - &_start_;
    tt->has_min = TRUE;
    tt->has_max = TRUE;
    tt->min_val.f = 0;
    tt->max_val.f = 30;
    tt->single_val.f = 30;
    tt++;
    
    // Parameter 'min_storm_size'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("min_storm_size");
    tt->descr = tdrpStrDup("Minimum storm size (km2 or km3 depending on input grid type).");
    tt->help = tdrpStrDup("Storms must exceed this size to be considered valie.  If the data is 2D (i.e. nz == 1), the units are km2; if the data is 3D, units are km3.");
    tt->val_offset = (char *) &min_storm_size - &_start_;
    tt->has_min = TRUE;
    tt->min_val.f = 0;
    tt->single_val.f = 30;
    tt++;
    
    // Parameter 'max_storm_size'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("max_storm_size");
    tt->descr = tdrpStrDup("Maximum storm size (km2 or km3 depending on input grid type).");
    tt->help = tdrpStrDup("Storms must not exceed this size to be considered valid.  If the data is 2D (i.e. nz == 1), the units are km2; if the data is 3D, the units are km3.");
    tt->val_offset = (char *) &max_storm_size - &_start_;
    tt->has_min = TRUE;
    tt->min_val.f = 1;
    tt->single_val.f = 1e+09;
    tt++;
    
    // Parameter 'Comment 6'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 6");
    tt->comment_hdr = tdrpStrDup("OPTIONS TO CHECK SECOND TRIP.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'check_range_limits'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("check_range_limits");
    tt->descr = tdrpStrDup("Option to check for storm range limits.");
    tt->help = tdrpStrDup("If the storm is at the limit of radar range, a flag is set.");
    tt->val_offset = (char *) &check_range_limits - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'check_second_trip'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("check_second_trip");
    tt->descr = tdrpStrDup("Option to check for second trip characteristics.");
    tt->help = tdrpStrDup("If set, the storm orientation and shape are checked for second trip characteristics. An elongated, low storm with a major axis lined up with the radar indicates a likely second-trip echo. For a storm to be considered second-trip, all 3 of the following tests must be passwd: (a) the horizontal aspect ratio exceeds the given parameter; (b) the vertical aspect ratio exceeds the given parameter; (c) the horizontal orientation lies close to the line from the radra. If the storm is thought to be second-trip, the second-trip flag is set.");
    tt->val_offset = (char *) &check_second_trip - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'sectrip_vert_aspect'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("sectrip_vert_aspect");
    tt->descr = tdrpStrDup("Second trip detection vertical aspect threshold.");
    tt->help = tdrpStrDup("If the vertical aspect ratio exceeds this value, the storm may be flagged as second-trip.");
    tt->val_offset = (char *) &sectrip_vert_aspect - &_start_;
    tt->has_min = TRUE;
    tt->has_max = TRUE;
    tt->min_val.f = 1;
    tt->max_val.f = 20;
    tt->single_val.f = 4;
    tt++;
    
    // Parameter 'sectrip_horiz_aspect'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("sectrip_horiz_aspect");
    tt->descr = tdrpStrDup("Second trip detection horizontal aspect threshold.");
    tt->help = tdrpStrDup("If the horizontal aspect ratio (based on the ellipse) exceeds this value, the storm may be flagged as second-trip.");
    tt->val_offset = (char *) &sectrip_horiz_aspect - &_start_;
    tt->has_min = TRUE;
    tt->has_max = TRUE;
    tt->min_val.f = 1;
    tt->max_val.f = 20;
    tt->single_val.f = 4;
    tt++;
    
    // Parameter 'sectrip_orientation_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("sectrip_orientation_error");
    tt->descr = tdrpStrDup("Allowable second trip orientation error.");
    tt->help = tdrpStrDup("For a storm to be flagged as second-trip, the orientation must be aligned with the storm azimuth from the radar, within this allowable error.");
    tt->val_offset = (char *) &sectrip_orientation_error - &_start_;
    tt->has_min = TRUE;
    tt->has_max = TRUE;
    tt->min_val.f = 1;
    tt->max_val.f = 90;
    tt->single_val.f = 10;
    tt++;
    
    // Parameter 'Comment 7'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 7");
    tt->comment_hdr = tdrpStrDup("PRECIP RATE AND MASS PARAMETERS.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'hail_dbz_threshold'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("hail_dbz_threshold");
    tt->descr = tdrpStrDup("Hail reflectivity threshold");
    tt->help = tdrpStrDup("The threshold between rain and hail (dBZ)");
    tt->val_offset = (char *) &hail_dbz_threshold - &_start_;
    tt->has_min = TRUE;
    tt->has_max = TRUE;
    tt->min_val.f = 40;
    tt->max_val.f = 70;
    tt->single_val.f = 55;
    tt++;
    
    // Parameter 'ZR'
    // ctype is '_zr_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("ZR");
    tt->descr = tdrpStrDup("Z-R parameters");
    tt->help = tdrpStrDup("Parameters in Z-R relationship.");
    tt->val_offset = (char *) &ZR - &_start_;
    tt->struct_def.name = tdrpStrDup("zr_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("float");
      tt->struct_def.fields[0].fname = tdrpStrDup("coeff");
      tt->struct_def.fields[0].ptype = FLOAT_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &ZR.coeff - (char *) &ZR;
      tt->struct_def.fields[1].ftype = tdrpStrDup("float");
      tt->struct_def.fields[1].fname = tdrpStrDup("expon");
      tt->struct_def.fields[1].ptype = FLOAT_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &ZR.expon - (char *) &ZR;
    tt->n_struct_vals = 2;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].f = 200;
      tt->struct_vals[1].f = 1.6;
    tt++;
    
    // Parameter 'ZM'
    // ctype is '_zr_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("ZM");
    tt->descr = tdrpStrDup("Z-M parameters");
    tt->help = tdrpStrDup("Parameters in Z-M relationship.");
    tt->val_offset = (char *) &ZM - &_start_;
    tt->struct_def.name = tdrpStrDup("zr_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("float");
      tt->struct_def.fields[0].fname = tdrpStrDup("coeff");
      tt->struct_def.fields[0].ptype = FLOAT_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &ZM.coeff - (char *) &ZM;
      tt->struct_def.fields[1].ftype = tdrpStrDup("float");
      tt->struct_def.fields[1].fname = tdrpStrDup("expon");
      tt->struct_def.fields[1].ptype = FLOAT_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &ZM.expon - (char *) &ZM;
    tt->n_struct_vals = 2;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].f = 20465;
      tt->struct_vals[1].f = 1.75;
    tt++;
    
    // Parameter 'dbz_hist_interval'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("dbz_hist_interval");
    tt->descr = tdrpStrDup("Dbz histogram interval.");
    tt->help = tdrpStrDup("Reflectivity interval for histogram computations related to the reflectivity distribution.");
    tt->val_offset = (char *) &dbz_hist_interval - &_start_;
    tt->has_min = TRUE;
    tt->min_val.f = 0.01;
    tt->single_val.f = 3;
    tt++;
    
    // Parameter 'Comment 8'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 8");
    tt->comment_hdr = tdrpStrDup("OPTIONS TO STORE STORM RUNS IN OUTPUT FILE.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'store_storm_runs'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("store_storm_runs");
    tt->descr = tdrpStrDup("Option to store runs in storm file");
    tt->help = tdrpStrDup("If set, the raw storm runs are stored in the storm file. A run is a contiguous block of reflectivity in the X direction for a given Y and Z. This is a useful way of storing storm grid locations reasonably efficiently. If the runs are stored, the exact 3D storm shape can be recreated from the storm file.");
    tt->val_offset = (char *) &store_storm_runs - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'store_proj_runs'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("store_proj_runs");
    tt->descr = tdrpStrDup("Option to store projected area runs in storm file");
    tt->help = tdrpStrDup("If set, the raw storm projected area runs are stored in the storm file. A run is a contiguous block of reflectivity in the X direction for a given Y. If these runs are stored, the exact 2D projected area storm shape can be recreated from the storm file.");
    tt->val_offset = (char *) &store_proj_runs - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'Comment 9'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 9");
    tt->comment_hdr = tdrpStrDup("OPTION TO CREATE VERIFICATION FILES.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'create_verification_files'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("create_verification_files");
    tt->descr = tdrpStrDup("Option to create verification files.");
    tt->help = tdrpStrDup("If this is set, verification files will be stored in verify_dir. The verification files allow forecast verification against the regions which were actually used by the program to compute the storms. There are 2 fields: field 0 is the ALL_STORMS_FIELD - all storms above threshold are stored even if they do not meet other criteria such as minimum storm volume. Field 1 is the VALID_STORMS_FIELD, which only include the valid storms included in the storm file.");
    tt->val_offset = (char *) &create_verification_files - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'verify_dir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("verify_dir");
    tt->descr = tdrpStrDup("Verify data directory.");
    tt->help = tdrpStrDup("If create_verification_files is TRUE, the verification files are stored in this directory.");
    tt->val_offset = (char *) &verify_dir - &_start_;
    tt->single_val.s = tdrpStrDup("null");
    tt++;
    
    // Parameter 'Comment 10'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 10");
    tt->comment_hdr = tdrpStrDup("OPTION TO CHECK STORM MORPHOLOGY.");
    tt->comment_text = tdrpStrDup("The storm morphology check allows you to erode minor connections between storms when these connections really have no phyical significance.");
    tt++;
    
    // Parameter 'check_morphology'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("check_morphology");
    tt->descr = tdrpStrDup("Option to check morphology");
    tt->help = tdrpStrDup("If this is set, morphology will be used for storm definition. A check is performed on storm morphology to reduce apparent mergers. The technique is as follows: 1. Compute euclidean distance (ed) of each point from edge of storm clump 2. Compute reflectivity excess above threshold, and divide by morphology_refl_divisor (in dbz/km). 3. Add ed to refl excess, to get interest map 4. Threshold interest map using morphology_erosion_threshold (in km). 5. Erode points which do not exceed the threshold, and which are not adjacent to a point which exceeds the threshold.");
    tt->val_offset = (char *) &check_morphology - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'create_morphology_files'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("create_morphology_files");
    tt->descr = tdrpStrDup("Option to create morphology files for debugging.");
    tt->help = tdrpStrDup("If this is set, morphology files will be stored in morphology_dir.");
    tt->val_offset = (char *) &create_morphology_files - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'morphology_dir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("morphology_dir");
    tt->descr = tdrpStrDup("Morphology data directory.");
    tt->help = tdrpStrDup("If create_morphology_files is TRUE, the morphology files are stored in this directory.");
    tt->val_offset = (char *) &morphology_dir - &_start_;
    tt->single_val.s = tdrpStrDup("null");
    tt++;
    
    // Parameter 'morphology_erosion_threshold'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("morphology_erosion_threshold");
    tt->descr = tdrpStrDup("Erosion threshold for morphology check (km).");
    tt->help = tdrpStrDup("Threshold to which morphology erosion is performed.");
    tt->val_offset = (char *) &morphology_erosion_threshold - &_start_;
    tt->has_min = TRUE;
    tt->has_max = TRUE;
    tt->min_val.f = 0;
    tt->max_val.f = 100;
    tt->single_val.f = 5;
    tt++;
    
    // Parameter 'morphology_refl_divisor'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("morphology_refl_divisor");
    tt->descr = tdrpStrDup("Reflectivity divisor for morphology check (dbz/km).");
    tt->help = tdrpStrDup("The morphology value for a point (km) is obtained by adding the euclidean distance to storm edge (km) to the reflectivity excess (above threshold) divided by this value (dbz/km).");
    tt->val_offset = (char *) &morphology_refl_divisor - &_start_;
    tt->has_min = TRUE;
    tt->has_max = TRUE;
    tt->min_val.f = 0.1;
    tt->max_val.f = 100;
    tt->single_val.f = 10;
    tt++;
    
    // Parameter 'Comment 11'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 11");
    tt->comment_hdr = tdrpStrDup("OPTION TO CHECK STORM TOPS.");
    tt->comment_text = tdrpStrDup("The storm tops check allows you to remove areas with low tops prior to performing the storm identification. In this manner you can ignore regions of stratiform rain.");
    tt++;
    
    // Parameter 'check_tops'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("check_tops");
    tt->descr = tdrpStrDup("Option to check tops");
    tt->help = tdrpStrDup("If this is active, areas with radar tops below min_radar_tops will be removed from the data prior to storm identification. The tops_edge_margin parameter allows you to account for tilted storms, leaving a  margin around the area to be removed.");
    tt->val_offset = (char *) &check_tops - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'create_tops_files'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("create_tops_files");
    tt->descr = tdrpStrDup("Option to create tops files for debugging.");
    tt->help = tdrpStrDup("If this is set, tops files will be stored in tops_dir.");
    tt->val_offset = (char *) &create_tops_files - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'tops_dir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("tops_dir");
    tt->descr = tdrpStrDup("Radar tops data directory.");
    tt->help = tdrpStrDup("If create_tops_files is TRUE, the tops files are stored in this directory.");
    tt->val_offset = (char *) &tops_dir - &_start_;
    tt->single_val.s = tdrpStrDup("null");
    tt++;
    
    // Parameter 'min_radar_tops'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("min_radar_tops");
    tt->descr = tdrpStrDup("Minimum radar tops (km).");
    tt->help = tdrpStrDup("Minimum radar tops for valid radar data - see check_tops.");
    tt->val_offset = (char *) &min_radar_tops - &_start_;
    tt->has_min = TRUE;
    tt->has_max = TRUE;
    tt->min_val.f = 0;
    tt->max_val.f = 25;
    tt->single_val.f = 4.5;
    tt++;
    
    // Parameter 'tops_edge_margin'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("tops_edge_margin");
    tt->descr = tdrpStrDup("Margin placed around tops when computing min_tops field (km).");
    tt->help = tdrpStrDup("This takes into account the fact that some storms may be tilted. Grid points within this margin are left intact.");
    tt->val_offset = (char *) &tops_edge_margin - &_start_;
    tt->has_min = TRUE;
    tt->has_max = TRUE;
    tt->min_val.f = 0;
    tt->max_val.f = 10;
    tt->single_val.f = 1.5;
    tt++;
    
    // Parameter 'Comment 12'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 12");
    tt->comment_hdr = tdrpStrDup("AUTO-RESTART OPTION.");
    tt->comment_text = tdrpStrDup("This allows you to automatically restart the program at a given time of day (GMT). This keeps the output files simple - there is one series of files per day. If storm tracking is running it is also restarted.");
    tt++;
    
    // Parameter 'auto_restart'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("auto_restart");
    tt->descr = tdrpStrDup("Auto-restart option");
    tt->help = tdrpStrDup("If set, the program restarts at restart_time (GMT). The data from the previous 'restart_overlap_period' is copied into the new file, so that tracks at restart time will have some history. Use of this option ensures that the storm and track files will not grow forever.");
    tt->val_offset = (char *) &auto_restart - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'restart_time'
    // ctype is '_restart_time_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("restart_time");
    tt->descr = tdrpStrDup("The time in the day (UCT/GMT) at which restart occurs.");
    tt->help = tdrpStrDup("The program will check for the passing of this time. Once data beyond this time is found, restart will occur.\n");
    tt->val_offset = (char *) &restart_time - &_start_;
    tt->struct_def.name = tdrpStrDup("restart_time_t");
    tt->struct_def.nfields = 2;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("int");
      tt->struct_def.fields[0].fname = tdrpStrDup("hour");
      tt->struct_def.fields[0].ptype = INT_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &restart_time.hour - (char *) &restart_time;
      tt->struct_def.fields[1].ftype = tdrpStrDup("int");
      tt->struct_def.fields[1].fname = tdrpStrDup("min");
      tt->struct_def.fields[1].ptype = INT_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &restart_time.min - (char *) &restart_time;
    tt->n_struct_vals = 2;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].i = 0;
      tt->struct_vals[1].i = 0;
    tt++;
    
    // Parameter 'restart_overlap_period'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("restart_overlap_period");
    tt->descr = tdrpStrDup("The period copied to the new file on restart (secs).");
    tt->help = tdrpStrDup("On restart, the program copies some of the previous file, to provide history for storm_track. This is the duration of the copied data.");
    tt->val_offset = (char *) &restart_overlap_period - &_start_;
    tt->has_min = TRUE;
    tt->min_val.i = 0;
    tt->single_val.i = 3600;
    tt++;
    
    // Parameter 'remove_old_files_on_restart'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("remove_old_files_on_restart");
    tt->descr = tdrpStrDup("Cleanup on restart option");
    tt->help = tdrpStrDup("If set, the program will delete old storm files on restart. This allows the program to keep the disk usage low.");
    tt->val_offset = (char *) &remove_old_files_on_restart - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'restart_no_delay'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("restart_no_delay");
    tt->descr = tdrpStrDup("Flag to force restart at first opportunity.");
    tt->help = tdrpStrDup("Normally the restart time will be set so that at least one day elapses before the restart. This flag forces the restart at the first opportunity. This option is normally only used for debugging.");
    tt->val_offset = (char *) &restart_no_delay - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // trailing entry has param_name set to NULL
    
    tt->param_name = NULL;
    
    return;
  
  }
