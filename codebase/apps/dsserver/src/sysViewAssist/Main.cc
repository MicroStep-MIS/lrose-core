// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* 
// ** Copyright UCAR (c) 1990 - 2016                                         
// ** University Corporation for Atmospheric Research (UCAR)                 
// ** National Center for Atmospheric Research (NCAR)                        
// ** Boulder, Colorado, USA                                                 
// ** BSD licence applies - redistribution and use in source and binary      
// ** forms, with or without modification, are permitted provided that       
// ** the following conditions are met:                                      
// ** 1) If the software is modified to produce derivative works,            
// ** such modified software should be clearly marked, so as not             
// ** to confuse it with the version available from UCAR.                    
// ** 2) Redistributions of source code must retain the above copyright      
// ** notice, this list of conditions and the following disclaimer.          
// ** 3) Redistributions in binary form must reproduce the above copyright   
// ** notice, this list of conditions and the following disclaimer in the    
// ** documentation and/or other materials provided with the distribution.   
// ** 4) Neither the name of UCAR nor the names of its contributors,         
// ** if any, may be used to endorse or promote products derived from        
// ** this software without specific prior written permission.               
// ** DISCLAIMER: THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS  
// ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      
// ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    
// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* 

#include <signal.h>
#include <toolsa/port.h>
#include <toolsa/pmu.h>
#include <toolsa/umisc.h>
#include <cstring>
#include <cstdio>

#include <dsserver/DmapAccess.hh>
#include <Spdb/DsSpdb.hh>
#include <Mdv/DsMdvx.hh>

#include "Params.hh"

using namespace std;

double getMdvMeanInterval(char *url, time_t endTime, long lookbackTime, int minPoints);
double getSpdbMeanInterval(char *url, time_t endTime, long lookbackTime, int minPoints);

int main( int argc, char **argv )
{

   Params params;
    
   if (params.loadFromArgs(argc,argv,NULL,NULL)){
     cerr << "Specify params file with -params option." << endl ;
     return(-1);
   }                       

   //
   // Parse out the time we're supposed to look for data, if we're to look for data.
   //
   date_time_t T;
   if (params.doData){
     if (6 != sscanf(params.endTime, "%d %d %d %d %d %d", &T.year, &T.month, &T.day, &T.hour, &T.min, &T.sec)){
       cerr << "Unable to parse data end time from " << params.endTime << endl;
       exit(-1);
     }
     uconvert_to_utime( &T );
   }
   cerr << "Data interval calculations cover " << utimstr( T.unix_time - params.lookbackTime ) << " to " << utimstr( T.unix_time ) << endl;

   
   //
   // Open the process list file.
   //
   FILE *ifp = fopen(params.processList, "r");
   if (ifp == NULL){
     cerr << "Process list " << params.processList << " not found, I cannot cope." << endl;
     exit(-1);
   }

   //
   // Given that we have the process list file, 
   // we'll probably be writing something, so open
   // the output diagram file and write the header
   // to it.
   //
   FILE *ofp = fopen(params.diagramFile, "w");
   if (ofp == NULL){
     cerr << "ERROR : Unable to create output diagram file " << params.diagramFile << endl;
     exit(-1);
   }

   fprintf(ofp,"%s\n", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>");

   fprintf(ofp,"<DIAGRAM className=\"edu.ucar.rap.sysview.appcore.DiagramConfig\" label=\"%s\" xloc=\"0\" yloc=\"0\" windowWidth=\"850\" windowHeight=\"600\" status=\"STATUS_DOWN\" priority=\"PRIORITY_HIGH\" infoLink=\"\" description=\"Automatically generated by sysViewAssist\">\n", params.hostname);

   //
   // Loop through the process list part of the diagram.
   //
   char Line[1024];
   int ixloc = params.layout.xInc; int iyloc = params.layout.yInc;
   int lineCount = 0;
   while(NULL != fgets(Line, 1024, ifp)){

     //
     // Skip comment lines, and blank lines.
     //
     if (
	 (strlen(Line) < 3) ||
	 (Line[0] == '#')
	 ){
       continue;
     }

     char processName[256];
     char processInstance[256];
     if (2 != sscanf(Line, "%s %s",  processName, processInstance)){
       cerr << "Failed to parse the following line in " << params.diagramFile << ":" <<endl;
       cerr << Line;
       continue;
     }

     //
     // See if we need to do a substitution on the instance string
     // based on the question-mark syntax.
     //
     if (NULL != strstr(processInstance, "?")){
       //
       // Need to do a substitution. Extract the substring that
       // is between the question marks.
       //
       int ip=0;
       char extractedString[256];
       int extractOn = 0;
       for (unsigned i=0; i < strlen(processInstance); i++){
	 
	 if ((extractOn) && (processInstance[i] != '?')){
	   extractedString[ip] = processInstance[i];
	   ip++;  extractedString[ip] = char(0);
	 }

	 if (processInstance[i] == '?'){
	   if (extractOn)
	     extractOn = 0;
	   else
	     extractOn = 1;
	 }
       }

       //
       // Now hunt for this extracted string in the param subList.
       //
       char *newString = NULL;
       for (int k=0; k < params.subList_n; k++){
	 if (0==strcmp(extractedString, params._subList[k].oldString)){
	   newString = params._subList[k].newString;
	   break;
	 }
       }

       if (newString == NULL){
	 cerr << "ERROR - no substitution found for " << extractedString << endl;
	 exit(-1);
       }

       //
       // Now substitute in newString for extractedString.
       //
       char tmp[1024];
       memset(tmp, 0, 1024);
 
       int il = 0;
       unsigned l=0;
       while (l < strlen(processInstance)){
	 //
	 if (processInstance[l] == '?'){
	   //
	   // Do the substitution - append extractedString to what
	   // we have so far in tmp.
	   //
	   sprintf(tmp, "%s%s", tmp, newString);
	   //
	   // And set il to point to the right place in tmp.
	   //
	   il = strlen(tmp);
	   //
	   // Then increment l so that it points to one more than
	   // the next question mark in processInstance.
	   //
	   while(1) {
	     l++;
	     if (processInstance[l] == '?'){
	       l++;
	       break;
	     }
	   }
	 } else {
	   //
	   // No substitution, just move the character across.
	   //
	   tmp[il] = processInstance[l];
	   il++; l++;
	 }
       }
       //
       // Overwrite the process instance.
       //
      sprintf(processInstance, "%s", tmp);
     }


     cerr << "Adding process " << processName << "\tinstance " << processInstance << endl;
     
     fprintf(ofp,"  <THING className=\"edu.ucar.rap.sysview.appcore.ProcessConfig\" onTop=\"true\" processInstance=\"%s\" processName=\"%s\" host=\"%s\" xloc=\"%d\" yloc=\"%d\" status=\"STATUS_DOWN\" priority=\"PRIORITY_HIGH\" infoLink=\"\" description=\"\" />\n", processInstance, processName, params.hostname, ixloc, iyloc);
     
     lineCount++;
     if (lineCount == params.layout.nx)
       {
	 ixloc = params.layout.xInc;
	 iyloc += params.layout.yInc;
	 lineCount = 0;
       } else {
	 ixloc += params.layout.xInc;
       }
   }

   
   //
   // If we're not doing the data part of the diagram,
   // then we're done.
   //
   fclose(ifp);
   if (!(params.doData)){
     fprintf(ofp,"</DIAGRAM>\n");
     fclose (ofp);
     exit(0);
   }
   
   //
   //
   // Start the data list.
   //
   ixloc = params.layout.xInc;
   iyloc += 2*params.layout.yInc;
   lineCount = 0;
   //
   // Contact the DataMapper to get the data part of the diagram.
   //
   DmapAccess dMap;
   if (dMap.reqAllInfo(params.hostname)){
     cerr << "Unable to contact DataMapper on host " << params.hostname << endl;
   } else {

     int nInfo = dMap.getNInfo();
     cerr << nInfo << " datasets found on " <<  params.hostname << endl;

     for (int i = 0; i < nInfo; i++) {

       const DMAP_info_t &info = dMap.getInfo(i);

       //
       // Skip null cases
       if ((strlen(info.datatype)==0) ||
	   (strlen(info.dir) == 0)){
	 continue;
       }

       //
       // If the data type is mdv or spdb, put it in the
       // diagram, otherwise discard it.
       //
       cerr << "Dataset " << i+1 << " : " << info.datatype << " : " << info.dir << " on " << info.hostname << endl;

       int gotType = 0;
       char url[1024];
       long lateTime = params.defaultLateTime;
       
       if (0 == strcmp( info.datatype, "mdv" )){
	 sprintf(url, "mdvp:://%s::%s", info.hostname, info.dir);
	 if (!(params.forceDefaultLateTime)){
	   double meanInterval = getMdvMeanInterval(url, T.unix_time, params.lookbackTime, params.minDataTimes);
	   if (meanInterval > 0.0) lateTime = (int)rint(meanInterval * params.mean2lateTimeFactor);
	 }
	 gotType = 1;
       }
       
       if (0 == strcmp( info.datatype, "spdb" )){
	 sprintf(url, "spdbp:://%s::%s", info.hostname, info.dir);
	 if (!(params.forceDefaultLateTime)){
	   double meanInterval = getSpdbMeanInterval(url, T.unix_time, params.lookbackTime, params.minDataTimes);
	   if (meanInterval > 0.0) lateTime = (int)rint(meanInterval * params.mean2lateTimeFactor);
	 }
	 gotType = 1;
       }
       
       if (gotType){
	 cerr << "    Recognised type, url " << url << endl;
       }

       if ((gotType) || (params.addUnknownTypes)){

	 cerr << "    Adding to diagram, latetime " << lateTime << " very late time " << (int)rint(params.veryLateFactor * lateTime) << endl;

	 fprintf(ofp,
		 "  <THING className=\"edu.ucar.rap.sysview.appcore.DatasetConfig\" onTop=\"true\" dataType=\"%s\" dataDir=\"%s\" host=\"%s\" lateDataSecs=\"%d\" veryLateDataSecs=\"%d\" xloc=\"%d\" yloc=\"%d\" status=\"STATUS_DOWN\" priority=\"PRIORITY_HIGH\" infoLink=\"\" description=\"\" />\n", 
		 info.datatype, info.dir, info.hostname, (int)lateTime, (int)rint(params.veryLateFactor * lateTime), ixloc, iyloc);

	 lineCount++;
	 if (lineCount == params.layout.nx)
	   {
	     ixloc = params.layout.xInc;
	     iyloc += params.layout.yInc;
	     lineCount = 0;
	   } else {
	     ixloc += params.layout.xInc;
	   }
       }
       
     }

   }

   //
   // Close the diagram.
   //
   fprintf(ofp,"</DIAGRAM>\n");
   fclose(ofp);
   return 0;

}

///////////////////////////////////////////////////////////////////////
//
// Function to try to get the mean interval between data points, seconds,
// for MDV data.
// returns -1 on failure.
//
double getMdvMeanInterval(char *url, time_t endTime, long lookbackTime,
			  int minPoints){

  time_t startTime = endTime - lookbackTime;

  DsMdvx Tlist;
  Tlist.setTimeListModeValid( url, startTime, endTime);
  Tlist.compileTimeList();

  vector<time_t> inTimes = Tlist.getTimeList();

  if (inTimes.size() < (unsigned)minPoints) return -1.0;

  int num=0;
  double total = 0.0;

  for (unsigned i=0; i < inTimes.size()-1; i++){
    long interval =  inTimes[i+1] - inTimes[i];
    if (interval > 0){
      total += interval;
      num++;
    }
  }

  if (num > 0) return total / double(num);

  //
  // Not successful.
  //
  return -1.0;
}

///////////////////////////////////////////////////////////////////////
//
// Function to try to get the mean interval between data points, seconds,
// for SPDB data.
// returns -1 on failure.
//
double getSpdbMeanInterval(char *url, time_t endTime, long lookbackTime,
			   int minPoints){

  time_t startTime = endTime - lookbackTime;

  DsSpdb spdb;

  //
  // Only get the chunk refs in this getInterval() call.
  //
  spdb.getInterval(url, startTime, endTime, 0, 0, true);

  int nChunks = spdb.getNChunks();

  if (nChunks < minPoints) return -1;

  Spdb::chunk_ref_t  *chunk_hdr = spdb.getChunkRefs();

  double total = 0.0;
  int num = 0;

  for (int i=0; i < nChunks-1; i++){
    int interval = chunk_hdr[i+1].valid_time - chunk_hdr[i].valid_time;
    if (interval > 0){
      total += interval;
      num++;
    }
  }

  if (num > 0) return total / double(num);


  //
  // Not successful.
  //
  return -1.0;
}












