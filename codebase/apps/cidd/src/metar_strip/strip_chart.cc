// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* 
// ** Copyright UCAR (c) 1990 - 2016                                         
// ** University Corporation for Atmospheric Research (UCAR)                 
// ** National Center for Atmospheric Research (NCAR)                        
// ** Boulder, Colorado, USA                                                 
// ** BSD licence applies - redistribution and use in source and binary      
// ** forms, with or without modification, are permitted provided that       
// ** the following conditions are met:                                      
// ** 1) If the software is modified to produce derivative works,            
// ** such modified software should be clearly marked, so as not             
// ** to confuse it with the version available from UCAR.                    
// ** 2) Redistributions of source code must retain the above copyright      
// ** notice, this list of conditions and the following disclaimer.          
// ** 3) Redistributions in binary form must reproduce the above copyright   
// ** notice, this list of conditions and the following disclaimer in the    
// ** documentation and/or other materials provided with the distribution.   
// ** 4) Neither the name of UCAR nor the names of its contributors,         
// ** if any, may be used to endorse or promote products derived from        
// ** this software without specific prior written permission.               
// ** DISCLAIMER: THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS  
// ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      
// ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    
// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* 
/*************************************************************************
 * STRIP_CHART.c - Produce a strip chart like plot of esonet data
 *
 * F. hage. 9/95
 */

#define STRIP_CHART_MAIN
#include "strip_chart.h"
#undef STRIP_CHART_MAIN

#include "Params.hh"
#include <toolsa/DateTime.hh>
using namespace std;

// prototypes

static void init_xview();
static int  x_error_proc( Display *disp, XErrorEvent *event);
static Notify_value base_win_destroy( Notify_client client,
				      Destroy_status status);
static void init_data_space(void);
static void modify_xview_objects(void);

/********************************************************************
 * MAIN: Process arguments, initialize and begin application
 */
 

int strip_chart_main(int argc, char **argv, Params *params,
		     coord_export_t *coord_shmem)

{
  xv_init(XV_INIT_ARGC_PTR_ARGV,
	  &argc,argv,
	  XV_X_ERROR_PROC, x_error_proc, NULL);

  // global struct

  MEM_zero (gd);
  gd.p = params;
  gd.cidd_mem = coord_shmem;
  
  // initialize globals, get/set defaults, establish data sources etc.
  
  init_data_space();

  // create Xview objects

  init_xview();

  // make changes to xview objects not available from DevGuide

  modify_xview_objects();
  
  // start timer

  start_timer();
  
  // Turn control over to XView.

  xv_main_loop(gd.Strip_chart_win1->win1);

  return 0;

}

/***************************************************************************
 * INIT_XVIEW : Initialize the base frame and other global objects
 */ 
 
static void init_xview()
{
 
  gd.Strip_chart_win1 =
    strip_chart_win1_objects_initialize(NULL, (Xv_opaque) NULL);
  
  notify_interpose_destroy_func(gd.Strip_chart_win1->win1,
				(Notify_func) base_win_destroy);

  gd.dpy = (Display *) xv_get(gd.Strip_chart_win1->win1,XV_DISPLAY);

}

/*****************************************************************
 * X_ERROR_PROC: Handle errors generated by the X server
 */
 
static int x_error_proc(Display *disp, XErrorEvent *event)
{
  char	text[256];
 
  XGetErrorText(disp,event->error_code,text,256);
  fprintf(stderr,"Generated X error : %s, ID:%d\n", text, 
	  (int) event->resourceid);
 
  switch(event->error_code) {
  default :
    return   XV_OK;
    break;
    
  case BadAlloc :
    return   XV_OK;
    break;
  }

}

/*****************************************************************
 * INIT_DATA_SPACE : Init all globals and set up defaults
 */

static void init_data_space(void)
{

  INSTANCE = xv_unique_key(); /* get keys for retrieving data */

  gd.variable = (int) gd.p->startup_field;

  DateTime atime(gd.p->archive_time.year,
		 gd.p->archive_time.month,
		 gd.p->archive_time.day,
		 gd.p->archive_time.hour,
		 gd.p->archive_time.min,
		 gd.p->archive_time.sec);

  gd.archive_time = atime.utime();

  gd.pixels_per_sec = (double) gd.p->window_width / gd.p->plot_period_secs;

  gd.num_sources = gd.p->stations_n;
     
  gd.data_min = 9999999.9;
  gd.data_max = -999999.9;
  
  // set up the sources

  gd.sources.clear();
  
  for(int i=0 ; i < gd.num_sources; i++) {
    SourceInfo source;
    source.station_info = &gd.p->_stations[i];
    gd.sources.push_back(source);
  }
  gd.fcat_cells = (int *) umalloc(gd.p->flight_category_n * sizeof(int));

  if (!strcmp(gd.p->station_location_file, "none")) {
    gd.stationLoc = NULL;
  } else {
    gd.stationLoc = new StationLoc;
    if (gd.stationLoc->ReadData(gd.p->station_location_file)) {
      if (gd.p->debug) {
	cerr << "WARNING - cannot read in station location file" << endl;
	cerr << "  " << gd.p->station_location_file << endl;
      }
      delete gd.stationLoc;
      gd.stationLoc = NULL;
    }
  }

}

/*****************************************************************
 * FREE : free up allocated memory
 */

void strip_chart_free()
{

  for(int i=0 ; i < gd.num_sources; i++) {
    gd.sources[i].obsArray.clear();
  }
  ufree (gd.fcat_cells);
}

/*****************************************************************
 * BASE_WIN_DESTROY: Interposition for base frame destroys
 */

static Notify_value
base_win_destroy( Notify_client   client, Destroy_status  status)
{

  switch(status) {
  case DESTROY_CLEANUP:
    
  case DESTROY_PROCESS_DEATH:
    PMU_unregister(gd.app_name, gd.p->instance);
    if (gd.cidd_mem != NULL)  {
      ushm_detach(gd.cidd_mem);
      if (ushm_nattach(gd.p->cidd_shmem_key) <= 0) {
	ushm_remove(gd.p->cidd_shmem_key);
      }
    }
    return notify_next_destroy_func(client,status);
    break;
    
  case DESTROY_CHECKING:
    return NOTIFY_DONE;
    break;
    
  case DESTROY_SAVE_YOURSELF:
    return NOTIFY_DONE;
    break;

  }

  return NOTIFY_DONE;

}

/*****************************************************************
 * MODIFY_XVIEW_OBJECTS : Modify any Xview objects that couldn't
 *    be set up in Devguide. This is primarily to avoid manually
 *    changing any *ui.c file
 */

static void modify_xview_objects()
{
  
  int i;
  Colormap cmap;
  XColor cell_def;
  XColor rgb_def;
  Menu_item mi;

  Menu menu = (Menu)
    xv_get(canvas_paint_window(gd.Strip_chart_win1->canvas1), WIN_MENU);
  
  xv_set(gd.Strip_chart_win1->win1,
         WIN_HEIGHT,gd.p->window_height,
         WIN_WIDTH,gd.p->window_width,
	 NULL);
  
  if(gd.p->show_window == false) {
    xv_set(gd.Strip_chart_win1->win1,XV_SHOW,FALSE,NULL);
  }
	  
  gd.win_height =  xv_get(gd.Strip_chart_win1->win1,WIN_HEIGHT);
  gd.win_width =  xv_get(gd.Strip_chart_win1->win1,WIN_WIDTH);
  gd.plot_height = gd.win_height - gd.p->bottom_margin;
  gd.plot_width = gd.win_width -  gd.p->right_margin;
  
  gd.canvas_xid =
    xv_get(canvas_paint_window(gd.Strip_chart_win1->canvas1),XV_XID);

  gd.back_xid =  XCreatePixmap(gd.dpy, gd.canvas_xid,
			       gd.win_width, gd.win_height,
			       DefaultDepth(gd.dpy,0));

  cmap = DefaultColormap(gd.dpy,DefaultScreen(gd.dpy));
  gd.def_gc = DefaultGC(gd.dpy, DefaultScreen(gd.dpy));

  XAllocNamedColor(gd.dpy,cmap, gd.p->foreground_color, &cell_def,&rgb_def);
  gd.fg_cell = cell_def.pixel;

  XAllocNamedColor(gd.dpy,cmap, gd.p->background_color, &cell_def,&rgb_def);
  gd.bg_cell = cell_def.pixel;

  XAllocNamedColor(gd.dpy,cmap, gd.p->now_color, &cell_def,&rgb_def);
  gd.now_cell = cell_def.pixel;
  
  for(i=0; i < gd.num_sources; i++) {
    XAllocNamedColor(gd.dpy,cmap, gd.p->_stations[i].color,
		     &cell_def,&rgb_def);
    gd.sources[i].color_cell = cell_def.pixel;
    mi = (Menu_item)
      xv_create(XV_NULL,MENUITEM,MENU_STRING,
		gd.p->_stations[i].name, NULL);
    // If Special Follow mouuse station is in the menu, set the 
    // default to this
    if (!strcmp(gd.p->_stations[i].name, "Follow mouse")) {
      xv_set(menu, MENU_DEFAULT, i + Params::PRESSURE + 1, NULL);
      gd.variable = i + Params::PRESSURE + 1;
    }
    xv_set(menu,MENU_APPEND_ITEM,mi,NULL);
  }

  // colors for flight cat
  
  for (i = 0; i < gd.p->flight_category_n; i++) {
    XAllocNamedColor(gd.dpy, cmap, gd.p->_flight_category[i].color,
		     &cell_def, &rgb_def);
    gd.fcat_cells[i] = cell_def.pixel;
  }
  
  gd.fontst = (XFontStruct *) XLoadQueryFont(gd.dpy, gd.p->font_name);
  if(gd.fontst == NULL) {
    fprintf(stderr,"Can't load font %s\n", gd.p->font_name);
    exit(-1);
  }
  gd.font  = gd.fontst->fid;
  XSetFont(gd.dpy, gd.def_gc, gd.font);

  xv_set(gd.Strip_chart_win1->canvas1, XV_HELP_DATA,
	 "strip_chart:canvas",NULL);

  set_frame_label();

  gd.new_data = true;

  check_retrieve();

}

/*****************************************************************
 * SET_FRAME_LABEL : 
 */

void set_frame_label(void)
{

  xv_set(gd.Strip_chart_win1->win1, FRAME_LABEL,
	 gd.p->window_label, NULL);
  
}

