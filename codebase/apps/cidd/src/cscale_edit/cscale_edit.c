/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
/* ** Copyright UCAR (c) 1990 - 2016                                         */
/* ** University Corporation for Atmospheric Research (UCAR)                 */
/* ** National Center for Atmospheric Research (NCAR)                        */
/* ** Boulder, Colorado, USA                                                 */
/* ** BSD licence applies - redistribution and use in source and binary      */
/* ** forms, with or without modification, are permitted provided that       */
/* ** the following conditions are met:                                      */
/* ** 1) If the software is modified to produce derivative works,            */
/* ** such modified software should be clearly marked, so as not             */
/* ** to confuse it with the version available from UCAR.                    */
/* ** 2) Redistributions of source code must retain the above copyright      */
/* ** notice, this list of conditions and the following disclaimer.          */
/* ** 3) Redistributions in binary form must reproduce the above copyright   */
/* ** notice, this list of conditions and the following disclaimer in the    */
/* ** documentation and/or other materials provided with the distribution.   */
/* ** 4) Neither the name of UCAR nor the names of its contributors,         */
/* ** if any, may be used to endorse or promote products derived from        */
/* ** this software without specific prior written permission.               */
/* ** DISCLAIMER: THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS  */
/* ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      */
/* ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    */
/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
/*
 * cscale_edit.c - Contains main() for project cscale_edit
 * This file was generated by `gxv'.
 */

#include "cscale_edit.h"
#include <stdio.h>
#include <sys/param.h>
#include <sys/types.h>
#include <xview/xview.h>
#include <xview/panel.h>
#include <xview/textsw.h>
#include <xview/xv_xrect.h>
#include "write_ui.h"
#include "read_ui.h"
#include "linear_ui.h"
#include "cscale_edit_ui.h"



/*
 * External variable declarations.
 */
cscale_edit_window1_objects	*Cscale_edit_window1;
write_popup1_objects	*Write_popup1;
read_popup1_objects	*Read_popup1;
linear_popup1_objects	*Linear_popup1;

/*
 * Instance XV_KEY_DATA key.  An instance is a set of related
 * user interface objects.  A pointer to an object's instance
 * is stored under this key in every object.  This must be a
 * global variable.
 */
Attr_attribute	INSTANCE;

/*
 * main for project cscale_edit
 */
void
main(argc, argv)
	int		argc;
	char		**argv;
{
  int border_width;
  Notify_value base_win_destroy(); /* destroy interposer */
  int i;
  Window root;  /* Root window ID of drawable */
  XColor db_val;
  XColor hw_val;
  Colormap cmap;
  char *filename;

  /*
   * Initialize XView.
   */
   xv_init(XV_INIT_ARGC_PTR_ARGV, &argc, argv, NULL);
   INSTANCE = xv_unique_key();
  
  /*
   * Initialize user interface components.
   * Do NOT edit the object initializations by hand.
   */
  Cscale_edit_window1 = cscale_edit_window1_objects_initialize(NULL, NULL);
  Write_popup1 = write_popup1_objects_initialize(NULL, NULL);
  Read_popup1 = read_popup1_objects_initialize(NULL, NULL);
  Linear_popup1 = linear_popup1_objects_initialize(NULL, NULL);
   
  notify_interpose_destroy_func(Cscale_edit_window1->window1,
                                base_win_destroy);

  /*  xv_set(Cscale_Edit_window1->canvas1, CANVAS_AUTO_SHRINK, TRUE,
             CANVAS_AUTO_EXPAND, TRUE, NULL);
  xv_set(Cscale_Edit_window1->canvas2, CANVAS_AUTO_SHRINK, TRUE,
         CANVAS_AUTO_EXPAND, TRUE, NULL);
*/

  Dpy = (Display *)xv_get(Cscale_edit_window1->window1, XV_DISPLAY);
  Gc = DefaultGC(Dpy, DefaultScreen(Dpy));

#ifdef SYNC
  XSynchronize(Dpy, TRUE);
#endif

  Canvas_xid = xv_get(canvas_paint_window(Cscale_edit_window1->canvas1),
                      XV_XID);
  XGetGeometry(Dpy, Canvas_xid, &root, &Can_x, &Can_y, &Can_width,
               &Can_height, &border_width, &Can_depth);

  if (argc == 1)
    if(get_colors("/usr/X11R6/lib/X11/rgb.txt")) {
			if(get_colors("/etc/X11/rgb.txt")) {
                          if(get_colors("/usr/share/X11/rgb.txt")) {
				fprintf(stderr,"Can't find rgb.txt in standard locations\n");
				exit(-1);
                           }
			}
	}
  else if (argc == 2)
    if(get_colors(argv[1])) {
			fprintf(stderr,"Can't find %s\n",argv[1]);
			exit(-1);
	}
  else
    {
    fprintf(stderr, "ERROR -- reading rgb.txt file unsuccessful!\n");
    fprintf(stderr, "Usage:  cscale_edit rgb_file\n");
    exit(-1);
  } /* end else argc != 1 or 2 */

  setup_color_table();  

  /*
   * Turn control over to XView.
   */
  xv_main_loop(Cscale_edit_window1->window1);
  exit(0);

} /* end main */


/*
 * SETUP_COLOR_TABLE: Read the file rgb_txt
 */

setup_color_table()
{
  int i;
  XColor db_val;
  XColor hw_val;
  Colormap cmap;

  cmap = DefaultColormap(Dpy, DefaultScreen(Dpy));
  Ngroups = Ncolors / COLOR_GROUP + 1;
  if (Ngroups < 2)
    xv_set(Cscale_edit_window1->slider1, XV_SHOW, FALSE, NULL);
  else
    xv_set(Cscale_edit_window1->slider1, XV_SHOW, TRUE, PANEL_MAX_VALUE,
           Ngroups - 1, NULL);
  First_color = 0;
  Last_color = COLOR_GROUP;
  if (Last_color > Ncolors)
    Last_color = Ncolors;

  for (i = First_color; i < Last_color; i++)
    {
    XAllocNamedColor(Dpy, cmap, Color[i], &db_val, &hw_val);
    Color_val[i] = db_val.pixel;
  } /* end for i = First_color to Last_color */
  
} /* end setup_color_table */



/* 
 * GET_COLORS: Read the file rgb.txt
 */

int get_colors(fname)
  char *fname;
{
  FILE *cfile;
  char string[128];
  char *cfield[8];
  int r, g, b, last_r, last_g, last_b;
  int i, j;
  int flag;
  int nstrings;
  char *fgets();

  /* get temp storage for character strings */
  for (i = 0; i < 8; i++)
    cfield[i] = (char *)malloc(32);

  if ((cfile = fopen(fname, "r")) == NULL)
    {
    fprintf(stderr, "Couldn't open %s\n", fname);
    return -1;
  } /* end if fopen unsuccessful */

  i = 0;

  while (((fgets(string, 128, cfile)) != NULL) && (Ncolors < MAX_COLORS))
    {
    nstrings = STRparse(string,cfield,128,8,32);

    if (nstrings < 4)
      {
      fprintf(stderr, "Error on line:\n %s \n -  too few fields\n", string);
      exit(0);
    } /* end of if nstrings < 4 */

    r = atoi(cfield[0]);
    g = atoi(cfield[1]);
    b = atoi(cfield[2]);
    flag = 1;
    /* check for duplicates, and black or white */
    if ((r == last_r) && (g == last_g) && (b == last_b))
      flag = 0;
    if (strcmp(cfield[3], "Black") == 0)
      flag = 0;
    if (strcmp(cfield[3], "black") == 0)
      flag = 0;
    if (strcmp(cfield[3], "White") == 0)
      flag = 0;
    if (strcmp(cfield[3], "white") == 0)
      flag = 0;

    if (flag)
      {
      Color[Ncolors] = malloc(32);
      
/*    Some names contain multiple strings */
      for (j = 3; j < nstrings; j++)
	{
        strcat(Color[Ncolors], cfield[j]);
        strcat(Color[Ncolors], " ");
      } /* end for j = 3 to nstrings */

/*    chop off last char */
      Color[Ncolors][strlen(Color[Ncolors]) - 1] = '\0';
      R[i] = r;
      G[i] = g;
      B[i] = b;
      i++;
      last_r = r;
      last_g = g;
      last_b = b;
      Ncolors += 1;
    } /* end if flag */

  } /* end while fgets not NULL and Ncolors < MAX_COLORS */

    fprintf(stderr, "Found %d colors \n", Ncolors);
      
  return 0;
} /* end get_colors */



/*
 * BASE_WIN_DESTROY: Interposition for base frame destroys
 */

Notify_value
base_win_destroy(client, status)
  Notify_client client;
  Destroy_status status;
{
  
  exit(0);

/* end base_win_destroy */
}
