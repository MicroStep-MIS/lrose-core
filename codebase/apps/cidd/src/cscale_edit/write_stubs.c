/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
/* ** Copyright UCAR (c) 1990 - 2016                                         */
/* ** University Corporation for Atmospheric Research (UCAR)                 */
/* ** National Center for Atmospheric Research (NCAR)                        */
/* ** Boulder, Colorado, USA                                                 */
/* ** BSD licence applies - redistribution and use in source and binary      */
/* ** forms, with or without modification, are permitted provided that       */
/* ** the following conditions are met:                                      */
/* ** 1) If the software is modified to produce derivative works,            */
/* ** such modified software should be clearly marked, so as not             */
/* ** to confuse it with the version available from UCAR.                    */
/* ** 2) Redistributions of source code must retain the above copyright      */
/* ** notice, this list of conditions and the following disclaimer.          */
/* ** 3) Redistributions in binary form must reproduce the above copyright   */
/* ** notice, this list of conditions and the following disclaimer in the    */
/* ** documentation and/or other materials provided with the distribution.   */
/* ** 4) Neither the name of UCAR nor the names of its contributors,         */
/* ** if any, may be used to endorse or promote products derived from        */
/* ** this software without specific prior written permission.               */
/* ** DISCLAIMER: THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS  */
/* ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      */
/* ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    */
/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
/*
 * write_stubs.c - Notify and event callback function stubs.
 * This file was generated by `gxv' from `write.G'.
 */

#include "cscale_edit.h"


/*
 * Done callback function for `popup1'.
 */
void
write_file_done(frame)
	Frame		frame;
{

  xv_set(frame, XV_SHOW, FALSE, NULL);
  
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

} /* end write_file_done */



/*
 * Event callback function for `popup_directory'.
 */
void
write_dir_events(item, event)
	Panel_item	item;
	Event		*event;
{
  write_popup1_objects *ip = (write_popup1_objects *)
    xv_get(item, XV_KEY_DATA, INSTANCE);
  char *value = (char *)xv_get(item, PANEL_VALUE);

  sprintf(Write_dir, "%s", value);
 
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

  panel_default_handle_event(item, event);

} /* end write_dir_events */



/*
 * Event callback function for `popup_filename'.
 */
void
write_filename_events(item, event)
	Panel_item	item;
	Event		*event;
{
  write_popup1_objects *ip = (write_popup1_objects *)
    xv_get(item, XV_KEY_DATA, INSTANCE);
  char *value = (char *)xv_get(item, PANEL_VALUE);

  sprintf(Write_filename, "%s", value);
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

  panel_default_handle_event(item, event);

} /* end write_filename_events */



/*
 * Notify callback function for `popup_format'.
 */
void
write_format_proc(item, value, event)
	Panel_item	item;
	int		value;
	Event		*event;
{
  write_popup1_objects *ip = (write_popup1_objects *)
    xv_get(item, XV_KEY_DATA, INSTANCE);
  
  Write_format = value;
  
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

} /* end write_format_proc */



/*
 * Notify callback function for `popup_write_button'.
 */
void
write_proc(item, event)
	Panel_item	item;
	Event		*event;
{
  write_popup1_objects *ip = (write_popup1_objects *)
    xv_get(item, XV_KEY_DATA, INSTANCE);
  FILE * outfile;
  char filename[128];
  char string[128];
  char name[10];
  char colorlabel[128];
  int i;
  struct tm *time_struct;
  time_t now_time;
  long year, mon, day, hour, min, sec;

  /* 
   * check format value and write appropriate files
   */
  sprintf(filename, "%s/%s", Write_dir, Write_filename);

  if ((outfile = fopen(filename, "w")) == NULL)
    { /* fopen failed */
    sprintf(string, "Status: Couldn't open '%s.'\n", Write_filename);
    xv_set(Cscale_edit_window1->status_message, PANEL_LABEL_STRING,
           string, NULL);
  } /* fopen failed */
  else
    { /* fopen successful */
    now_time = time(&now_time);
    time_struct = localtime(&now_time);
    year = time_struct->tm_year + 1900;
    mon = time_struct->tm_mon + 1;
    day = time_struct->tm_mday;
    hour = time_struct->tm_hour;
    min = time_struct->tm_min;
    sec = time_struct->tm_sec;
    sprintf(name, "%s", getenv("USER"));

    if (Write_format == 1)
      { /* RGB */
      fprintf(outfile, "# RGB %s\n", Write_filename);
      fprintf(outfile, "# %s \t%d/%d/%d %d:%d:%d\n", name, mon, day, year,
              hour, min, sec);
      fprintf(outfile, "# RED    GREEN   BLUE    MIN     MAX      COLOR LABEL\n");

      for (i = Num_fields; i > 0; i--)
        {
        sprintf(colorlabel, "!%s", Color_struct[i-1].label);
        fprintf(outfile, "%d \t%d \t%d \t%lg \t%lg \t%s\n",
                Color_struct[i-1].red, Color_struct[i-1].green,
                Color_struct[i-1].blue, Color_struct[i-1].min_val,
                Color_struct[i-1].max_val, colorlabel);
      } /* end for i = Num_fields to 0 */

      fclose(outfile);
      sprintf(string, "%s", "Status: successfully written");
      xv_set(Cscale_edit_window1->status_message, PANEL_LABEL_STRING,
             string, NULL);
    } /* end RGB */

    else if (Write_format == 0)
      { /* NAME */
      fprintf(outfile, "# NAME %s\n", Write_filename);
      fprintf(outfile, "# %s \t%d/%d/%d %d:%d:%d\n", name, mon, day, year,
              hour, min, sec);
      fprintf(outfile, "# MIN    MAX    NAME        COLOR LABEL\n");

      for (i = Num_fields; i > 0; i--)
        {
        sprintf(colorlabel, "!%s", Color_struct[i-1].label);
        fprintf(outfile, "%lg \t%lg \t%s \t%s\n",
                Color_struct[i-1].min_val, Color_struct[i-1].max_val,
                Color_struct[i-1].name, colorlabel);
      } /* end for i = Num_fields to 0 */

      fclose(outfile);
      sprintf(string, "%s", "Status: successfully written");
      xv_set(Cscale_edit_window1->status_message, PANEL_LABEL_STRING,
             string, NULL);
    } /* end else NAME */

    else if (Write_format == 2)
      { /* HEXVAL */
      fprintf(outfile, "# HEXVAL %s\n", Write_filename);
      fprintf(outfile, "# %s \t%d/%d/%d %d:%d:%d\n", name, mon, day, year,
              hour, min, sec);
      fprintf(outfile, "# MIN    MAX    HEXVAL           COLOR LABEL\n");

      for (i = Num_fields; i > 0; i--)
        {
        sprintf(colorlabel, "!%s", Color_struct[i-1].label);
        fprintf(outfile, "%lg \t%lg \t%s \t%s\n",
                Color_struct[i-1].min_val, Color_struct[i-1].max_val,
                Color_struct[i-1].hexval, colorlabel);
      } /* end i = Num_fields to 0 */

      fclose(outfile);
      sprintf(string, "%s", "Status: successfully written");
      xv_set(Cscale_edit_window1->status_message, PANEL_LABEL_STRING,
             string, NULL);
    } /* end else HEXVAL */

    else
      { /* Write_format not equal to 0, 1, or 2 */
      sprintf(string, "%s", "ERROR - invalid write format!");
      xv_set(Cscale_edit_window1->status_message, PANEL_LABEL_STRING,
             string, NULL);
    } /* end else Write_format not equal to 0,1, or 2 */

  } /* end of else fopen successful */

	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

} /* end write_proc */
