/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
/* ** Copyright UCAR (c) 1990 - 2016                                         */
/* ** University Corporation for Atmospheric Research (UCAR)                 */
/* ** National Center for Atmospheric Research (NCAR)                        */
/* ** Boulder, Colorado, USA                                                 */
/* ** BSD licence applies - redistribution and use in source and binary      */
/* ** forms, with or without modification, are permitted provided that       */
/* ** the following conditions are met:                                      */
/* ** 1) If the software is modified to produce derivative works,            */
/* ** such modified software should be clearly marked, so as not             */
/* ** to confuse it with the version available from UCAR.                    */
/* ** 2) Redistributions of source code must retain the above copyright      */
/* ** notice, this list of conditions and the following disclaimer.          */
/* ** 3) Redistributions in binary form must reproduce the above copyright   */
/* ** notice, this list of conditions and the following disclaimer in the    */
/* ** documentation and/or other materials provided with the distribution.   */
/* ** 4) Neither the name of UCAR nor the names of its contributors,         */
/* ** if any, may be used to endorse or promote products derived from        */
/* ** this software without specific prior written permission.               */
/* ** DISCLAIMER: THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS  */
/* ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      */
/* ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    */
/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
/*
 * read_stubs.c - Notify and event callback function stubs.
 * This file was generated by `gxv' from `read.G'.
 */

#include "cscale_edit.h"



/*
 * Done callback function for `popup1'.
 */
void
read_file_done(frame)
  Frame	   frame;
{
  xv_set(frame, XV_SHOW, FALSE, NULL);

	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

} /* end read_file_done */



/*
 * Event callback function for `read_directory'.
 */
void
read_dir_events(item, event)
	Panel_item	item;
	Event		*event;
{
  read_popup1_objects *ip = (read_popup1_objects *)
    xv_get(item, XV_KEY_DATA, INSTANCE);
	
  char *value = (char *) xv_get(item, PANEL_VALUE);
  sprintf(Read_dir, "%s", value);
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

  panel_default_handle_event(item, event);

} /* end read_dir_events */



/*
 * Event callback function for `read_filename'.
 */
void
read_filename_events(item, event)
	Panel_item	item;
	Event		*event;
{
  read_popup1_objects *ip = (read_popup1_objects *)
    xv_get(item, XV_KEY_DATA, INSTANCE);
  char *value = (char *) xv_get(item, PANEL_VALUE);

  sprintf(Read_filename, "%s", value);
  sprintf(Write_filename, "%s", value);
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

  panel_default_handle_event(item, event);

} /* end read_filename_events */



/*
 * Notify callback function for `read_format'.
 */
void
read_format_proc(item, value, event)
	Panel_item	item;
	int		value;
	Event		*event;
{
  read_popup1_objects *ip = (read_popup1_objects *)
    xv_get(item, XV_KEY_DATA, INSTANCE);
	
  Read_format = value;
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

} /* end read_format_proc */



/*
 * Notify callback function for `read_button'.
 */
void
read_button_proc(item, event)
	Panel_item	item;
	Event		*event;
{
  read_popup1_objects *ip = (read_popup1_objects *)
    xv_get(item, XV_KEY_DATA, INSTANCE);
  FILE *infile;
  char filename[128];
  char string[128];
  char line[BUFSIZ];
  char *colorname;
  char *colorlabel;
  long ilevel = 0;
  double start_val, end_val;
  int i, j;
  int parse_color_scale_line();
  int num, flag, value;
  int red, green, blue;
  double min, max;
  XColor db_val;
  XColor hw_val;
  XColor xc_struct;
  Colormap cmap;
       
  /*
   * check format value and read appropriate files
   */        
  sprintf(filename, "%s/%s", Read_dir, Read_filename);

  if ((infile = fopen(filename, "r")) == NULL)
    { /* if fopen fails */
    sprintf(string, "Status: Couldn't open '%s.'\n", Read_filename);
    xv_set(Cscale_edit_window1->status_message, PANEL_LABEL_STRING,
           string, NULL);
  } /* if fopen fails */
  else
    { /* fopen successful */
    cmap = DefaultColormap(Dpy, DefaultScreen(Dpy));

    /* clear fields before reading in new file */
    for (i = 0; i < Num_fields; i++)
      {
      Color_struct[i].max_val = 0;
      Color_struct[i].min_val = 0;
      strcpy(Color_struct[i].hexval, " ");
      strcpy(Color_struct[i].name, " ");
      strcpy(Color_struct[i].label, " ");
      Color_struct[i].red = 0;
      Color_struct[i].green = 0;
      Color_struct[i].blue = 0;
      Color_struct[i].pix_val = 0;
    } /* end for i = 0 to Num_fields */

    Num_fields = 1;
    xv_set(Cscale_edit_window1->fields, PANEL_VALUE, Num_fields, NULL);
    xv_set(Cscale_edit_window1->max, PANEL_VALUE, 0, NULL);
    xv_set(Cscale_edit_window1->min, PANEL_VALUE, 0, NULL);
    xv_set(Cscale_edit_window1->color_label, PANEL_VALUE, " ", NULL);
    colorize_can2();
    can2_draw_text();
    can2_draw_rect();
    highlight_field();

    if (Read_format == 1)
      { /* RBG */
      while (fgets(line, BUFSIZ, infile) != NULL)
        if(parse_rgb_scale(line, &red, &green, &blue, &min, &max, &colorlabel)
           == SUCCESS)
          Num_fields++;

      Num_fields -= 1;
      xv_set(Cscale_edit_window1->fields, PANEL_VALUE, Num_fields, NULL);

      if (Num_fields == 0)
	{ /* Num_fields == 0 */
        sprintf(string, "%s", "Status: ERROR - 0 fields invalid!\n"); 
        xv_set(Cscale_edit_window1->status_message, PANEL_LABEL_STRING,
               string, NULL);
      } /* end if Num_fields == 0 */

      fseek(infile, 0L, 0);
      ilevel = Num_fields - 1;

      while(fgets(line, BUFSIZ, infile) != NULL)
	{ /* fgets is not NULL */

        if(parse_rgb_scale(line, &red, &green, &blue, &min, &max, &colorlabel)
           == SUCCESS)
	  { /* parse_rgb_scale successful */
          Color_struct[ilevel].red = red;
          Color_struct[ilevel].green = green;
          Color_struct[ilevel].blue = blue;
          Color_struct[ilevel].max_val = max;
          Color_struct[ilevel].min_val = min;
          sprintf(Color_struct[ilevel].hexval, "#%.4x%.4x%.4x",
                  (red*256), (green*256), (blue*256));
          sprintf(Color_struct[ilevel].name, "#%.4x%.4x%.4x",
                  (red*256), (green*256), (blue*256));
          for (i = 1; i < strlen(colorlabel); i++)
            colorlabel[i-1] = colorlabel[i];
          colorlabel[i-1] = '\0';
          strcpy(Color_struct[ilevel].label, colorlabel);
          ilevel--;
	} /* end if parse_rgb_scale successful */

      } /* end while fgets is not NULL */

      fclose(infile);
/*      XFreeColors(Dpy, cmap, &(Color_val[100]), Num_fields, 0L); */

      for (i = 0; i < Num_fields; i++)
        {
        XParseColor(Dpy,cmap, Color_struct[i].name, &xc_struct);
        XAllocColor(Dpy, cmap, &xc_struct);
        Color_val[100+i] = xc_struct.pixel;
        Color_struct[i].pix_val = xc_struct.pixel;
      } /* end for i = 0 to Num_fields */

      colorize_can2();
      can2_draw_text();
      can2_draw_rect();
      highlight_field();
      sprintf(string, "%s", "Status: successfully read");
      xv_set(Cscale_edit_window1->status_message, PANEL_LABEL_STRING,
             string, NULL);
    } /* end RBG */

    else if (Read_format == 0 || Read_format == 2)
      { /* NAME & HEXVAL */
      while(fgets(line, BUFSIZ, infile) != NULL)
        if (parse_color_scale_line(line, &start_val, &end_val, &colorname,
            &colorlabel) == SUCCESS)
          Num_fields++;

      Num_fields -= 1;
      xv_set(Cscale_edit_window1->fields, PANEL_VALUE, Num_fields, NULL);

      if (Num_fields == 0)
        {
        sprintf(string, "%s", "Status: ERROR - 0 fields invalid!\n");
        xv_set(Cscale_edit_window1->status_message, PANEL_LABEL_STRING,
               string, NULL);
      } /* end if Num_fields == 0 */

      fseek(infile, 0L, 0);
      ilevel = Num_fields - 1;

      while (fgets(line, BUFSIZ, infile) != NULL)
        {

        if (parse_color_scale_line(line, &start_val, &end_val, &colorname,
            &colorlabel) == SUCCESS)
          {
          Color_struct[ilevel].min_val = start_val;
          Color_struct[ilevel].max_val = end_val;
          strcpy(Color_struct[ilevel].hexval, colorname);
          strcpy(Color_struct[ilevel].name, colorname);
	  if(strlen(colorlabel) > 1) {
            for (i = 1; i < strlen(colorlabel); i++) colorlabel[i-1] = colorlabel[i];
            colorlabel[i-1] = '\0';
            strcpy(Color_struct[ilevel].label, colorlabel);
	  }
          ilevel--;
        } /* end if parse_color_scale_line is successful */

      } /* while fgets is not NULL */

      fclose(infile);
/*      XFreeColors(Dpy, cmap, &(Color_val[100]), Num_fields, 0L);*/

      for (i = 0; i < Num_fields; i++)
        {
        XParseColor(Dpy, cmap, Color_struct[i].name, &xc_struct);
        XAllocColor(Dpy, cmap, &xc_struct);
        Color_val[100+i] = xc_struct.pixel;
        Color_struct[i].pix_val = xc_struct.pixel;
        Color_struct[i].red = xc_struct.red;
        Color_struct[i].green = xc_struct.green;
        Color_struct[i].blue = xc_struct.blue;
      } /* end for i = 0 to Num_fields */

      colorize_can2();
      can2_draw_text();
      can2_draw_rect();
      highlight_field();
      sprintf(string, "%s", "Status: successfully read");
      xv_set(Cscale_edit_window1->status_message, PANEL_LABEL_STRING,
             string, NULL);
    } /* end else NAME & HEXVAL */
 
    else
      {
      sprintf(string, "%s", "Status: ERROR - invalid read format!");
      xv_set(Cscale_edit_window1->status_message, PANEL_LABEL_STRING,
             string, NULL);
    } /* end else Read_format */

  } /* end else fopen successful */

	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

} /* end read_button_proc */



/* 
 * parse_color_scale_line
 */
int
parse_color_scale_line(line, start_val, end_val, colorname, colorlabel)
     char *line;
     double *start_val, *end_val;
     char **colorname;
     char **colorlabel;
{
  char *start_pt, *end_pt;
  int wrong_format;
  int i;
  double start, end;
  char *name;
  char *label;

  wrong_format = FALSE;
  line[strlen(line)-1] = '\0';

  /* get min value */
  errno = 0;
  start_pt = line;
  start = strtod(start_pt, &end_pt);
  if (errno != 0 || start_pt == end_pt)
    wrong_format = TRUE;

  /* get max value */
  errno = 0;
  start_pt = end_pt;
  end = strtod(start_pt, &end_pt);
  if (errno != 0 || start_pt == end_pt)
    wrong_format = TRUE;

  /* get entire string with colorname and colorlabel */
  start_pt = end_pt;
  while(*start_pt == ' ' || *start_pt == '\t')
    start_pt++;
  if (*start_pt == '\0')
    wrong_format = TRUE;
  end_pt = start_pt + strlen(start_pt) - 1;

  if (wrong_format == FALSE)
    {
    while (*end_pt == ' ' || *end_pt == '\t')
      {
      *end_pt = '\0';
      end_pt--;
    } /* end while *end_pt == ... */

    name = start_pt;
    i = 0;
    /* separate colorname and colorlabel */
    while (*start_pt != '!' && *start_pt != '\0')
      {
      start_pt++;
      i++;
    } /* end while ... */
    i--;
    if (*start_pt == '!')
      {
      label = start_pt;
      name[i] = '\0';
      i--;
      while (name[i] == ' ' || name[i] == '\t')
	{
        name[i] = '\0';
        i--;
      } /* end while ... */
    } /* end if *start_pt == '!' */
    else
      label = "\0\0\0";

  } /* end if wrong_format == FALSE */


  if (wrong_format == TRUE)
    return (FAILURE);
  else
    {
    *colorlabel = label;
    *colorname = name;
    *start_val = start;
    *end_val = end;
    return (SUCCESS);
  } /* end else wrong_format == FALSE */

} /* end parse_color_scale_line */



/*
 * parse_rgb_scale
 */
int
parse_rgb_scale(line, red, green, blue, min, max, colorlabel)
      char *line;
      int *red, *green, *blue;
      double *min, *max;
      char **colorlabel;
{
  char *start_pt, *end_pt;
  int wrong_format;
  int ired, igreen, iblue;
  double imin, imax;
  char *label;

  wrong_format =  FALSE;
  line[strlen(line)-1] = '\0';

  /* get red value */
  errno = 0;
  start_pt = line;
  ired = strtod(start_pt, &end_pt);
  if (errno != 0 || start_pt == end_pt)
    wrong_format = TRUE;

  /* get green value */
  errno = 0;
  start_pt = end_pt;
  igreen = strtod(start_pt, &end_pt);
  if (errno != 0 || start_pt == end_pt)
    wrong_format = TRUE;

  /* get blue value */
  errno = 0;
  start_pt = end_pt;
  iblue = strtod(start_pt, &end_pt);
  if (errno != 0 || start_pt == end_pt)
    wrong_format = TRUE;

  /* get min value */
  errno = 0;
  start_pt = end_pt;
  imin = strtod(start_pt, &end_pt);
  if (errno != 0 || start_pt == end_pt)
    wrong_format = TRUE;

  /* get max value */
  errno = 0;
  start_pt = end_pt;
  imax = strtod(start_pt, &end_pt);
  if (errno != 0 || start_pt == end_pt)
    wrong_format = TRUE;

  /* get colorlabel */
  start_pt = end_pt;
  if (start_pt != NULL)
    {
    while (*start_pt == ' ' || *start_pt == '\t')
      start_pt++;
    if (*start_pt != '\0')
      {
      end_pt = start_pt + strlen(start_pt) - 1;
      while (*end_pt == ' ' || *end_pt == '\t')
        {
        *end_pt = '\0';
        end_pt--;
      } /* end while *end_pt == ... */
    } /* end if *start_pt not '\0' */
  label = start_pt;  
  } /* end if start_pt not NULL */
  else
    label = "\0";

  if (wrong_format == TRUE)
    return (FAILURE);
  else
    {
    *red = ired;
    *green = igreen;
    *blue = iblue;
    *min = imin;
    *max = imax;
    *colorlabel = label;
    return (SUCCESS);
  } /* end if wrong_format == FALSE */

} /* end parse_rgb_scale */
