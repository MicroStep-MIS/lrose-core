/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
/* ** Copyright UCAR (c) 1990 - 2016                                         */
/* ** University Corporation for Atmospheric Research (UCAR)                 */
/* ** National Center for Atmospheric Research (NCAR)                        */
/* ** Boulder, Colorado, USA                                                 */
/* ** BSD licence applies - redistribution and use in source and binary      */
/* ** forms, with or without modification, are permitted provided that       */
/* ** the following conditions are met:                                      */
/* ** 1) If the software is modified to produce derivative works,            */
/* ** such modified software should be clearly marked, so as not             */
/* ** to confuse it with the version available from UCAR.                    */
/* ** 2) Redistributions of source code must retain the above copyright      */
/* ** notice, this list of conditions and the following disclaimer.          */
/* ** 3) Redistributions in binary form must reproduce the above copyright   */
/* ** notice, this list of conditions and the following disclaimer in the    */
/* ** documentation and/or other materials provided with the distribution.   */
/* ** 4) Neither the name of UCAR nor the names of its contributors,         */
/* ** if any, may be used to endorse or promote products derived from        */
/* ** this software without specific prior written permission.               */
/* ** DISCLAIMER: THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS  */
/* ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      */
/* ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    */
/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
/*
 * cscale_edit_stubs.c - Notify and event callback function stubs.
 * This file was generated by `gxv' from `cscale_edit.G'.
 */

#include "cscale_edit.h"
#include <stdio.h>
#include <sys/param.h>
#include <sys/types.h>
#include <xview/xview.h>
#include <xview/panel.h>
#include <xview/textsw.h>
#include <xview/xv_xrect.h>
#include "cscale_edit_ui.h"


#ifdef MAIN


#endif



/*
 * Global object definitions.
 */
cscale_edit_window1_objects	*Cscale_edit_window1;
/*
 * Instance XV_KEY_DATA key.  An instance is a set of related
 * user interface objects.  A pointer to an object's instance
 * is stored under this key in every object.  This must be a
 * global variable.
 */
Attr_attribute	INSTANCE;

long Wdir_flag = 0;
long Rdir_flag = 0;


/*
 * Event callback function for `window1'.
 */
Notify_value
win_event_proc(win, event, arg, type)
	Xv_window	win;
	Event		*event;
	Notify_arg	arg;
	Notify_event_type type;
{
  int i;
  Window root;  /* root window ID of drawable */
  int border_width;
  int border2_width;
  cscale_edit_window1_objects *ip =
    (cscale_edit_window1_objects *) xv_get(win, XV_KEY_DATA, INSTANCE);
  
  switch (event_action(event))
    {
    case  WIN_RESIZE:
      Canvas_xid = xv_get(canvas_paint_window(Cscale_edit_window1->canvas1),
                          XV_XID);
      XGetGeometry(Dpy, Canvas_xid, &root, &Can_x, &Can_y, &Can_width,
                   &Can_height, &border_width, &Can_depth);
      Canvas2_xid = xv_get(canvas_paint_window(Cscale_edit_window1->canvas1),
                           XV_XID);
      XGetGeometry(Dpy, Canvas2_xid, &root, &Can2_x, &Can2_y, &Can2_width,
                   &Can2_height, &border2_width, &Can2_depth);
      break;
  } /* end switch */
  
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

  return notify_next_event_func(win, (Notify_event) event, arg, type);

} /* end win_event_proc */



/*
 * Notify callback function for `read_file_button'.
 */
void
read_file(item, event)
	Panel_item	item;
	Event		*event;
{
  cscale_edit_window1_objects *ip =
    (cscale_edit_window1_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
  
  if (Rdir_flag == 0)
    {
    sprintf(Read_dir, "%s", getenv("PWD"));
    Rdir_flag = 1;
  } /* end if Rdir_flag == 0 */

  xv_set(Read_popup1->read_directory, PANEL_VALUE, Read_dir, NULL);
  xv_set(Read_popup1->popup1, XV_SHOW, TRUE, NULL);
  xv_set(Cscale_edit_window1->fields, PANEL_VALUE, 1, NULL);
  
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

} /* end read_file */



/*
 * Notify callback function for `delete_button'.
 */
void
del_field_proc(item, event)
	Panel_item	item;
	Event		*event;
{
  cscale_edit_window1_objects *ip =
    (cscale_edit_window1_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
  int i;

  xv_set(Cscale_edit_window1->status_message, PANEL_LABEL_STRING,
         "Status:", NULL);

  if (Num_fields > 1)
    {  
    for (i = (Field-1); i < Num_fields; i++)
      Color_struct[i] = Color_struct[i+1];

    Num_fields -= 1;
    xv_set(Cscale_edit_window1->fields, PANEL_VALUE, Num_fields, NULL);
    colorize_can2();
    can2_draw_text();
    can2_draw_rect();
    highlight_field();
  } /* end if Num_fields > 1 */

	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

} /* end del_field_proc */



/*
 * Notify callback function for `value_setting'.
 */
void
value_proc(item, event)
	Panel_item	item;
	Event		*event;
{
  cscale_edit_window1_objects *ip =
    (cscale_edit_window1_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);

  xv_set(Linear_popup1->fields, PANEL_VALUE, Num_fields, NULL);  
  xv_set(Linear_popup1->popup1, XV_SHOW, TRUE, NULL);
  xv_set(Linear_popup1->color_scale_min, PANEL_LABEL_STRING,
         "Color Value 1 Min", NULL);
  xv_set(Linear_popup1->color_scale_max, PANEL_LABEL_STRING,
         "Color Value   Max", NULL);
  Lin_fields = Num_fields;

	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

} /* end value_proc */



/*
 * Notify callback function for `clear_button'.
 */

void
clear_button_proc(item, event)
	Panel_item	item;
	Event		*event;
{
  cscale_edit_window1_objects *ip =
    (cscale_edit_window1_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
  int i;
  
  xv_set(Cscale_edit_window1->status_message, PANEL_LABEL_STRING,
         "Status:", NULL);

  for (i = 0; i < Num_fields; i++)
    {
    Color_struct[i].max_val = 0;
    Color_struct[i].min_val = 0;
    strcpy(Color_struct[i].hexval, " ");
    strcpy(Color_struct[i].name, " ");
    strcpy(Color_struct[i].label, " ");
    Color_struct[i].red = 255;
    Color_struct[i].green = 255;
    Color_struct[i].blue = 255;
    Color_struct[i].pix_val = 0;
  } /* end for i = 0 to Num_fields */

  Num_fields = 1;
  xv_set(Cscale_edit_window1->fields, PANEL_VALUE, Num_fields, NULL);
  xv_set(Cscale_edit_window1->max, PANEL_VALUE, 0, NULL);
  xv_set(Cscale_edit_window1->min, PANEL_VALUE, 0, NULL);
  xv_set(Cscale_edit_window1->color_label, PANEL_VALUE, " ", NULL);
  colorize_can2();
  can2_draw_text();
  can2_draw_rect();
  highlight_field();  

	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

} /* end clear_button_proc */



/*
 * Notify callback function for `quit_button'.
 */
void
quit_proc(item, event)
	Panel_item	item;
	Event		*event;
{
  cscale_edit_window1_objects *ip =
    (cscale_edit_window1_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
  
  xv_destroy_safe(ip->window1);
  exit(0);
  
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

} /* end quit_proc */



/*
 * Notify callback function for `write_file_button'.
 */
void
write_file(item, event)
	Panel_item	item;
	Event		*event;
{
  cscale_edit_window1_objects *ip =
    (cscale_edit_window1_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
  
  if (Wdir_flag == 0)
    {
    sprintf(Write_dir, "%s", getenv("PWD"));
    Wdir_flag = 1;
  } /* end if Wdir_flag == 0 */

  if (Rdir_flag == 1)
    {
    sprintf(Write_dir, "%s", Read_dir);
    Wdir_flag = 1;
  } /* end if Wdir_flag == 1 */

  xv_set(Write_popup1->popup_directory, PANEL_VALUE, Write_dir, NULL);
  xv_set(Write_popup1->popup_filename, PANEL_VALUE, Write_filename, NULL);
  xv_set(Write_popup1->popup1, XV_SHOW, TRUE, NULL);
  
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

} /* end write_file */



/*
 * Notify callback function for `sort_button'.
 */
void
sort_proc(item, event)
	Panel_item	item;
	Event		*event;
{
  double red, green, blue;
  double rweight, gweight, bweight;
  double rsatweight, gsatweight, bsatweight;
  double intenweight;
  int flag, i, j;
  int v_class;
  Colormap cmap;
  XColor xc_struct;
  cscale_edit_window1_objects *ip =
    (cscale_edit_window1_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);

  v_class = xv_get(ip->window1,XV_VISUAL_CLASS);

  xv_set(Cscale_edit_window1->status_message, PANEL_LABEL_STRING,
         "Status:", NULL);
  cmap = DefaultColormap(Dpy, DefaultScreen(Dpy));
  Sort_list = (SORT_STRUCT **)malloc(Ncolors*sizeof(SORT_STRUCT *));
  for (i = 0; i < Ncolors; i++)
    Sort_list[i] = (SORT_STRUCT *)malloc(sizeof(SORT_STRUCT));
  red = (double)Color_struct[Field-1].red;
  green = (double)Color_struct[Field-1].green;
  blue = (double)Color_struct[Field-1].blue;
  rweight = 1.0;
  gweight = 1.0;
  bweight = 1.0;
  rsatweight = 1.0;
  gsatweight = 1.0;
  bsatweight = 1.0;
  intenweight = 1.0;
  if (red == 255)
    rsatweight = (green + blue) / red;
  if (green == 255)
    gsatweight = (red + blue) / green;
  if (blue == 255)
    bsatweight = (red + green) / blue;
  
  for (i = 0; i < Ncolors; i++)
    {
    Sort_list[i]->red = R[i];
    Sort_list[i]->green = G[i];
    Sort_list[i]->blue = B[i];
    Sort_list[i]->index = i;
    Sort_list[i]->delta = (fabs(red - R[i]) * rweight * rsatweight +
                           fabs(green - G[i]) * gweight * gsatweight +
                           fabs(blue - B[i]) * bweight * bsatweight +
                           fabs((red + green + blue) - (R[i] + G[i] + B[i]))
                           * intenweight);
    strcpy(Sort_list[i]->name, Color[i]);
  } /* end for i = 0 to Ncolors */
  
  /*
   * perform sorting of deltas 
   */
  qsort(Sort_list, Ncolors, sizeof(SORT_STRUCT *), sort_func);
  
  for (i = First_color; i < Last_color; i++)
    {
    flag = 1;
    for (j = 0; j < Num_fields; j++)
      if (Color_struct[j].pix_val == Color_val[i])
        flag = 0;
     if (flag == 1 && v_class == PseudoColor) XFreeColors(Dpy, cmap, &(Color_val[i]), 1, 0L);
  } /* end for i = First_color to Last_color */
  
  for (i = First_color; i < Last_color; i++)
    {
    XParseColor(Dpy, cmap, Sort_list[i-First_color]->name, &xc_struct);
    XAllocColor(Dpy, cmap, &xc_struct);
    Color_val[i] = xc_struct.pixel;
    Sort_list[i]->red = xc_struct.red / 256;
    Sort_list[i]->green = xc_struct.green / 256;
    Sort_list[i]->blue = xc_struct.blue / 256;
    Sortednames[i] = malloc(32);
    strcpy(Sortednames[i], Sort_list[i-First_color]->name);
  } /* end for i = First_color to Last_color */

  Sort_flag = TRUE;
  repaint_canvas();
  
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

} /* end sort_proc */



/*
 * Notify callback function for `fields'.
 */
Panel_setting
fields_proc(item, event)
	Panel_item	item;
	Event		*event;
{
  cscale_edit_window1_objects *ip =
    (cscale_edit_window1_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
  int	value = (int) xv_get(item, PANEL_VALUE);
  int i, old_val;

  old_val = Num_fields;
  Num_fields = value;

  if (old_val < Num_fields)
    {
    for (i = Num_fields; i > 0; i--)
      Color_struct[i] = Color_struct[i-1];
    Color_struct[0].pix_val = 0;
    strcpy(Color_struct[0].name, " ");
    strcpy(Color_struct[0].hexval, " ");
    strcpy(Color_struct[0].label, " ");
    Color_struct[0].red = 255;
    Color_struct[0].green = 255;
    Color_struct[0].blue = 255;
    Color_struct[0].max_val = 0;
    Color_struct[0].min_val = 0;
  } /* end if old_val < Num_fields */
  else if (old_val > Num_fields)
    {
    for (i = 0; i < Num_fields; i++)
      Color_struct[i] = Color_struct[i+1];
  } /* end else old_val > Num_fields */

  colorize_can2();
  can2_draw_text();
  can2_draw_rect();
  highlight_field();
  
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

  return panel_text_notify(item, event);

} /* end fields_proc */



/*
 * Notify callback function for `max'.
 */
Panel_setting
max_proc(item, event)
	Panel_item	item;
	Event		*event;
{
  cscale_edit_window1_objects *ip =
    (cscale_edit_window1_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
  char *value = (char *) xv_get(item, PANEL_VALUE);
  char *endptr;

  Color_struct[Field-1].max_val = strtod(value, &endptr);
  colorize_can2();
  can2_draw_text();
  can2_draw_rect();
  highlight_field();
  
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

  return panel_text_notify(item, event);

} /* end max_proc */



/*
 * Notify callback function for `min'.
 */
Panel_setting
min_proc(item, event)
	Panel_item	item;
	Event		*event;
{
  cscale_edit_window1_objects *ip =
    (cscale_edit_window1_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
  char *value = (char *) xv_get(item, PANEL_VALUE);
  char *endptr;

  Color_struct[Field-1].min_val = strtod(value, &endptr);
  Color_struct[Field].max_val = Color_struct[Field-1].min_val;
  colorize_can2();
  can2_draw_text();
  can2_draw_rect();
  highlight_field();
  
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

  return panel_text_notify(item, event);

} /*end min_proc */



/*
 * Notify callback function for `slider1'.
 */
void
slide_proc(item, value, event)
	Panel_item	item;
	int		value;
	Event		*event;
{
  int i, j, flag;
  int v_class;
  XColor db_val;
  XColor hw_val;
  Colormap cmap;
  cscale_edit_window1_objects *ip =
    (cscale_edit_window1_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
  
  cmap = DefaultColormap(Dpy, DefaultScreen(Dpy));

  v_class = xv_get(ip->window1,XV_VISUAL_CLASS);

  for (i = First_color; i < Last_color; i++)
    {
    flag = 1;
    for ( j = 0; j < Num_fields; j++)
      if (Color_val[i] == Color_struct[j].pix_val)
        flag = 0;
     if (flag == 1 && v_class == PseudoColor) XFreeColors(Dpy, cmap, &(Color_val[i]), 1, 0L);
  } /* for i = First_color to Last_color */

  First_color = value * COLOR_GROUP;
  Last_color = (value + 1) * COLOR_GROUP;
  if (Last_color > Ncolors)
    Last_color = Ncolors;

  for (i = First_color; i < Last_color; i++)
    {
    XAllocNamedColor(Dpy, cmap, Color[i], &db_val, &hw_val);
    Color_val[i] = db_val.pixel;
  } /* for i = First_color to Last_color */

  Sort_flag = FALSE;
  repaint_canvas();
  
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

} /* end slide_proc */



/*
 * Event callback function for `canvas1'.
 */
Notify_value
can_event_proc(win, event, arg, type)
	Xv_window	win;
	Event		*event;
	Notify_arg	arg;
	Notify_event_type type;
{
  int x, y;
  int clr;
  int n;
  int xindex, yindex, xsize, ysize, isize;
  char string[128];
  double size, sqrt();
  cscale_edit_window1_objects *ip = (cscale_edit_window1_objects *)
    xv_get(xv_get(win, CANVAS_PAINT_CANVAS_WINDOW), XV_KEY_DATA, INSTANCE);
  
  if (event_action(event) == ACTION_DRAG_LOAD)
    {
    char name[MAXPATHLEN];
    if (gdd_get_drag_name(win, name) != -1)
      fprintf(stderr, "xcolor: can_event_proc: load %s\n", name);
  } /* end if event_action(event) == ACTION_DRAG_LOAD */
  else if (event_action(event) == ACTION_MENU && event_is_down(event))
    {
    Menu menu = (Menu)xv_get(win, WIN_MENU);
    if (menu)
      menu_show(menu, win, event, 0);
  } /* end if event_action(event) == ... */

  if (event_id(event) == MS_LEFT && event_is_down(event))
    {
    x = event_x(event);
    y = event_y(event);
    n = Last_color - First_color;
    size = sqrt((double)n);
    isize = size;
    xsize = (Can_width / isize) + 1;
    if (size > (double)isize)
      ysize = (Can_height / (isize + 1)) + 1;
    else
      ysize = (Can_height / isize) + 1;
    xindex = x / xsize;
    yindex = y / ysize;
    clr = (yindex * isize) + xindex + First_color;
    if (Field <= 1)
      Field = 1;

    if (Sort_flag == TRUE)
      {
      sprintf(string, "Color is: %s", Sortednames[clr]);
      xv_set(Cscale_edit_window1->color_message, PANEL_LABEL_STRING,
             string, NULL);
      Color_struct[Field-1].red = Sort_list[clr]->red;
      Color_struct[Field-1].green = Sort_list[clr]->green;
      Color_struct[Field-1].blue = Sort_list[clr]->blue;
      Color_struct[Field-1].pix_val = Color_val[clr];
      strcpy(Color_struct[Field-1].name, Sortednames[clr]);
    } /* end if Sort_flag == TRUE */

  else
    {
      sprintf(string, "Color is: %s", Color[clr]);
      xv_set(Cscale_edit_window1->color_message, PANEL_LABEL_STRING,
             string, NULL);
      strcpy(Color_struct[Field-1].name, Color[clr]);
      Color_struct[Field-1].red = R[clr];
      Color_struct[Field-1].green = G[clr];
      Color_struct[Field-1].blue = B[clr];
      Color_struct[Field-1].pix_val = Color_val[clr];
      sprintf(Color_struct[Field-1].hexval, "#%.4x%.4x%.4x",
              (R[clr]*256), (G[clr]*256), (B[clr]*256));
    } /* end else Sort_flag == FALSE */

    colorize_can2();
    can2_draw_text();
    can2_draw_rect();
    highlight_field();

  } /* end if event_id(event) == ... */
  else if (event_id(event) == MS_RIGHT && event_is_down(event))
    {
    x = event_x(event);
    y = event_y(event);
    n = Last_color - First_color;
    size = sqrt((double)n);
    isize = size;
    xsize = (Can_width / isize) + 1;
    if (size > (double)isize)
      ysize = (Can_height / (isize + 1)) + 1;
    else
      ysize = (Can_height / isize) + 1;
    xindex = x / xsize;
    yindex = y / ysize;
    clr = (yindex * isize) + xindex + First_color;

    if (Sort_flag == TRUE)
      {
      sprintf(string, "Color is: %s", Sortednames[clr]);
      xv_set(Cscale_edit_window1->color_message, PANEL_LABEL_STRING,
             string, NULL);
    } /* end if Sort_flag == TRUE */
    else
      {
      sprintf(string, "Color is: %s", Color[clr]);
      xv_set(Cscale_edit_window1->color_message, PANEL_LABEL_STRING,
             string, NULL);
    } /* end else Sort_flag == FALSE */

  } /* end else if event_id(event) == ... */
  
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

  return notify_next_event_func(win, (Notify_event) event, arg, type);

} /* end can_event_proc */



/*
 * Repaint callback function for `canvas1'.
 */
void
can_repaint_proc(canvas, paint_window, display, xid, rects)
	Canvas		canvas;
	Xv_window	paint_window;
	Display		*display;
	Window		xid;
	Xv_xrectlist	*rects;
{

  repaint_canvas();
  
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

} /* end can_repaint_proc */



/*
 * Event callback function for `canvas2'.
 */
Notify_value
can2_event_proc(win, event, arg, type)
	Xv_window	win;
	Event		*event;
	Notify_arg	arg;
	Notify_event_type type;
{
  int i, x, y;
  int ysize;
  char string[128];
  cscale_edit_window1_objects *ip = (cscale_edit_window1_objects *)
    xv_get(xv_get(win, CANVAS_PAINT_CANVAS_WINDOW), XV_KEY_DATA, INSTANCE);
  
  if (event_action(event) == ACTION_DRAG_LOAD)
    {
    char name[MAXPATHLEN];
    if (gdd_get_drag_name(win, name) != -1)
      fprintf(stderr, "cscale_edit: can2_event_proc: load %s\n", name);
  } /* end if event_action(event) == ... */
  else if (event_action(event) == ACTION_MENU && event_is_down(event))
    {
    Menu menu = (Menu)xv_get(win, WIN_MENU);
    if (menu)
      menu_show(menu, win, event, 0);
  } /* end else if event_action(event) == ... */

  if (event_id(event) == MS_LEFT && event_is_down(event))
    {
    x = event_x(event);
    y = event_y(event);
    ysize = Can2_height / Num_fields;

    for (i = 1; i <= Num_fields; i++)
      if ((y < (i * ysize)) && (y >= ((i-1) * ysize)))
        Field = i;
      else if (Num_fields == 1)
        Field = i;

    colorize_can2();
    can2_draw_text();
    can2_draw_rect();
    highlight_field();

    if (Field == Num_fields)
      {
      sprintf(string, "%lg", Color_struct[Field-1].min_val);
      xv_set(Cscale_edit_window1->min, PANEL_VALUE, string, NULL);
    } /* end if Field == Num_fields */
    else
      {
      Color_struct[Field-1].min_val = Color_struct[Field].max_val;
      sprintf(string, "%lg", Color_struct[Field-1].min_val);
      xv_set(Cscale_edit_window1->min, PANEL_VALUE, string, NULL);
    } /* end else Field != Num_fields */

    sprintf(string, "Color is: %s", Color_struct[Field-1].name);
    xv_set(Cscale_edit_window1->color_message, PANEL_LABEL_STRING,
           string, NULL);
    xv_set(Cscale_edit_window1->color_label, PANEL_VALUE,
           Color_struct[Field-1].label, NULL);
    sprintf(string, "%lg", Color_struct[Field-1].max_val);
    xv_set(Cscale_edit_window1->max, PANEL_VALUE, string, NULL);

  } /* end if event_id(event) == ... */
  else if (event_id(event) == MS_RIGHT && event_is_down(event))
    {
    x = event_x(event);
    y = event_y(event);
    ysize = Can2_height / Num_fields;

    for (i = 1; i <= Num_fields;  i++)
      if ((y < (i * ysize)) && (y >= ((i-1) * ysize)))
        Field = i;
      else if (Num_fields == 1)
        Field = i;

    sprintf(string, "Color is: %s", Color_struct[Field-1].name);
    xv_set(Cscale_edit_window1->color_message, PANEL_LABEL_STRING,
           string, NULL);
    xv_set(Cscale_edit_window1->color_label, PANEL_VALUE,
           Color_struct[Field-1].label, NULL);
  } /* end else if event_id(event) == ... */
 
  
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

  return notify_next_event_func(win, (Notify_event) event, arg, type);

} /* end can2_event_proc */



/*
 * Repaint callback function for `canvas2'.
 */
void
can2_repaint_proc(canvas, paint_window, display, xid, rects)
	Canvas		canvas;
	Xv_window	paint_window;
	Display		*display;
	Window		xid;
	Xv_xrectlist	*rects;
{

  colorize_can2();
  can2_draw_text();
  can2_draw_rect();
  highlight_field();
  
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

} /* end can2_repaint_proc */



/* 
 * repaint_canvas
 */

repaint_canvas()
{
  int i, j;
  Window root;   /* root window ID of drawable */
  int border_width;
  int num_colors;
  int color, isize;
  int xoff, yoff, xsize, ysize, xlim;
  double size;
  
  XGetGeometry(Dpy, Canvas_xid, &root, &Can_x, &Can_y, &Can_width,
               &Can_height, &border_width, &Can_depth);
  num_colors = Last_color - First_color;
  XSetForeground(Dpy, Gc, BlackPixel(Dpy,0));
  XFillRectangle(Dpy, Canvas_xid, Gc, 0, 0, Can_width, Can_height);
  isize = sqrt((double)num_colors);
  xsize = (Can_width / isize) + 1;
  xlim = xsize * isize;
  if (sqrt((double)num_colors) > (double)isize)
    ysize = (Can_height / (isize + 1)) + 1;
  else
    ysize = (Can_height / isize) + 1;
  i = 0;
  j = 0;
  xoff = 0;
  yoff = 0;
  color = First_color;

  while (color < Last_color)
    {
    XSetForeground(Dpy, Gc, Color_val[color]);
    XFillRectangle(Dpy, Canvas_xid, Gc, xoff, yoff, xsize, ysize);
    xoff += xsize;

    if(xoff >= xlim)
      {
      xoff = 0;
      yoff += ysize;
    } /* end if xoff >= xlim */

    color++;
  } /* end while color < Last_color */

} /* end repaint canvas */



/*
 * colorize_can2
 */

colorize_can2()
{
  Window root;    /* Root window ID of drawable */
  int border_width, num, i, j;
  int rect_height;

  if (Num_fields <= 1)
    Num_fields = 1;
  Canvas2_xid = xv_get(canvas_paint_window(Cscale_edit_window1->canvas2),
                       XV_XID);
  XGetGeometry(Dpy, Canvas2_xid, &root, &Can2_x, &Can2_y, &Can2_width,
               &Can2_height, &border_width, &Can2_depth);
  rect_height = Can2_height / Num_fields;
  XSetForeground(Dpy, Gc, BlackPixel(Dpy,0));
  XFillRectangle(Dpy, Canvas2_xid, Gc, 0, 0, Can2_width, Can2_height);

  for (i = 0; i < Num_fields; i++)
    {
    XSetForeground(Dpy, Gc, Color_struct[i].pix_val);
    XFillRectangle(Dpy, Canvas2_xid, Gc, 0, (i * rect_height),
                   (Can2_width / 3), rect_height);
  } /* end for i = 0 to Num_fields */

} /* end colorize_can2 */



/*
 * can2_draw_text
 */

can2_draw_text()
{
  Window root;    /* Root window ID of drawable */
  int rect_height, i;
  int border_width;
  int font_height;
  char string[15];
  XFontStruct *font_info;
  char *fontname = "6x10";

  if ((font_info = XLoadQueryFont(Dpy, fontname)) == NULL)
    fprintf(stderr, "Cannot open font\n");
  Canvas2_xid = xv_get(canvas_paint_window(Cscale_edit_window1->canvas2),
                       XV_XID);
  XGetGeometry(Dpy, Canvas2_xid, &root, &Can2_x, &Can2_y, &Can2_width,
               &Can2_height, &border_width, &Can2_depth);
  rect_height = Can2_height / Num_fields;
  font_height = font_info->ascent + font_info->descent;
  colorize_can2();
  XSetForeground(Dpy, Gc, WhitePixel(Dpy,0));
  sprintf(string, "%lg", Color_struct[Num_fields-1].min_val);
  XDrawString(Dpy, Canvas2_xid, Gc, (Can2_width / 3 + 15),
              (rect_height * Num_fields), string, strlen(string));

  for (i = 0; i < Num_fields; i++)
    {
    sprintf(string, "%lg", Color_struct[i].max_val);
    XDrawString(Dpy, Canvas2_xid, Gc, (Can2_width / 3 + 15),
                (rect_height * i + font_height), string, strlen(string));
  } /* end for i = 0 to Num_fields */

} /* end can2_draw_text */



/*
 * can2_draw_rect
 */

can2_draw_rect()
{
  Window root;    /* Root window ID of drawable */
  int i, border_width;
  int rect_height;

  if (Num_fields <= 1)
    Num_fields = 1;
  Canvas2_xid = xv_get(canvas_paint_window(Cscale_edit_window1->canvas2),
                       XV_XID);
  XGetGeometry(Dpy, Canvas2_xid, &root, &Can2_x, &Can2_y, &Can2_width,
               &Can2_height, &border_width, &Can2_depth);
  rect_height = Can2_height / Num_fields;

  for (i = Num_fields; i > 0; i--)
    {
    XSetForeground(Dpy,Gc, WhitePixel(Dpy,0));
    XDrawLine(Dpy, Canvas2_xid, Gc, (Can2_width / 3),
              ((i - 1) * rect_height), (Can2_width / 4),
              ((i - 1) * rect_height));
  } /* end for i = Num_fields to 0 */

} /* end can2_draw_rect */



/*
 * highlight_field
 */

highlight_field()
{
  Window root;    /* Root window ID of drawable */
  int ysize;
  
  ysize = Can2_height / Num_fields;
  XSetForeground(Dpy, Gc, WhitePixel(Dpy,0));
  XSetLineAttributes(Dpy, Gc, 4, LineSolid, CapButt, JoinMiter);
  XDrawLine(Dpy, Canvas2_xid, Gc, (Can2_width / 3 + 5),
            ((Field - 1) * ysize), (Can2_width / 3 + 5),
            ((Field - 1) * ysize + ysize));
  XSetLineAttributes(Dpy, Gc, 1, LineSolid, CapButt, JoinMiter);

} /* end highlight_field */



/*
 * sort_func - used for sorting deltas
 */
static int
sort_func(entry1, entry2)
      SORT_STRUCT **entry1, **entry2;
{

  if ((*entry1)->delta < (*entry2)->delta)
    return(-1);
  else if ((*entry1)->delta > (*entry2)->delta)
    return(1);
  else
    return(0);

} /* end sort_func */



/*
 * Notify callback function for `color_label'.
 */
Panel_setting
label_proc(item, event)
	Panel_item	item;
	Event		*event;
{
  cscale_edit_window1_objects *ip = (cscale_edit_window1_objects *)
    xv_get(item, XV_KEY_DATA, INSTANCE);
  char *value = (char *) xv_get(item, PANEL_VALUE);
  
  sprintf(Color_struct[Field-1].label, "%s", value);
  
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

  return panel_text_notify(item, event);

} /* end label_proc */



/*
 * Notify callback function for `insert_above'.
 */
void
insert_above_proc(item, event)
	Panel_item	item;
	Event		*event;
{
  cscale_edit_window1_objects *ip = (cscale_edit_window1_objects *)
    xv_get(item, XV_KEY_DATA, INSTANCE);
  int i;
  
  xv_set(Cscale_edit_window1->status_message, PANEL_LABEL_STRING,
         "Status:", NULL);

  if (Field > 0)
    {
    Num_fields += 1;
    xv_set(Cscale_edit_window1->fields, PANEL_VALUE, Num_fields, NULL);
    for (i = (Num_fields - 1); i > (Field - 1); i--)
      Color_struct[i] = Color_struct[i-1];
    if (Field != 1)
      Color_struct[Field-1].max_val = Color_struct[Field-2].min_val;
    else
      Color_struct[Field-1].max_val = 0;
    Color_struct[Field-1].min_val = Color_struct[Field].max_val;
    strcpy(Color_struct[Field-1].hexval, " ");
    strcpy(Color_struct[Field-1].name, " ");
    strcpy(Color_struct[Field-1].label, " ");
    Color_struct[Field-1].red = 255;
    Color_struct[Field-1].green = 255;
    Color_struct[Field-1].blue = 255;
    Color_struct[Field-1].pix_val = 0;
  } /* end if Field > 0 */

  colorize_can2();
  can2_draw_text();
  can2_draw_rect();
  highlight_field();
  
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

} /* end insert_above_proc */



/*
 * Notify callback function for `insert_below'.
 */
void
insert_below_proc(item, event)
	Panel_item	item;
	Event		*event;
{
  cscale_edit_window1_objects *ip = (cscale_edit_window1_objects *)
    xv_get(item, XV_KEY_DATA, INSTANCE);
  int i;

  xv_set(Cscale_edit_window1->status_message, PANEL_LABEL_STRING,
         "Status:", NULL);

  if (Field > 0)
    {
    Num_fields += 1;
    xv_set(Cscale_edit_window1->fields, PANEL_VALUE, Num_fields, NULL);
    if ((Num_fields - 1) != Field)
      for (i = Num_fields; i > Field; i--)
        Color_struct[i] = Color_struct[i-1];
    Color_struct[Field].max_val = Color_struct[Field-1].min_val;
    if ((Num_fields - 1) != Field)
      Color_struct[Field].min_val = Color_struct[Field+1].max_val;
    else
      Color_struct[Field].min_val = 0;
    strcpy(Color_struct[Field].hexval, " ");
    strcpy(Color_struct[Field].name, " ");
    strcpy(Color_struct[Field].label, " ");
    Color_struct[Field].red = 255;
    Color_struct[Field].green = 255;
    Color_struct[Field].blue = 255;
    Color_struct[Field].pix_val = 0;
    Field += 1;
  } /* end if Field > 0 */
 
  colorize_can2();
  can2_draw_text();
  can2_draw_rect();
  highlight_field();
  
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */
/* end insert_below_proc */
}
