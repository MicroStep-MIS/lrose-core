// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* 
// ** Copyright UCAR (c) 1990 - 2016                                         
// ** University Corporation for Atmospheric Research (UCAR)                 
// ** National Center for Atmospheric Research (NCAR)                        
// ** Boulder, Colorado, USA                                                 
// ** BSD licence applies - redistribution and use in source and binary      
// ** forms, with or without modification, are permitted provided that       
// ** the following conditions are met:                                      
// ** 1) If the software is modified to produce derivative works,            
// ** such modified software should be clearly marked, so as not             
// ** to confuse it with the version available from UCAR.                    
// ** 2) Redistributions of source code must retain the above copyright      
// ** notice, this list of conditions and the following disclaimer.          
// ** 3) Redistributions in binary form must reproduce the above copyright   
// ** notice, this list of conditions and the following disclaimer in the    
// ** documentation and/or other materials provided with the distribution.   
// ** 4) Neither the name of UCAR nor the names of its contributors,         
// ** if any, may be used to endorse or promote products derived from        
// ** this software without specific prior written permission.               
// ** DISCLAIMER: THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS  
// ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      
// ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    
// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* 
////////////////////////////////////////////
// Params.cc
//
// TDRP C++ code file for class 'Params'.
//
// Code for program Windtracer2Dsr
//
// This file has been automatically
// generated by TDRP, do not modify.
//
/////////////////////////////////////////////

/**
 *
 * @file Params.cc
 *
 * @class Params
 *
 * This class is automatically generated by the Table
 * Driven Runtime Parameters (TDRP) system
 *
 * @note Source is automatically generated from
 *       paramdef file at compile time, do not modify
 *       since modifications will be overwritten.
 *
 *
 * @author Automatically generated
 *
 */
using namespace std;

#include "Params.hh"
#include <cstring>

  ////////////////////////////////////////////
  // Default constructor
  //

  Params::Params()

  {

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // initialize table

    _init();

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Copy constructor
  //

  Params::Params(const Params& source)

  {

    // sync the source object

    source.sync();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // copy table

    tdrpCopyTable((TDRPtable *) source._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Destructor
  //

  Params::~Params()

  {

    // free up

    freeAll();

  }

  ////////////////////////////////////////////
  // Assignment
  //

  void Params::operator=(const Params& other)

  {

    // sync the other object

    other.sync();

    // free up any existing memory

    freeAll();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // copy table

    tdrpCopyTable((TDRPtable *) other._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = other._exitDeferred;

  }

  ////////////////////////////////////////////
  // loadFromArgs()
  //
  // Loads up TDRP using the command line args.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   char **params_path_p:
  //     If this is non-NULL, it is set to point to the path
  //     of the params file used.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromArgs(int argc, char **argv,
                           char **override_list,
                           char **params_path_p,
                           bool defer_exit)
  {
    int exit_deferred;
    if (_tdrpLoadFromArgs(argc, argv,
                          _table, &_start_,
                          override_list, params_path_p,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadApplyArgs()
  //
  // Loads up TDRP using the params path passed in, and applies
  // the command line args for printing and checking.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   const char *param_file_path: the parameter file to be read in
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadApplyArgs(const char *params_path,
                            int argc, char **argv,
                            char **override_list,
                            bool defer_exit)
  {
    int exit_deferred;
    if (tdrpLoadApplyArgs(params_path, argc, argv,
                          _table, &_start_,
                          override_list,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  //

  bool Params::isArgValid(const char *arg)
  {
    return (tdrpIsArgValid(arg));
  }

  ////////////////////////////////////////////
  // load()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to load
  // up more than one class for a single application. It is a
  // lower-level routine than loadFromArgs, and hence more
  // flexible, but the programmer must do more work.
  //
  //   const char *param_file_path: the parameter file to be read in.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::load(const char *param_file_path,
                   char **override_list,
                   int expand_env, int debug)
  {
    if (tdrpLoad(param_file_path,
                 _table, &_start_,
                 override_list,
                 expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadFromBuf()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to
  // load up more than one module for a single application,
  // using buffers which have been read from a specified source.
  //
  //   const char *param_source_str: a string which describes the
  //     source of the parameter information. It is used for
  //     error reporting only.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   const char *inbuf: the input buffer
  //
  //   int inlen: length of the input buffer
  //
  //   int start_line_num: the line number in the source which
  //     corresponds to the start of the buffer.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromBuf(const char *param_source_str,
                          char **override_list,
                          const char *inbuf, int inlen,
                          int start_line_num,
                          int expand_env, int debug)
  {
    if (tdrpLoadFromBuf(param_source_str,
                        _table, &_start_,
                        override_list,
                        inbuf, inlen, start_line_num,
                        expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadDefaults()
  //
  // Loads up default params for a given class.
  //
  // See load() for more detailed info.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadDefaults(int expand_env)
  {
    if (tdrpLoad(NULL,
                 _table, &_start_,
                 NULL, expand_env, FALSE)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // sync()
  //
  // Syncs the user struct data back into the parameter table,
  // in preparation for printing.
  //
  // This function alters the table in a consistent manner.
  // Therefore it can be regarded as const.
  //

  void Params::sync(void) const
  {
    tdrpUser2Table(_table, (char *) &_start_);
  }

  ////////////////////////////////////////////
  // print()
  // 
  // Print params file
  //
  // The modes supported are:
  //
  //   PRINT_SHORT:   main comments only, no help or descriptions
  //                  structs and arrays on a single line
  //   PRINT_NORM:    short + descriptions and help
  //   PRINT_LONG:    norm  + arrays and structs expanded
  //   PRINT_VERBOSE: long  + private params included
  //

  void Params::print(FILE *out, tdrp_print_mode_t mode)
  {
    tdrpPrint(out, _table, _className, mode);
  }

  ////////////////////////////////////////////
  // checkAllSet()
  //
  // Return TRUE if all set, FALSE if not.
  //
  // If out is non-NULL, prints out warning messages for those
  // parameters which are not set.
  //

  int Params::checkAllSet(FILE *out)
  {
    return (tdrpCheckAllSet(out, _table, &_start_));
  }

  //////////////////////////////////////////////////////////////
  // checkIsSet()
  //
  // Return TRUE if parameter is set, FALSE if not.
  //
  //

  int Params::checkIsSet(const char *paramName)
  {
    return (tdrpCheckIsSet(paramName, _table, &_start_));
  }

  ////////////////////////////////////////////
  // freeAll()
  //
  // Frees up all TDRP dynamic memory.
  //

  void Params::freeAll(void)
  {
    tdrpFreeAll(_table, &_start_);
  }

  ////////////////////////////////////////////
  // usage()
  //
  // Prints out usage message for TDRP args as passed
  // in to loadFromArgs().
  //

  void Params::usage(ostream &out)
  {
    out << "TDRP args: [options as below]\n"
        << "   [ -params path ] specify params file path\n"
        << "   [ -check_params] check which params are not set\n"
        << "   [ -print_params [mode]] print parameters\n"
        << "     using following modes, default mode is 'norm'\n"
        << "       short:   main comments only, no help or descr\n"
        << "                structs and arrays on a single line\n"
        << "       norm:    short + descriptions and help\n"
        << "       long:    norm  + arrays and structs expanded\n"
        << "       verbose: long  + private params included\n"
        << "       short_expand:   short with env vars expanded\n"
        << "       norm_expand:    norm with env vars expanded\n"
        << "       long_expand:    long with env vars expanded\n"
        << "       verbose_expand: verbose with env vars expanded\n"
        << "   [ -tdrp_debug] debugging prints for tdrp\n"
        << "   [ -tdrp_usage] print this usage\n";
  }

  ////////////////////////////////////////////
  // arrayRealloc()
  //
  // Realloc 1D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::arrayRealloc(const char *param_name, int new_array_n)
  {
    if (tdrpArrayRealloc(_table, &_start_,
                         param_name, new_array_n)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // array2DRealloc()
  //
  // Realloc 2D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::array2DRealloc(const char *param_name,
                             int new_array_n1,
                             int new_array_n2)
  {
    if (tdrpArray2DRealloc(_table, &_start_, param_name,
                           new_array_n1, new_array_n2)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // _init()
  //
  // Class table initialization function.
  //
  //

  void Params::_init()

  {

    TDRPtable *tt = _table;

    // Parameter 'Comment 0'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 0");
    tt->comment_hdr = tdrpStrDup("DATA INPUT.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'InDir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("InDir");
    tt->descr = tdrpStrDup("Input directory.");
    tt->help = tdrpStrDup("Directory path for input data files.");
    tt->val_offset = (char *) &InDir - &_start_;
    tt->single_val.s = tdrpStrDup("./");
    tt++;
    
    // Parameter 'fileExtension'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("fileExtension");
    tt->descr = tdrpStrDup("Input file extension.");
    tt->help = tdrpStrDup("If string is NULL, all extensions are valid.");
    tt->val_offset = (char *) &fileExtension - &_start_;
    tt->single_val.s = tdrpStrDup("");
    tt++;
    
    // Parameter 'max_realtime_valid_age'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("max_realtime_valid_age");
    tt->descr = tdrpStrDup("Max age of input data");
    tt->help = tdrpStrDup("For realtime only - max age of input data for it to be valid");
    tt->val_offset = (char *) &max_realtime_valid_age - &_start_;
    tt->single_val.i = 1800;
    tt++;
    
    // Parameter 'temp_file'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("temp_file");
    tt->descr = tdrpStrDup("The CTI data file has an ASCII section embedded in it.\nDuring processing this ascii section is written to this temporary\nfile (which is overwritten each time a new CTI file is processed).");
    tt->help = tdrpStrDup("ASCII section contains information on LIDAR setup.");
    tt->val_offset = (char *) &temp_file - &_start_;
    tt->single_val.s = tdrpStrDup("./ascii_header.txt");
    tt++;
    
    // Parameter 'tag_line'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("tag_line");
    tt->descr = tdrpStrDup("The ASCII section of the CTI file has several sections in\nit. The YEAR, MONTH, DAY and SAMPLE_FREQUENCY are read from the\nstart of the file, but other parameters such as the RAW_DATA_OFFSET_METERS,\nRANGE_GATES and GATES_TO_MERGE appear several times in different\nsections of the file. The tag_line parameter allows the user to\ndetermines which section to read these parameters from.");
    tt->help = tdrpStrDup("You can use the less command to view the ASCII section of a CTI\nlidar file - it is towards the front of the file.");
    tt->val_offset = (char *) &tag_line - &_start_;
    tt->single_val.s = tdrpStrDup("# VELOCITY, ASCOPE, VAD, UVW, BACK PROP RAW DATA PARAMETERS SECTION");
    tt++;
    
    // Parameter 'Comment 1'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 1");
    tt->comment_hdr = tdrpStrDup("DEBUGGING AND PROCESS CONTROL");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'debug'
    // ctype is '_debug_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("debug");
    tt->descr = tdrpStrDup("Debug option");
    tt->help = tdrpStrDup("If set, debug messages will be printed appropriately");
    tt->val_offset = (char *) &debug - &_start_;
    tt->enum_def.name = tdrpStrDup("debug_t");
    tt->enum_def.nfields = 3;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("DEBUG_OFF");
      tt->enum_def.fields[0].val = DEBUG_OFF;
      tt->enum_def.fields[1].name = tdrpStrDup("DEBUG_NORM");
      tt->enum_def.fields[1].val = DEBUG_NORM;
      tt->enum_def.fields[2].name = tdrpStrDup("DEBUG_DATA");
      tt->enum_def.fields[2].val = DEBUG_DATA;
    tt->single_val.e = DEBUG_OFF;
    tt++;
    
    // Parameter 'msgLog_dir'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("msgLog_dir");
    tt->descr = tdrpStrDup("Directory for log file output");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &msgLog_dir - &_start_;
    tt->single_val.s = tdrpStrDup("");
    tt++;
    
    // Parameter 'info'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("info");
    tt->descr = tdrpStrDup("Info option");
    tt->help = tdrpStrDup("Print info messages");
    tt->val_offset = (char *) &info - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'instance'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("instance");
    tt->descr = tdrpStrDup("Process instance");
    tt->help = tdrpStrDup("Used for registration with procmap.");
    tt->val_offset = (char *) &instance - &_start_;
    tt->single_val.s = tdrpStrDup("Test");
    tt++;
    
    // Parameter 'mode'
    // ctype is '_op_mode'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("mode");
    tt->descr = tdrpStrDup("Operation mode");
    tt->help = tdrpStrDup("Program may be run in two modes, archive and realtime. In realtime mode, the conversion is performed for each input file as it becomes available. In archive mode, the file list is obtained from the command line.");
    tt->val_offset = (char *) &mode - &_start_;
    tt->enum_def.name = tdrpStrDup("op_mode");
    tt->enum_def.nfields = 2;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("ARCHIVE");
      tt->enum_def.fields[0].val = ARCHIVE;
      tt->enum_def.fields[1].name = tdrpStrDup("REALTIME");
      tt->enum_def.fields[1].val = REALTIME;
    tt->single_val.e = REALTIME;
    tt++;
    
    // Parameter 'output_fmq_url'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("output_fmq_url");
    tt->descr = tdrpStrDup("output fmq url");
    tt->help = tdrpStrDup("Path for FMQ output data.");
    tt->val_offset = (char *) &output_fmq_url - &_start_;
    tt->single_val.s = tdrpStrDup("fmqp:://localhost::./fmq.dsLidar");
    tt++;
    
    // Parameter 'output_fmq_size'
    // ctype is 'long'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = LONG_TYPE;
    tt->param_name = tdrpStrDup("output_fmq_size");
    tt->descr = tdrpStrDup("Size of output FMQ, in bytes.");
    tt->help = tdrpStrDup("This is the total size of the output FMQ buffer. Some of this buffer will be used for control bytes (12 bytes per message.");
    tt->val_offset = (char *) &output_fmq_size - &_start_;
    tt->single_val.l = 2000000;
    tt++;
    
    // Parameter 'output_fmq_nslots'
    // ctype is 'long'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = LONG_TYPE;
    tt->param_name = tdrpStrDup("output_fmq_nslots");
    tt->descr = tdrpStrDup("Number of slots in output FMQ.");
    tt->help = tdrpStrDup("The number of slots corresponds to the maximum number of messages which may be written to the buffer before overwrites occur. However, overwrites may occur sooner if the size is not set large enough.");
    tt->val_offset = (char *) &output_fmq_nslots - &_start_;
    tt->single_val.l = 3600;
    tt++;
    
    // Parameter 'output_fmq_compress'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("output_fmq_compress");
    tt->descr = tdrpStrDup("FMQ compression option.");
    tt->help = tdrpStrDup("If TRUE FMQ messages are compressed.");
    tt->val_offset = (char *) &output_fmq_compress - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 2'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 2");
    tt->comment_hdr = tdrpStrDup("LIDAR PARAMETERS");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'lidarID'
    // ctype is '_lidarID_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("lidarID");
    tt->descr = tdrpStrDup("Description of this lidar.");
    tt->help = tdrpStrDup("lat/lon info is not in the input files.");
    tt->val_offset = (char *) &lidarID - &_start_;
    tt->struct_def.name = tdrpStrDup("lidarID_t");
    tt->struct_def.nfields = 5;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("int");
      tt->struct_def.fields[0].fname = tdrpStrDup("lidarNumber");
      tt->struct_def.fields[0].ptype = INT_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &lidarID.lidarNumber - (char *) &lidarID;
      tt->struct_def.fields[1].ftype = tdrpStrDup("string");
      tt->struct_def.fields[1].fname = tdrpStrDup("Name");
      tt->struct_def.fields[1].ptype = STRING_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &lidarID.Name - (char *) &lidarID;
      tt->struct_def.fields[2].ftype = tdrpStrDup("double");
      tt->struct_def.fields[2].fname = tdrpStrDup("lat");
      tt->struct_def.fields[2].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &lidarID.lat - (char *) &lidarID;
      tt->struct_def.fields[3].ftype = tdrpStrDup("double");
      tt->struct_def.fields[3].fname = tdrpStrDup("lon");
      tt->struct_def.fields[3].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[3].rel_offset = 
        (char *) &lidarID.lon - (char *) &lidarID;
      tt->struct_def.fields[4].ftype = tdrpStrDup("double");
      tt->struct_def.fields[4].fname = tdrpStrDup("alt");
      tt->struct_def.fields[4].ptype = DOUBLE_TYPE;
      tt->struct_def.fields[4].rel_offset = 
        (char *) &lidarID.alt - (char *) &lidarID;
    tt->n_struct_vals = 5;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].i = 42;
      tt->struct_vals[1].s = tdrpStrDup("TestLidar");
      tt->struct_vals[2].d = 42;
      tt->struct_vals[3].d = -95;
      tt->struct_vals[4].d = 1.02;
    tt++;
    
    // Parameter 'readLocationFromFile'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("readLocationFromFile");
    tt->descr = tdrpStrDup("Option to try to read the lidar location from a file.\nIf set, the location set in the lidarID struct (lat, lon\nand altitude) is overridden by reading the location\nfrom an ASCII file that has a record of the lidars movements.");
    tt->help = tdrpStrDup("Format of the file is as follows : \nYYYY-MM-DD hh:mm:ss timeZone lat lon alt altUnits, ie.\n2003-09-24 09:47:00  MDT  40.1234 -113.115 1350 Meters\n2003-10-03 12:00:00  MDT  41.345  -114.234 1250 Meters\nIf the data time is less than the first time, then the\nfirst lat/lon are used. If the time is after the last entry\nthen the last entry is used. If the data time is between two\nentry times, then the entry at the time that preceedes\nthe data time is used.\n\nAt the time of writing, the timeZone and the altUnits\nstrings are ignored. The time is adjusted to UTC by\nadding the time_offset parameter to it, and the altitude is\nassumed to be in meters.");
    tt->val_offset = (char *) &readLocationFromFile - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'locationFile'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("locationFile");
    tt->descr = tdrpStrDup("File from which to read lidar location if\nreadLocationFromFile is TRUE.");
    tt->help = tdrpStrDup("See comments for readLocationFromFile parameter above.");
    tt->val_offset = (char *) &locationFile - &_start_;
    tt->single_val.s = tdrpStrDup("/some/file/name.dat");
    tt++;
    
    // Parameter 'Comment 3'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 3");
    tt->comment_hdr = tdrpStrDup("FIELD PARAMETERS");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'MaxAbsDataVal'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("MaxAbsDataVal");
    tt->descr = tdrpStrDup("Maximum absolute value for data values.");
    tt->help = tdrpStrDup("Data values outside this range are marked as bad.\nThe default should be fine since -999 seems to be\nwhat is used to delineate bad values in the input file.");
    tt->val_offset = (char *) &MaxAbsDataVal - &_start_;
    tt->single_val.d = 990;
    tt++;
    
    // Parameter 'fields'
    // ctype is '_field_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRUCT_TYPE;
    tt->param_name = tdrpStrDup("fields");
    tt->descr = tdrpStrDup("Fields are recognized by their Windtracer codes and given\nan output field name. These codes MUST be specified in the\norder in which they occur in the input file (ie. the codes\nmust be in ascending order) or the output fields will be labelled\nincorrectly.");
    tt->help = tdrpStrDup("The defaults are very probably fine. The options are :\n\n VEL  (Windtracer code 30) - velocity\n SNR  (Windtracer code 31) - signal-to-noise, analagous to dBz\n SW   (Windtracer code 33) - spectral width\n FVEL (Windtracer code 85) - median filtered velocity\n FSNR (Windtracer code 86) - filtered signal-to-noise.\n\nThere are other options which I have documented");
    tt->array_offset = (char *) &_fields - &_start_;
    tt->array_n_offset = (char *) &fields_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(field_t);
    tt->array_n = 5;
    tt->struct_def.name = tdrpStrDup("field_t");
    tt->struct_def.nfields = 3;
    tt->struct_def.fields = (struct_field_t *)
        tdrpMalloc(tt->struct_def.nfields * sizeof(struct_field_t));
      tt->struct_def.fields[0].ftype = tdrpStrDup("int");
      tt->struct_def.fields[0].fname = tdrpStrDup("windtracerCode");
      tt->struct_def.fields[0].ptype = INT_TYPE;
      tt->struct_def.fields[0].rel_offset = 
        (char *) &_fields->windtracerCode - (char *) _fields;
      tt->struct_def.fields[1].ftype = tdrpStrDup("string");
      tt->struct_def.fields[1].fname = tdrpStrDup("outputFieldName");
      tt->struct_def.fields[1].ptype = STRING_TYPE;
      tt->struct_def.fields[1].rel_offset = 
        (char *) &_fields->outputFieldName - (char *) _fields;
      tt->struct_def.fields[2].ftype = tdrpStrDup("string");
      tt->struct_def.fields[2].fname = tdrpStrDup("units");
      tt->struct_def.fields[2].ptype = STRING_TYPE;
      tt->struct_def.fields[2].rel_offset = 
        (char *) &_fields->units - (char *) _fields;
    tt->n_struct_vals = 15;
    tt->struct_vals = (tdrpVal_t *)
        tdrpMalloc(tt->n_struct_vals * sizeof(tdrpVal_t));
      tt->struct_vals[0].i = 30;
      tt->struct_vals[1].s = tdrpStrDup("VEL");
      tt->struct_vals[2].s = tdrpStrDup("m/s");
      tt->struct_vals[3].i = 31;
      tt->struct_vals[4].s = tdrpStrDup("SNR");
      tt->struct_vals[5].s = tdrpStrDup("none");
      tt->struct_vals[6].i = 33;
      tt->struct_vals[7].s = tdrpStrDup("SW");
      tt->struct_vals[8].s = tdrpStrDup("m");
      tt->struct_vals[9].i = 85;
      tt->struct_vals[10].s = tdrpStrDup("FVEL");
      tt->struct_vals[11].s = tdrpStrDup("m/s");
      tt->struct_vals[12].i = 86;
      tt->struct_vals[13].s = tdrpStrDup("FSNR");
      tt->struct_vals[14].s = tdrpStrDup("none");
    tt++;
    
    // Parameter 'addTimeField'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("addTimeField");
    tt->descr = tdrpStrDup("If set, the time is added to the output.");
    tt->help = tdrpStrDup("This may be desired for use with VLAS.");
    tt->val_offset = (char *) &addTimeField - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'thresholdOnField'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("thresholdOnField");
    tt->descr = tdrpStrDup("If set, threshold each beam according to one field.");
    tt->help = tdrpStrDup("This may be useful if there is a quality control field\nlike CFAR - if CFAR is 2.0 the other fields are good.");
    tt->val_offset = (char *) &thresholdOnField - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'thresholdFieldNum'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("thresholdFieldNum");
    tt->descr = tdrpStrDup("The field number, starting at 0, as ordered in the\nlist above, on which we are to threshold.");
    tt->help = tdrpStrDup("Only relevant if thresholdOnField is TRUE.");
    tt->val_offset = (char *) &thresholdFieldNum - &_start_;
    tt->single_val.i = 0;
    tt++;
    
    // Parameter 'threshMin'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("threshMin");
    tt->descr = tdrpStrDup("The minimum threshold.");
    tt->help = tdrpStrDup("Only relevant if thresholdOnField is TRUE.");
    tt->val_offset = (char *) &threshMin - &_start_;
    tt->single_val.d = 1.5;
    tt++;
    
    // Parameter 'threshMax'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("threshMax");
    tt->descr = tdrpStrDup("The maximum threshold.");
    tt->help = tdrpStrDup("Only relevant if thresholdOnField is TRUE.");
    tt->val_offset = (char *) &threshMax - &_start_;
    tt->single_val.d = 2.5;
    tt++;
    
    // Parameter 'oneFilePerVolume'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("oneFilePerVolume");
    tt->descr = tdrpStrDup("If set, send an end of volume at the end of each input\ndata file. This also causes a start_of_volume to be sent at\nthe start of each data file.");
    tt->help = tdrpStrDup("This may be useful if there is a one to one relationship\nin that there is one file per volume. AT THE TIME OF WRITING THIS\nSHOULD DEFINITELY BE TRUE - later development may change that.");
    tt->val_offset = (char *) &oneFilePerVolume - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'endVolumeOnAzReversal'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("endVolumeOnAzReversal");
    tt->descr = tdrpStrDup("If set, send an end of volume followed by a start of volume\nif the azimuth direction changes.");
    tt->help = tdrpStrDup("This is useful if the lidar is scanning back and forth\nat one elevation.");
    tt->val_offset = (char *) &endVolumeOnAzReversal - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'beamsPerMessage'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("beamsPerMessage");
    tt->descr = tdrpStrDup("How many beams to process before sending radar header message.");
    tt->help = tdrpStrDup("The default should be OK.\n");
    tt->val_offset = (char *) &beamsPerMessage - &_start_;
    tt->single_val.i = 60;
    tt++;
    
    // Parameter 'delaySecs'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("delaySecs");
    tt->descr = tdrpStrDup("After sending the radar header message, delay for this\nmany seconds.");
    tt->help = tdrpStrDup("The intent is to allows Dsr2Vol some catchup time.\n");
    tt->val_offset = (char *) &delaySecs - &_start_;
    tt->single_val.i = 2;
    tt++;
    
    // Parameter 'fileDelaySecs'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("fileDelaySecs");
    tt->descr = tdrpStrDup("After finishing a file, delay for this\nmany seconds.");
    tt->help = tdrpStrDup("The intent is to allows Dsr2Vol some catchup time.\n");
    tt->val_offset = (char *) &fileDelaySecs - &_start_;
    tt->single_val.i = 2;
    tt++;
    
    // Parameter 'horizBeamWidth'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("horizBeamWidth");
    tt->descr = tdrpStrDup("Nominal horizontal beam width, degrees.");
    tt->help = tdrpStrDup("The default should be OK.\n");
    tt->val_offset = (char *) &horizBeamWidth - &_start_;
    tt->single_val.d = 1;
    tt++;
    
    // Parameter 'vertBeamWidth'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("vertBeamWidth");
    tt->descr = tdrpStrDup("Nominal vertical beam width, degrees.");
    tt->help = tdrpStrDup("The default should be OK.\n");
    tt->val_offset = (char *) &vertBeamWidth - &_start_;
    tt->single_val.d = 0.1;
    tt++;
    
    // Parameter 'time_offset'
    // ctype is 'long'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = LONG_TYPE;
    tt->param_name = tdrpStrDup("time_offset");
    tt->descr = tdrpStrDup("Time offset, seconds.");
    tt->help = tdrpStrDup("The Lidar data are typically referenced according to\nlocal time, while UTC is desired for output. This parameter\nis added to the input time to obtain the output time.");
    tt->val_offset = (char *) &time_offset - &_start_;
    tt->single_val.l = 0;
    tt++;
    
    // Parameter 'useRealTime'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("useRealTime");
    tt->descr = tdrpStrDup("Option to use the current time. If this option is\nselected, the time_offset (above) is not added. All the beams are sent\ntimestamped with the run-time of this program.");
    tt->help = tdrpStrDup("This is intended for use in archive mode to simulate\nrealtime operations.");
    tt->val_offset = (char *) &useRealTime - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'azimuth_offset'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("azimuth_offset");
    tt->descr = tdrpStrDup("Azimuth offset, degrees.");
    tt->help = tdrpStrDup("An offset added to the azimuth to correct misalignment.");
    tt->val_offset = (char *) &azimuth_offset - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'elevation_offset'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("elevation_offset");
    tt->descr = tdrpStrDup("Elevation offset, degrees");
    tt->help = tdrpStrDup("An offset added to the elevation angle to correct for\nmisalignment.");
    tt->val_offset = (char *) &elevation_offset - &_start_;
    tt->single_val.d = 0;
    tt++;
    
    // Parameter 'maxDelAz'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("maxDelAz");
    tt->descr = tdrpStrDup("Maximum change in azimuth from one beam to the next\nfor a beam to be sent.");
    tt->help = tdrpStrDup("The intent is to avoid sending beams that are collected\nwhen the lidar is in fact not scanning but rather is racing to\nthe next point in its scan pattern - the instrument is not\nshut down at these times.");
    tt->val_offset = (char *) &maxDelAz - &_start_;
    tt->single_val.d = 3;
    tt++;
    
    // Parameter 'lastElevation'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("lastElevation");
    tt->descr = tdrpStrDup("The final elevation of the scan, degrees.");
    tt->help = tdrpStrDup("After 5 sequential beams at this elevation are encountered,\nthe program assumes that it is on the last scan.\n\nIf the program is on its last scan, then once the elevation\ndeviates from this elevation the file is closed.\n\nThe intent is to stop reading when the last scan is finished\nand close the file, thereby avoiding reading the trailing data\nwhich are probably junk, collected as the scanner moved into\nposition for the next scan. If this is set to a non-existant\nscan like 100 degrees, then the program will read to the end\nof the file.");
    tt->val_offset = (char *) &lastElevation - &_start_;
    tt->single_val.d = 100;
    tt++;
    
    // Parameter 'firstElevation'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("firstElevation");
    tt->descr = tdrpStrDup("First elevation to accept in a scan, degrees.\nRelevant only if firstElevationSpecified is TRUE.");
    tt->help = tdrpStrDup("The intent is similar to that of the lastElevation\nparameter - while lastElevation avoid trailing junk, firstElevation\navoids leading junk in the file. While lastElevation can be made\nirrelevant by setting it to a nonexistant scan, firstElevation\ncannot - therefore, the firstElevationSpecified parameter is used\nto indicate that this parameter is relevant.");
    tt->val_offset = (char *) &firstElevation - &_start_;
    tt->single_val.d = 0.5;
    tt++;
    
    // Parameter 'elevationTolerance'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("elevationTolerance");
    tt->descr = tdrpStrDup("Elevation tolerance, degrees.");
    tt->help = tdrpStrDup("Used to evaluate if the elevation is close enough\nto firstElevation or lastElevation.");
    tt->val_offset = (char *) &elevationTolerance - &_start_;
    tt->single_val.d = 0.1;
    tt++;
    
    // Parameter 'firstElevationSpecified'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("firstElevationSpecified");
    tt->descr = tdrpStrDup("See description for firstElevation parameter above.");
    tt->help = tdrpStrDup("This parameter determines if firstElevation is used.");
    tt->val_offset = (char *) &firstElevationSpecified - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'firstAzimuth'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("firstAzimuth");
    tt->descr = tdrpStrDup("If firstAzimuthSpecified (below) is set to TRUE, then\nthe scanner must reach this azimuth before any beams\nare sent to the FMQ. If a firstElevation is also\nspecified then this amounts to specifying a start\nposition - data collected before this position is reached\nare discarded. The azimuth must match that specified\nto within firstAzimuthTolerance (set below) to be\nconsidered a match.");
    tt->help = tdrpStrDup("Relevant only if firstAzimuthSpecified is TRUE.");
    tt->val_offset = (char *) &firstAzimuth - &_start_;
    tt->single_val.d = 40;
    tt++;
    
    // Parameter 'firstAzimuthTolerance'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("firstAzimuthTolerance");
    tt->descr = tdrpStrDup("See description for firstAzimuth parameter above.");
    tt->help = tdrpStrDup("Relevant only if firstAzimuthSpecified is TRUE.");
    tt->val_offset = (char *) &firstAzimuthTolerance - &_start_;
    tt->single_val.d = 3;
    tt++;
    
    // Parameter 'firstAzimuthSpecified'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("firstAzimuthSpecified");
    tt->descr = tdrpStrDup("See description for firstAzimuth parameter above.");
    tt->help = tdrpStrDup("This parameter determines if firstAzimuth and\nfirstAzimuthTolerance are used.");
    tt->val_offset = (char *) &firstAzimuthSpecified - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'timeFromFilename'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("timeFromFilename");
    tt->descr = tdrpStrDup("Option to take the time from the filename rather than\nreading it from the file itself. Added for realtime\nsimulations. The time_offset is still added to the time that\nis obtained. The filename format is taken to be\nYYYYMMDD_hhmmss_blah, ie.  20020722_231017_base.prd");
    tt->help = tdrpStrDup("Set for realtime simulations.");
    tt->val_offset = (char *) &timeFromFilename - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'minRunLen'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("minRunLen");
    tt->descr = tdrpStrDup("a run of non-missing values in a beam must be at\nleast this long to be accepted. The intent is to avoid short\nruns of non-missing data embedded in missing data as these are\nusually erroneous.");
    tt->help = tdrpStrDup("Avoid making this too big or good values will be rejected.");
    tt->val_offset = (char *) &minRunLen - &_start_;
    tt->single_val.i = 4;
    tt++;
    
    // Parameter 'Comment 4'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 4");
    tt->comment_hdr = tdrpStrDup("Options to test the velocity data for maximum shear.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'doShearTest'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("doShearTest");
    tt->descr = tdrpStrDup("Option to do a shear test on the velocity data.");
    tt->help = tdrpStrDup("If this is set, points in each beam that would cause\na shear that exceeds maxShear are marked as bad. Points near to the lidar\nare trusted over those further away.");
    tt->val_offset = (char *) &doShearTest - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'maxShear'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("maxShear");
    tt->descr = tdrpStrDup("Maximum allowable shear, meters per second per meters.");
    tt->help = tdrpStrDup("Only relevant if doShearTest is TRUE.");
    tt->val_offset = (char *) &maxShear - &_start_;
    tt->single_val.d = 0.025;
    tt++;
    
    // Parameter 'velFieldNum'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("velFieldNum");
    tt->descr = tdrpStrDup("Field number for velocity in the fields[] list above.\nFirst field is number 0.");
    tt->help = tdrpStrDup("Only relevant if doShearTest is TRUE.");
    tt->val_offset = (char *) &velFieldNum - &_start_;
    tt->single_val.i = 0;
    tt++;
    
    // Parameter 'azAscendingOnly'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("azAscendingOnly");
    tt->descr = tdrpStrDup("Option to only read scans that are ascending in azimuth.");
    tt->help = tdrpStrDup("May be helpful if scans double back on themselves.");
    tt->val_offset = (char *) &azAscendingOnly - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'azDescendingOnly'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("azDescendingOnly");
    tt->descr = tdrpStrDup("Option to only read scans that are descending in azimuth.");
    tt->help = tdrpStrDup("May be helpful if scans double back on themselves.");
    tt->val_offset = (char *) &azDescendingOnly - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'roundElevations'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("roundElevations");
    tt->descr = tdrpStrDup("Option to round off elevation angles.");
    tt->help = tdrpStrDup("May be helpful to turn elevations like 1.5001\ninto elevations like 1.5");
    tt->val_offset = (char *) &roundElevations - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'elevationRounding'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("elevationRounding");
    tt->descr = tdrpStrDup("How much to round off elevation angles.");
    tt->help = tdrpStrDup("Relevant only if roundElevations is TRUE");
    tt->val_offset = (char *) &elevationRounding - &_start_;
    tt->single_val.d = 0.1;
    tt++;
    
    // Parameter 'minElevation'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("minElevation");
    tt->descr = tdrpStrDup("Minimum elevation to process, degrees.");
    tt->help = tdrpStrDup("Always applied but default has no effect.");
    tt->val_offset = (char *) &minElevation - &_start_;
    tt->single_val.d = -90;
    tt++;
    
    // Parameter 'maxElevation'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("maxElevation");
    tt->descr = tdrpStrDup("Maximum elevation to process, degrees.");
    tt->help = tdrpStrDup("Always applied but default has no effect.");
    tt->val_offset = (char *) &maxElevation - &_start_;
    tt->single_val.d = 90;
    tt++;
    
    // Parameter 'minAzimuth'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("minAzimuth");
    tt->descr = tdrpStrDup("Minimum azimuth to process, degrees.");
    tt->help = tdrpStrDup("Always applied but default has no effect.");
    tt->val_offset = (char *) &minAzimuth - &_start_;
    tt->single_val.d = -90;
    tt++;
    
    // Parameter 'maxAzimuth'
    // ctype is 'double'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = DOUBLE_TYPE;
    tt->param_name = tdrpStrDup("maxAzimuth");
    tt->descr = tdrpStrDup("Maximum azimuth to process, degrees.");
    tt->help = tdrpStrDup("Always applied but default has no effect.");
    tt->val_offset = (char *) &maxAzimuth - &_start_;
    tt->single_val.d = 400;
    tt++;
    
    // trailing entry has param_name set to NULL
    
    tt->param_name = NULL;
    
    return;
  
  }
